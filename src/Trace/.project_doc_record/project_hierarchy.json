{
  "setup.py": [],
  "opto\\optimizers\\buffers.py": [
    {
      "type": "ClassDef",
      "name": "FIFOBuffer",
      "md_content": [
        "**FIFOBuffer**: The function of FIFOBuffer is to manage a First-In-First-Out (FIFO) buffer of a specified size.\n\n**attributes**: The attributes of this Class.\n· size: The maximum number of items the buffer can hold.\n· buffer: A list that stores the items in the buffer.\n\n**Code Description**: The FIFOBuffer class is designed to handle a buffer that operates on a First-In-First-Out (FIFO) basis. This means that the first item added to the buffer will be the first one to be removed when the buffer reaches its maximum size.\n\n- The `__init__` method initializes the buffer with a specified size and creates an empty list to store the items.\n- The `add` method allows adding an item to the buffer. If the buffer exceeds the specified size, it removes the oldest items to maintain the size constraint.\n- The `__iter__` method returns an iterator for the buffer, allowing it to be used in loops and other iterable contexts.\n- The `__len__` method returns the current number of items in the buffer.\n\nIn the project, the FIFOBuffer is utilized by the `FunctionOptimizerV2Memory` class in the `opto\\optimizers\\function_optimizer.py` file. Specifically, it is instantiated in the `__init__` method of `FunctionOptimizerV2Memory` with a parameter `memory_size`, which determines the size of the FIFO buffer. This integration suggests that the FIFOBuffer is used to store a limited history of optimization states or results, ensuring that only the most recent entries are kept.\n\n**Note**: \n- Ensure that the size parameter is a positive integer to avoid unexpected behavior.\n- The buffer will automatically discard the oldest items when new items are added beyond its capacity.\n\n**Output Example**: \nIf a FIFOBuffer is created with a size of 3 and the following items are added in sequence: `1, 2, 3, 4`, the buffer will contain `[2, 3, 4]`. The first item `1` is discarded to maintain the buffer size of 3."
      ],
      "code_start_line": 1,
      "code_end_line": 16,
      "params": [],
      "have_return": true,
      "code_content": "class FIFOBuffer:\n    # A basic FIFO buffer\n    def __init__(self, size: int):\n        self.size = size\n        self.buffer = []\n\n    def add(self, item):\n        if self.size > 0:\n            self.buffer.append(item)\n            self.buffer = self.buffer[-self.size :]\n\n    def __iter__(self):\n        return iter(self.buffer)\n\n    def __len__(self):\n        return len(self.buffer)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizerV2Memory/__init__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize a FIFOBuffer object with a specified size.\n\n**parameters**: The parameters of this Function.\n· size: An integer representing the maximum size of the buffer.\n\n**Code Description**: The __init__ function is a constructor method for the FIFOBuffer class. It takes one parameter, size, which determines the maximum number of elements that the buffer can hold. Inside the function, the size parameter is assigned to the instance variable self.size. Additionally, an empty list is initialized and assigned to the instance variable self.buffer. This list will be used to store the elements of the buffer.\n\n**Note**: \n- The size parameter must be a positive integer.\n- The buffer is initially empty upon creation of the FIFOBuffer object."
      ],
      "code_start_line": 3,
      "code_end_line": 5,
      "params": [
        "self",
        "size"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, size: int):\n        self.size = size\n        self.buffer = []\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "add",
      "md_content": [
        "**add**: The function of add is to insert a new item into the buffer while maintaining its maximum size.\n\n**parameters**: The parameters of this Function.\n· item: The item to be added to the buffer.\n\n**Code Description**: The add function is a method of the FIFOBuffer class, which is designed to manage a buffer with a fixed maximum size. When a new item is added to the buffer, the function first checks if the buffer size is greater than zero. If it is, the item is appended to the buffer. After appending the item, the buffer is truncated to ensure that its size does not exceed the predefined maximum size. This is achieved by slicing the buffer to keep only the most recent items up to the specified size.\n\nIn the context of its usage within the project, the add function is called by the construct_prompt method of the FunctionOptimizerV2Memory class. Specifically, after constructing the system and user prompts, the add function is used to store a tuple containing the summary variables and user feedback into the memory buffer. This ensures that the memory buffer maintains a record of past interactions, which can be used to provide examples in future prompts.\n\n**Note**: \n- The buffer size must be set to a positive integer for the add function to operate correctly.\n- The function ensures that the buffer does not grow beyond its maximum size, maintaining only the most recent items.\n- Proper handling of the buffer size is crucial to avoid unexpected behavior."
      ],
      "code_start_line": 7,
      "code_end_line": 10,
      "params": [
        "self",
        "item"
      ],
      "have_return": false,
      "code_content": "    def add(self, item):\n        if self.size > 0:\n            self.buffer.append(item)\n            self.buffer = self.buffer[-self.size :]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizerV2Memory/construct_prompt"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__iter__",
      "md_content": [
        "**__iter__**: The function of __iter__ is to return an iterator for the buffer attribute of the FIFOBuffer instance.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The __iter__ function is a special method in Python that allows an object to be iterable. In this implementation, the __iter__ method returns an iterator for the buffer attribute of the FIFOBuffer instance. The buffer attribute is expected to be a collection (such as a list) that supports iteration. By calling iter(self.buffer), the method leverages Python's built-in iter function to obtain an iterator for the buffer, enabling the FIFOBuffer instance to be used in contexts that require iteration, such as in for-loops.\n\n**Note**: \n- Ensure that the buffer attribute is properly initialized and contains iterable elements before invoking the __iter__ method.\n- This method does not modify the buffer; it only provides a way to iterate over its elements.\n\n**Output Example**: \nIf the buffer attribute of the FIFOBuffer instance contains the elements [1, 2, 3], calling the __iter__ method will return an iterator that produces the sequence 1, 2, 3 when iterated over."
      ],
      "code_start_line": 12,
      "code_end_line": 13,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __iter__(self):\n        return iter(self.buffer)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__len__",
      "md_content": [
        "**__len__**: The function of __len__ is to return the number of elements currently stored in the buffer.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The __len__ function is a special method in Python that is used to define the behavior of the len() function for instances of a class. In this context, the __len__ function returns the length of the buffer attribute of the FIFOBuffer class. The buffer attribute is expected to be a list or another collection that supports the len() function. When len() is called on an instance of FIFOBuffer, it internally calls this __len__ method, which in turn returns the length of the buffer.\n\n**Note**: Ensure that the buffer attribute is properly initialized and maintained as a collection that supports the len() function. If the buffer is not initialized or is set to a non-collection type, calling len() on an instance of FIFOBuffer will result in an error.\n\n**Output Example**: If the buffer contains 5 elements, calling len() on an instance of FIFOBuffer will return 5."
      ],
      "code_start_line": 15,
      "code_end_line": 16,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __len__(self):\n        return len(self.buffer)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\optimizers\\function_optimizer.py": [
    {
      "type": "FunctionDef",
      "name": "get_fun_name",
      "md_content": [
        "**get_fun_name**: The function of get_fun_name is to retrieve the name of a MessageNode object.\n\n**parameters**:\n- node: A MessageNode object.\n\n**Code Description**:\nThe `get_fun_name` function is used to retrieve the name of a `MessageNode` object. It takes a `node` parameter, which is an instance of the `MessageNode` class.\n\nThe function first checks if the `info` attribute of the `node` object is a dictionary and if it contains the key \"fun_name\". If this condition is true, the function returns the value associated with that key.\n\nIf the condition is false, the function splits the `name` attribute of the `node` object using the \":\" delimiter. It then returns the first part of the split.\n\nThe purpose of this function is to provide a convenient way to retrieve the name of a `MessageNode` object. The name can be used for various purposes, such as identifying the node in a graph or generating function calls.\n\nThis function is called by the `repr_function_call` function in the `function_optimizer.py` file of the `optimizers` module. It is used to retrieve the name of a `MessageNode` object and include it in a function call representation.\n\n**Note**:\n- The `get_fun_name` function assumes that the `node` object is an instance of the `MessageNode` class.\n- The function relies on the `info` and `name` attributes of the `node` object to retrieve the name.\n\n**Output Example**:\nIf the `info` attribute of the `node` object is a dictionary with the key \"fun_name\" and the associated value is \"my_function\", calling `get_fun_name(node)` will return \"my_function\".\n"
      ],
      "code_start_line": 17,
      "code_end_line": 20,
      "params": [
        "node"
      ],
      "have_return": true,
      "code_content": "def get_fun_name(node: MessageNode):\n    if isinstance(node.info, dict) and \"fun_name\" in node.info:\n        return node.info[\"fun_name\"]\n    return node.name.split(\":\")[0]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/repr_function_call",
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name",
        "opto\\trace\\nodes.py/Node/info",
        "opto\\trace\\nodes.py/MessageNode"
      ],
      "special_reference_type": [
        false,
        false,
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "repr_function_call",
      "md_content": [
        "**repr_function_call**: The function of repr_function_call is to generate a string representation of a function call based on a MessageNode object.\n\n**parameters**:\n- child: A MessageNode object.\n\n**Code Description**:\nThe `repr_function_call` function takes a `child` parameter, which is an instance of the `MessageNode` class. It generates a string representation of a function call based on the attributes of the `child` object.\n\nThe function first initializes the `function_call` variable with the format \"{child.py_name} = {get_fun_name(child)}(\". This sets the initial part of the function call string, which includes the name of the variable assigned to the function call and the name of the function itself.\n\nNext, the function iterates over the `inputs` attribute of the `child` object, which is a dictionary containing the input nodes of the `MessageNode` object. For each key-value pair in the dictionary, the function appends \"{k}={v.py_name}, \" to the `function_call` string. This adds the input variable names and their corresponding values to the function call string.\n\nAfter the loop, the function removes the trailing \", \" from the `function_call` string and adds a closing parenthesis. This completes the function call string.\n\nFinally, the function returns the `function_call` string.\n\nThe purpose of this function is to provide a convenient way to generate a string representation of a function call based on a `MessageNode` object. The function call string can be used for various purposes, such as logging, debugging, or generating code.\n\nThis function is called by the `node_to_function_feedback` function in the `function_optimizer.py` file of the `optimizers` module. It is used to generate the function call representation of a `MessageNode` object and include it in the `graph` list of the `FunctionFeedback` object.\n\n**Note**:\n- The `repr_function_call` function assumes that the `child` object is an instance of the `MessageNode` class.\n- The function relies on the `py_name` attribute of the input nodes to retrieve their variable names.\n- The function relies on the `get_fun_name` function to retrieve the name of the `child` object.\n\n**Output Example**:\nIf the `child` object has the following attributes:\n- `py_name`: \"result\"\n- `inputs`: {\"x\": <Node object at 0x12345678>, \"y\": <Node object at 0x23456789>}\n\nCalling `repr_function_call(child)` will return the following string:\n\"result = my_function(x=node_x, y=node_y)\""
      ],
      "code_start_line": 23,
      "code_end_line": 28,
      "params": [
        "child"
      ],
      "have_return": true,
      "code_content": "def repr_function_call(child: MessageNode):\n    function_call = f\"{child.py_name} = {get_fun_name(child)}(\"\n    for k, v in child.inputs.items():\n        function_call += f\"{k}={v.py_name}, \"\n    function_call = function_call[:-2] + \")\"\n    return function_call\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/get_fun_name",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\nodes.py/MessageNode/inputs"
      ],
      "special_reference_type": [
        false,
        false,
        true,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "node_to_function_feedback",
      "md_content": [
        "**node_to_function_feedback**: The function of node_to_function_feedback is to convert a TraceGraph object into a FunctionFeedback object. It processes the nodes in the TraceGraph, categorizes them into roots, intermediates, and outputs, and populates the corresponding attributes of the FunctionFeedback object.\n\n**parameters**:\n- node_feedback: A TraceGraph object representing the subgraph of nodes.\n\n**Code Description**:\nThe `node_to_function_feedback` function takes a `node_feedback` parameter, which is an instance of the `TraceGraph` class. It converts the `TraceGraph` object into a `FunctionFeedback` object by processing the nodes in the graph and organizing them into different categories.\n\nThe function first initializes the `depth` variable based on the length of the `graph` attribute of the `node_feedback` object. If the `graph` attribute is empty, the depth is set to 0; otherwise, it is set to the last element's depth in the `graph` attribute.\n\nNext, the function initializes empty lists and dictionaries for `graph`, `others`, `roots`, `output`, and `documentation`. These variables will store the processed data and information.\n\nThe function then creates a `visited` set to keep track of visited nodes. It iterates over the `graph` attribute of the `node_feedback` object, which contains tuples representing the level and node of the graph. For each level and node, it checks if the node is a root node by checking the `is_root` attribute. If it is a root node, it updates the `roots` dictionary with the node's name as the key and its data and constraint as the value.\n\nIf the node is not a root node, it checks if all of its parents have been visited. If they have, it categorizes the node as an intermediate node. It updates the `documentation` dictionary with the node's name as the key and its description as the value. It appends a tuple representing the level and a string representation of the function call to the `graph` list. If the level is equal to the depth, it updates the `output` dictionary with the node's name as the key and its data and constraint as the value. Otherwise, it updates the `others` dictionary with the node's name as the key and its data and constraint as the value.\n\nIf the node is not an intermediate node, it categorizes it as a blanket node and adds it to the `roots` dictionary.\n\nFinally, the function returns a `FunctionFeedback` object with the populated `graph`, `others`, `roots`, `output`, `user_feedback`, and `documentation` attributes.\n\n**Note**:\n- The `node_to_function_feedback` function assumes that the `node_feedback` parameter is a valid instance of the `TraceGraph` class.\n- The function relies on the attributes and methods of the `TraceGraph` class to process the nodes and extract the necessary information.\n- The resulting `FunctionFeedback` object represents the converted feedback from the `TraceGraph` object.\n\n**Output Example**:\nA possible return value of the `node_to_function_feedback` function could be a `FunctionFeedback` object with the following attributes:\n- `graph`: [(0, \"function_call_1\"), (1, \"function_call_2\"), ...]\n- `others`: {\"node_name_1\": (data_1, constraint_1), \"node_name_2\": (data_2, constraint_2), ...}\n- `roots`: {\"root_name_1\": (data_1, constraint_1), \"root_name_2\": (data_2, constraint_2), ...}\n- `output`: {\"output_name_1\": (data_1, constraint_1), \"output_name_2\": (data_2, constraint_2), ...}\n- `user_feedback`: \"User feedback string\"\n- `documentation`: {\"node_name_1\": \"Node description 1\", \"node_name_2\": \"Node description 2\", ...}"
      ],
      "code_start_line": 31,
      "code_end_line": 70,
      "params": [
        "node_feedback"
      ],
      "have_return": true,
      "code_content": "def node_to_function_feedback(node_feedback: TraceGraph):\n    \"\"\"Convert a TraceGraph to a FunctionFeedback. roots, others, outputs are dict of variable name and its data and constraints.\"\"\"\n    depth = 0 if len(node_feedback.graph) == 0 else node_feedback.graph[-1][0]\n    graph = []\n    others = {}\n    roots = {}\n    output = {}\n    documentation = {}\n\n    visited = set()\n    for level, node in node_feedback.graph:\n        # the graph is already sorted\n        visited.add(node)\n\n        if node.is_root:  # Need an or condition here\n            roots.update({node.py_name: (node.data, node._constraint)})\n        else:\n            # Some might be root (i.e. blanket nodes) and some might be intermediate nodes\n            # Blanket nodes belong to roots\n            if all([p in visited for p in node.parents]):\n                # this is an intermediate node\n                assert isinstance(node, MessageNode)\n                documentation.update({get_fun_name(node): node.description})\n                graph.append((level, repr_function_call(node)))\n                if level == depth:\n                    output.update({node.py_name: (node.data, node._constraint)})\n                else:\n                    others.update({node.py_name: (node.data, node._constraint)})\n            else:\n                # this is a blanket node (classified into roots)\n                roots.update({node.py_name: (node.data, node._constraint)})\n\n    return FunctionFeedback(\n        graph=graph,\n        others=others,\n        roots=roots,\n        output=output,\n        user_feedback=node_feedback.user_feedback,\n        documentation=documentation,\n    )\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "tests\\unit_tests\\test_backward.py"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/get_fun_name",
        "opto\\optimizers\\function_optimizer.py/repr_function_call",
        "opto\\optimizers\\function_optimizer.py/FunctionFeedback",
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false,
        false,
        true
      ]
    },
    {
      "type": "ClassDef",
      "name": "FunctionFeedback",
      "md_content": [
        "**FunctionFeedback**: The function of FunctionFeedback is to serve as a feedback container used by the FunctionPropagator.\n\n**attributes**: The attributes of this Class.\n· graph: Each item is a representation of a function call. The items are topologically sorted.\n· documentation: Function name and its documentation string.\n· others: Intermediate variable names and their data.\n· roots: Root variable name and its data.\n· output: Leaf variable name and its data.\n· user_feedback: User feedback at the leaf of the graph.\n\n**Code Description**: The FunctionFeedback class is designed to encapsulate feedback information used by the FunctionPropagator. It organizes and stores various types of data related to function calls and their execution within a graph structure. The attributes of this class are as follows:\n\n- `graph`: This attribute holds a list of tuples, where each tuple represents a function call. The tuples are topologically sorted, ensuring that the order of function calls respects their dependencies.\n- `documentation`: This dictionary maps function names to their corresponding documentation strings, providing a reference for understanding the purpose and behavior of each function.\n- `others`: This dictionary stores intermediate variable names along with their associated data. These variables are neither root nor leaf nodes in the function call graph.\n- `roots`: This dictionary contains root variable names and their data. Root variables are the starting points in the function call graph.\n- `output`: This dictionary holds leaf variable names and their data. Leaf variables are the endpoints in the function call graph.\n- `user_feedback`: This string captures user feedback at the leaf of the graph, providing insights or comments from the user regarding the final output.\n\nThe FunctionFeedback class is utilized by the `node_to_function_feedback` function, which converts a TraceGraph into a FunctionFeedback instance. This conversion involves processing the nodes of the TraceGraph, categorizing them into roots, intermediates (others), and outputs, and then populating the corresponding attributes of the FunctionFeedback instance. The `node_to_function_feedback` function ensures that the graph is correctly sorted and that all relevant data and documentation are accurately captured.\n\n**Note**: Points to note about the use of the code\n- Ensure that the input TraceGraph to the `node_to_function_feedback` function is correctly structured and sorted.\n- The FunctionFeedback class relies on the accurate categorization of nodes into roots, intermediates, and outputs for proper functionality.\n- User feedback should be meaningful and relevant to the final output to provide valuable insights."
      ],
      "code_start_line": 74,
      "code_end_line": 84,
      "params": [],
      "have_return": false,
      "code_content": "class FunctionFeedback:\n    \"\"\"Feedback container used by FunctionPropagator.\"\"\"\n\n    graph: List[\n        Tuple[int, str]\n    ]  # Each item is is a representation of function call. The items are topologically sorted.\n    documentation: Dict[str, str]  # Function name and its documentationstring\n    others: Dict[str, Any]  # Intermediate variable names and their data\n    roots: Dict[str, Any]  # Root variable name and its data\n    output: Dict[str, Any]  # Leaf variable name and its data\n    user_feedback: str  # User feedback at the leaf of the graph\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "ProblemInstance",
      "md_content": [
        "**ProblemInstance**: The function of ProblemInstance is to encapsulate and format the details of a problem instance for optimization tasks.\n\n**attributes**: The attributes of this Class.\n· instruction: A string containing the instructions for the problem.\n· code: A string representing the code to be executed.\n· documentation: A string providing documentation for the code.\n· variables: A string listing the variables involved in the problem.\n· inputs: A string detailing the inputs required for the code.\n· others: A string for any additional information related to the problem.\n· outputs: A string specifying the expected outputs of the code.\n· feedback: A string containing feedback on the problem instance.\n· constraints: A string outlining any constraints on the variables or the problem.\n\n**Code Description**: The ProblemInstance class is designed to encapsulate various components of a problem instance, such as instructions, code, documentation, variables, inputs, outputs, feedback, and constraints. It uses a predefined template to format these components into a structured string representation.\n\nThe class includes a `problem_template` attribute, which is a formatted string template that organizes the problem details into sections. The `__repr__` method is overridden to return a formatted string representation of the problem instance using this template.\n\nThe ProblemInstance class is utilized in the FunctionOptimizer class, specifically in its `__init__` and `probelm_instance` methods. In the `__init__` method, an example problem instance is created using the ProblemInstance class to demonstrate the expected format and structure. The `probelm_instance` method generates a new ProblemInstance based on the provided summary and an optional mask to exclude certain sections.\n\n**Note**: When using the ProblemInstance class, ensure that all attributes are properly populated to generate a meaningful and complete problem instance. The class relies on the provided template to format the output, so any missing or incorrect information may result in an incomplete or inaccurate representation.\n\n**Output Example**: \n```\n#Instruction\nOptimize the function to achieve the desired output.\n\n#Code\ny = add(x=a,y=b)\nz = subtract(x=y, y=c)\n\n#Documentation\nadd: add x and y \nsubtract: subtract y from x\n\n#Variables\n(int) a = 5\n\n#Constraints\na: a > 0\n\n#Inputs\n(int) b = 1\n(int) c = 5\n\n#Others\n(int) y = 6\n\n#Outputs\n(int) z = 1\n\n#Feedback:\nThe result of the code is not as expected. The result should be 10, but the code returns 1\n```"
      ],
      "code_start_line": 88,
      "code_end_line": 141,
      "params": [],
      "have_return": true,
      "code_content": "class ProblemInstance:\n    instruction: str\n    code: str\n    documentation: str\n    variables: str\n    inputs: str\n    others: str\n    outputs: str\n    feedback: str\n    constraints: str\n\n    problem_template = dedent(\n        \"\"\"\n        #Instruction\n        {instruction}\n\n        #Code\n        {code}\n\n        #Documentation\n        {documentation}\n\n        #Variables\n        {variables}\n\n        #Constraints\n        {constraints}\n\n        #Inputs\n        {inputs}\n\n        #Others\n        {others}\n\n        #Outputs\n        {outputs}\n\n        #Feedback:\n        {feedback}\n        \"\"\"\n    )\n\n    def __repr__(self) -> str:\n        return self.problem_template.format(\n            instruction=self.instruction,\n            code=self.code,\n            documentation=self.documentation,\n            variables=self.variables,\n            constraints=self.constraints,\n            inputs=self.inputs,\n            outputs=self.outputs,\n            others=self.others,\n            feedback=self.feedback,\n        )\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/__init__",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/probelm_instance"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__repr__",
      "md_content": [
        "**__repr__**: The function of __repr__ is to provide a formatted string representation of the ProblemInstance object.\n\n**parameters**: The parameters of this function.\n· self: Refers to the instance of the ProblemInstance class.\n\n**Code Description**: The __repr__ function returns a string that represents the ProblemInstance object in a human-readable format. It uses the problem_template attribute of the instance to format the string. The placeholders in the problem_template are filled with the corresponding attributes of the instance, which include:\n- instruction: Instructions related to the problem instance.\n- code: The code associated with the problem instance.\n- documentation: Documentation details of the problem instance.\n- variables: Variables involved in the problem instance.\n- constraints: Constraints applied to the problem instance.\n- inputs: Inputs required for the problem instance.\n- outputs: Outputs expected from the problem instance.\n- others: Any other relevant information about the problem instance.\n- feedback: Feedback related to the problem instance.\n\n**Note**: Ensure that the problem_template attribute is properly defined and contains the necessary placeholders for all the attributes used in the format method. If any attribute is missing or the template is incorrectly formatted, it may result in a runtime error.\n\n**Output Example**: A possible appearance of the code's return value could be:\n```\nProblemInstance(\n    instruction='Optimize the function',\n    code='def optimize(): pass',\n    documentation='This function optimizes the given parameters.',\n    variables={'x': 10, 'y': 20},\n    constraints='x + y <= 30',\n    inputs=['x', 'y'],\n    outputs=['result'],\n    others='Additional information',\n    feedback='No issues found'\n)\n```"
      ],
      "code_start_line": 130,
      "code_end_line": 141,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __repr__(self) -> str:\n        return self.problem_template.format(\n            instruction=self.instruction,\n            code=self.code,\n            documentation=self.documentation,\n            variables=self.variables,\n            constraints=self.constraints,\n            inputs=self.inputs,\n            outputs=self.outputs,\n            others=self.others,\n            feedback=self.feedback,\n        )\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "FunctionOptimizer",
      "md_content": [
        "**FunctionOptimizer**: The function of FunctionOptimizer is to serve as a base class for optimizers, responsible for updating parameters based on feedback.\n\n**attributes**:\n- parameters: A list of ParameterNode objects that the optimizer will manage and update.\n\n**Code Description**:\nThe FunctionOptimizer class is a subclass of the Optimizer class and provides a base implementation for optimizing functions. It extends the Optimizer class and overrides some of its methods to customize the optimization process.\n\nThe `__init__` method initializes the FunctionOptimizer object by calling the superclass's `__init__` method and passing the parameters list. It also sets the `representation_prompt` attribute, which is a generic representation prompt explaining how to read and understand the problem.\n\nThe `default_objective` attribute defines the default objective of the optimizer, which is to change the values of the variables in the `#Variables` section to improve the output according to the feedback.\n\nThe `output_format_prompt` attribute defines the output format of the optimizer's response. It specifies that the output should be in JSON format and provides a template for the structure of the response.\n\nThe `example_problem_template` attribute defines a template for an example problem instance and response. It includes placeholders for the problem instance and the response, which can be filled in with actual values.\n\nThe `user_prompt_template` attribute defines a template for the user prompt. It includes placeholders for the problem instance and the instruction, which can be filled in with actual values.\n\nThe `example_prompt` attribute is currently empty and marked as a TODO. It is intended to provide feasible but not optimal solutions for the current problem instance as a hint to help users understand the problem better.\n\nThe `final_prompt` attribute defines a template for the final prompt, which prompts the user to provide their response.\n\nThe `__init__` method also initializes other attributes such as `propagator`, `llm`, `ignore_extraction_error`, `include_example`, `max_tokens`, and `log` with default values or values passed as arguments.\n\nThe `default_propagator` method returns the default Propagator object of the optimizer. This method is implemented in the Optimizer class and must be overridden by subclasses.\n\nThe `summarize` method aggregates the feedback from all the parameters and constructs the summary object. It then classifies the root nodes into variables and others.\n\nThe `repr_node_value` method takes a dictionary of node values and returns a string representation of the values.\n\nThe `repr_node_constraint` method takes a dictionary of node constraints and returns a string representation of the constraints.\n\nThe `probelm_instance` method constructs a ProblemInstance object based on the summary and a mask. The mask is used to exclude certain sections from the problem instance.\n\nThe `construct_prompt` method constructs the system and user prompts based on the summary and a mask. The system prompt includes the representation prompt and the output format prompt. The user prompt includes the problem instance and the final prompt.\n\nThe `_step` method is an abstract method that must be implemented by subclasses. It is responsible for proposing new parameter values based on feedback and returning the update dictionary.\n\nThe `construct_update_dict` method converts the suggestion in text format into the right data type and constructs an update dictionary.\n\nThe `extract_llm_suggestion` method extracts the suggestion from the response received from the LLM (Language Model).\n\nThe `call_llm` method calls the LLM with a prompt and returns the response.\n\n**Note**:\n- The FunctionOptimizer class is designed to be subclassed and extended to create specific optimizers for different types of problems.\n- Subclasses of FunctionOptimizer must implement the `_step` and `default_propagator` methods.\n- The FunctionOptimizer class provides a consistent interface and behavior for managing and updating parameters based on feedback.\n- The class uses the LLM to generate suggestions for updating the parameters.\n- The class includes methods for constructing prompts, extracting suggestions, and calling the LLM.\n\n**Output Example**:\n{\n    \"reasoning\": \"In this case, the desired response would be to change the value of input a to 14, as that would make the code return 10.\",\n    \"answer\": {},\n    \"suggestion\": {\n        \"a\": 10\n    }\n}"
      ],
      "code_start_line": 144,
      "code_end_line": 453,
      "params": [],
      "have_return": true,
      "code_content": "class FunctionOptimizer(Optimizer):\n    # This is generic representation prompt, which just explains how to read the problem.\n    representation_prompt = dedent(\n        \"\"\"\n        You're tasked to solve a coding/algorithm problem. You will see the instruction, the code, the documentation of each function used in the code, and the feedback about the execution result.\n\n        Specifically, a problem will be composed of the following parts:\n        - #Instruction: the instruction which describes the things you need to do or the question you should answer.\n        - #Code: the code defined in the problem.\n        - #Documentation: the documentation of each function used in #Code. The explanation might be incomplete and just contain high-level description. You can use the values in #Others to help infer how those functions work.\n        - #Variables: the input variables that you can change.\n        - #Constraints: the constraints or descriptions of the variables in #Variables.\n        - #Inputs: the values of other inputs to the code, which are not changeable.\n        - #Others: the intermediate values created through the code execution.\n        - #Outputs: the result of the code output.\n        - #Feedback: the feedback about the code's execution result.\n\n        In #Variables, #Inputs, #Outputs, and #Others, the format is:\n\n        <data_type> <variable_name> = <value>\n\n        If <type> is (code), it means <value> is the source code of a python code, which may include docstring and definitions.\n        \"\"\"\n    )\n\n    # Optimization\n    default_objective = \"You need to change the <value> of the variables in #Variables to improve the output in accordance to #Feedback.\"\n\n    output_format_prompt = dedent(\n        \"\"\"\n        Output_format: Your output should be in the following json format, satisfying the json syntax:\n\n        {{\n        \"reasoning\": <Your reasoning>,\n        \"answer\": <Your answer>,\n        \"suggestion\": {{\n            <variable_1>: <suggested_value_1>,\n            <variable_2>: <suggested_value_2>,\n        }}\n        }}\n\n        You should write down your thought process in \"reasoning\". If #Instruction asks for an answer, write it down in \"answer\". If you need to suggest a change in the values of #Variables, write down the suggested values in \"suggestion\". Remember you can change only the values in #Variables, not others. When <type> of a variable is (code), you should write the new definition in the format of python code without syntax errors, and you should not change the function name or the function signature.\n\n        If no changes or answer are needed, just output TERMINATE.\n        \"\"\"\n    )\n\n    example_problem_template = dedent(\n        \"\"\"\n        Here is an example of problem instance and response:\n\n        ================================\n        {example_problem}\n        ================================\n\n        Your response:\n        {example_response}\n        \"\"\"\n    )\n\n    user_prompt_template = dedent(\n        \"\"\"\n        Now you see problem instance:\n\n        ================================\n        {problem_instance}\n        ================================\n\n        \"\"\"\n    )\n\n    # TODO\n    example_prompt = dedent(\n        \"\"\"\n\n        Here are some feasible but not optimal solutions for the current problem instance. Consider this as a hint to help you understand the problem better.\n\n        ================================\n\n        {examples}\n\n        ================================\n        \"\"\"\n    )\n\n    final_prompt = dedent(\n        \"\"\"\n        Your response:\n        \"\"\"\n    )\n\n    def __init__(\n        self,\n        parameters: List[ParameterNode],\n        config_list: List = None,\n        *args,\n        propagator: Propagator = None,\n        objective: Union[None, str] = None,\n        ignore_extraction_error: bool = True,  # ignore the type conversion error when extracting updated values from LLM's suggestion\n        include_example=False,  # TODO # include example problem and response in the prompt\n        max_tokens=4096,\n        log=True,\n        **kwargs,\n    ):\n        super().__init__(parameters, *args, propagator=propagator, **kwargs)\n        self.ignore_extraction_error = ignore_extraction_error\n        if config_list is None:\n            config_list = autogen.config_list_from_json(\"OAI_CONFIG_LIST\")\n        self.llm = autogen.OpenAIWrapper(config_list=config_list)\n        self.objective = objective or self.default_objective\n        self.example_problem = ProblemInstance.problem_template.format(\n            instruction=self.default_objective,\n            code=\"y = add(x=a,y=b)\\nz = subtract(x=y, y=c)\",\n            documentation=\"add: add x and y \\nsubtract: subtract y from x\",\n            variables=\"(int) a = 5\",\n            constraints=\"a: a > 0\",\n            outputs=\"(int) z = 1\",\n            others=\"(int) y = 6\",\n            inputs=\"(int) b = 1\\n(int) c = 5\",\n            feedback=\"The result of the code is not as expected. The result should be 10, but the code returns 1\",\n            stepsize=1,\n        )\n        self.example_response = dedent(\n            \"\"\"\n            {\"reasoning\": 'In this case, the desired response would be to change the value of input a to 14, as that would make the code return 10.',\n             \"answer\", {},\n             \"suggestion\": {\"a\": 10}\n            }\n            \"\"\"\n        )\n\n        self.include_example = include_example\n        self.max_tokens = max_tokens\n        self.log = [] if log else None\n\n    def default_propagator(self):\n        \"\"\"Return the default Propagator object of the optimizer.\"\"\"\n        return GraphPropagator()\n\n    def summarize(self):\n        # Aggregate feedback from all the parameters\n        feedbacks = [self.propagator.aggregate(node.feedback) for node in self.parameters if node.trainable]\n        summary = sum(feedbacks)  # TraceGraph\n        # Construct variables and update others\n        # Some trainable nodes might not receive feedback, because they might not be connected to the output\n        summary = node_to_function_feedback(summary)\n        # Classify the root nodes into variables and others\n        # summary.variables = {p.py_name: p.data for p in self.parameters if p.trainable and p.py_name in summary.roots}\n\n        trainable_param_dict = {p.py_name: p for p in self.parameters if p.trainable}\n        summary.variables = {\n            py_name: data for py_name, data in summary.roots.items() if py_name in trainable_param_dict\n        }\n        summary.inputs = {\n            py_name: data for py_name, data in summary.roots.items() if py_name not in trainable_param_dict\n        }  # non-variable roots\n\n        return summary\n\n    @staticmethod\n    def repr_node_value(node_dict):\n        temp_list = []\n        for k, v in node_dict.items():\n            if \"__code\" not in k:\n                temp_list.append(f\"({type(v[0]).__name__}) {k}={v[0]}\")\n            else:\n                temp_list.append(f\"(code) {k}:{v[0]}\")\n        return \"\\n\".join(temp_list)\n\n    @staticmethod\n    def repr_node_constraint(node_dict):\n        temp_list = []\n        for k, v in node_dict.items():\n            if \"__code\" not in k:\n                if v[1] is not None:\n                    temp_list.append(f\"({type(v[0]).__name__}) {k}: {v[1]}\")\n            else:\n                if v[1] is not None:\n                    temp_list.append(f\"(code) {k}: {v[1]}\")\n        return \"\\n\".join(temp_list)\n\n    def probelm_instance(self, summary, mask=None):\n        mask = mask or []\n        return ProblemInstance(\n            instruction=self.objective,\n            code=\"\\n\".join([v for k, v in sorted(summary.graph)]) if \"#Code\" not in mask else \"\",\n            documentation=\"\\n\".join([v for v in summary.documentation.values()])\n            if \"#Documentation\" not in mask\n            else \"\",\n            variables=self.repr_node_value(summary.variables) if \"#Variables\" not in mask else \"\",\n            constraints=self.repr_node_constraint(summary.variables) if \"#Constraints\" not in mask else \"\",\n            inputs=self.repr_node_value(summary.inputs) if \"#Inputs\" not in mask else \"\",\n            outputs=self.repr_node_value(summary.output) if \"#Outputs\" not in mask else \"\",\n            others=self.repr_node_value(summary.others) if \"#Others\" not in mask else \"\",\n            feedback=summary.user_feedback if \"#Feedback\" not in mask else \"\",\n        )\n\n    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        system_prompt = self.representation_prompt + self.output_format_prompt  # generic representation + output rule\n        user_prompt = self.user_prompt_template.format(\n            problem_instance=str(self.probelm_instance(summary, mask=mask))\n        )  # problem instance\n        if self.include_example:\n            user_prompt = (\n                self.example_problem_template.format(\n                    example_problem=self.example_problem, example_response=self.example_response\n                )\n                + user_prompt\n            )\n        user_prompt += self.final_prompt\n        return system_prompt, user_prompt\n\n    def _step(self, verbose=False, mask=None, *args, **kwargs) -> Dict[ParameterNode, Any]:\n        assert isinstance(self.propagator, GraphPropagator)\n        summary = self.summarize()\n        system_prompt, user_prompt = self.construct_prompt(summary, mask=mask)\n        response = self.call_llm(\n            system_prompt=system_prompt, user_prompt=user_prompt, verbose=verbose, max_tokens=self.max_tokens\n        )\n\n        if \"TERMINATE\" in response:\n            return {}\n\n        suggestion = self.extract_llm_suggestion(response)\n        update_dict = self.construct_update_dict(suggestion)\n\n        if self.log is not None:\n            self.log.append({\"system_prompt\": system_prompt, \"user_prompt\": user_prompt, \"response\": response})\n\n        return update_dict\n\n    def construct_update_dict(self, suggestion: Dict[str, Any]) -> Dict[ParameterNode, Any]:\n        \"\"\"Convert the suggestion in text into the right data type.\"\"\"\n        # TODO: might need some automatic type conversion\n        update_dict = {}\n        for node in self.parameters:\n            if node.trainable and node.py_name in suggestion:\n                try:\n                    update_dict[node] = type(node.data)(suggestion[node.py_name])\n                except (ValueError, KeyError) as e:\n                    # catch error due to suggestion missing the key or wrong data type\n                    if self.ignore_extraction_error:\n                        warnings.warn(\n                            f\"Cannot convert the suggestion '{suggestion[node.py_name]}' for {node.py_name} to the right data type\"\n                        )\n                    else:\n                        raise e\n        return update_dict\n\n    def extract_llm_suggestion(self, response: str):\n        \"\"\"Extract the suggestion from the response.\"\"\"\n        suggestion = {}\n        attempt_n = 0\n        while attempt_n < 2:\n            try:\n                suggestion = json.loads(response)[\"suggestion\"]\n                break\n            except json.JSONDecodeError:  # TODO try to fix it\n                # Remove things outside the brackets\n                response = re.findall(r\"{.*}\", response, re.DOTALL)\n                if len(response) > 0:\n                    response = response[0]\n                attempt_n += 1\n            except Exception:\n                attempt_n += 1\n\n        if len(suggestion) == 0:\n            # we try to extract key/value separately and return it as a dictionary\n            pattern = r'\"suggestion\"\\s*:\\s*\\{(.*?)\\}'\n            suggestion_match = re.search(pattern, str(response), re.DOTALL)\n            if suggestion_match:\n                suggestion = {}\n                # Extract the entire content of the suggestion dictionary\n                suggestion_content = suggestion_match.group(1)\n                # Regex to extract each key-value pair;\n                # This scheme assumes double quotes but is robust to missing cammas at the end of the line\n                pair_pattern = r'\"([a-zA-Z0-9_]+)\"\\s*:\\s*\"(.*)\"'\n                # Find all matches of key-value pairs\n                pairs = re.findall(pair_pattern, suggestion_content, re.DOTALL)\n                for key, value in pairs:\n                    suggestion[key] = value\n\n        if len(suggestion) == 0:\n            print(\"Cannot extract suggestion from LLM's response:\")\n            print(response)\n\n        return suggestion\n\n    def call_llm(\n        self, system_prompt: str, user_prompt: str, verbose: Union[bool, str] = False, max_tokens: int = 4096\n    ):  # TODO Get this from utils?\n        \"\"\"Call the LLM with a prompt and return the response.\"\"\"\n        if verbose not in (False, \"output\"):\n            print(\"Prompt\\n\", system_prompt + user_prompt)\n\n        messages = [{\"role\": \"system\", \"content\": system_prompt}, {\"role\": \"user\", \"content\": user_prompt}]\n\n        try:  # Try tp force it to be a json object\n            response = self.llm.create(\n                messages=messages,\n                response_format={\"type\": \"json_object\"},\n            )\n        except Exception:\n            response = self.llm.create(messages=messages, max_tokens=max_tokens)\n        response = response.choices[0].message.content\n\n        if verbose:\n            print(\"LLM response:\\n\", response)\n        return response\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\__init__.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizerV2",
        "opto\\optimizers\\opro.py",
        "opto\\optimizers\\opro.py/OPRO",
        "tests\\unit_tests\\test_optimizer.py"
      ],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/Optimizer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the FunctionOptimizer class.\n\n**parameters**:\n- parameters: A list of ParameterNode objects representing the trainable nodes in the computational graph.\n- config_list: A list of configurations for the OpenAIWrapper. Default is None.\n- *args: Additional positional arguments.\n- propagator: An instance of the Propagator class. Default is None.\n- objective: A string representing the objective of the optimization task. Default is None.\n- ignore_extraction_error: A boolean indicating whether to ignore type conversion errors when extracting updated values from LLM's suggestion. Default is True.\n- include_example: A boolean indicating whether to include an example problem and response in the prompt. Default is False.\n- max_tokens: An integer representing the maximum number of tokens allowed in the prompt. Default is 4096.\n- log: A boolean indicating whether to log the optimization process. Default is True.\n- **kwargs: Additional keyword arguments.\n\n**Code Description**: The __init__ method of the FunctionOptimizer class initializes an instance of the class. It takes in various parameters such as parameters, config_list, *args, propagator, objective, ignore_extraction_error, include_example, max_tokens, log, and **kwargs.\n\nThe method first calls the __init__ method of the superclass (Optimizer) to initialize the parameters and propagator attributes. It then sets the ignore_extraction_error attribute based on the provided ignore_extraction_error parameter.\n\nIf the config_list parameter is None, it uses the autogen.config_list_from_json function to retrieve the configuration list from the \"OAI_CONFIG_LIST\" JSON file. It then initializes the llm attribute with an instance of the autogen.OpenAIWrapper class, passing the config_list as a parameter.\n\nThe objective attribute is set to the provided objective parameter if it is not None, otherwise it is set to the default_objective attribute of the class.\n\nThe example_problem attribute is initialized with a formatted string template that represents an example problem instance. It includes placeholders for the instruction, code, documentation, variables, constraints, inputs, others, outputs, and feedback sections.\n\nThe example_response attribute is initialized with a formatted string that represents an example response to the problem instance. It includes placeholders for the reasoning, answer, and suggestion sections.\n\nThe include_example, max_tokens, and log attributes are set based on the provided parameters.\n\n**Note**: \n- The FunctionOptimizer class is a subclass of the Optimizer class.\n- The parameters attribute represents the trainable nodes in the computational graph.\n- The config_list attribute represents the configuration list for the OpenAIWrapper.\n- The propagator attribute represents the propagator for the optimization process.\n- The objective attribute represents the objective of the optimization task.\n- The ignore_extraction_error attribute indicates whether to ignore type conversion errors when extracting updated values from LLM's suggestion.\n- The include_example attribute indicates whether to include an example problem and response in the prompt.\n- The max_tokens attribute represents the maximum number of tokens allowed in the prompt.\n- The log attribute indicates whether to log the optimization process.\n\n**Output Example**: \n```\nFunctionOptimizer(\n    parameters=[ParameterNode: (name, dtype=<class 'type'>, data=value)],\n    config_list=[...],\n    propagator=Propagator(),\n    objective=\"...\",\n    ignore_extraction_error=True,\n    include_example=False,\n    max_tokens=4096,\n    log=True,\n    ...\n)\n```"
      ],
      "code_start_line": 235,
      "code_end_line": 277,
      "params": [
        "self",
        "parameters",
        "config_list"
      ],
      "have_return": true,
      "code_content": "    def __init__(\n        self,\n        parameters: List[ParameterNode],\n        config_list: List = None,\n        *args,\n        propagator: Propagator = None,\n        objective: Union[None, str] = None,\n        ignore_extraction_error: bool = True,  # ignore the type conversion error when extracting updated values from LLM's suggestion\n        include_example=False,  # TODO # include example problem and response in the prompt\n        max_tokens=4096,\n        log=True,\n        **kwargs,\n    ):\n        super().__init__(parameters, *args, propagator=propagator, **kwargs)\n        self.ignore_extraction_error = ignore_extraction_error\n        if config_list is None:\n            config_list = autogen.config_list_from_json(\"OAI_CONFIG_LIST\")\n        self.llm = autogen.OpenAIWrapper(config_list=config_list)\n        self.objective = objective or self.default_objective\n        self.example_problem = ProblemInstance.problem_template.format(\n            instruction=self.default_objective,\n            code=\"y = add(x=a,y=b)\\nz = subtract(x=y, y=c)\",\n            documentation=\"add: add x and y \\nsubtract: subtract y from x\",\n            variables=\"(int) a = 5\",\n            constraints=\"a: a > 0\",\n            outputs=\"(int) z = 1\",\n            others=\"(int) y = 6\",\n            inputs=\"(int) b = 1\\n(int) c = 5\",\n            feedback=\"The result of the code is not as expected. The result should be 10, but the code returns 1\",\n            stepsize=1,\n        )\n        self.example_response = dedent(\n            \"\"\"\n            {\"reasoning\": 'In this case, the desired response would be to change the value of input a to 14, as that would make the code return 10.',\n             \"answer\", {},\n             \"suggestion\": {\"a\": 10}\n            }\n            \"\"\"\n        )\n\n        self.include_example = include_example\n        self.max_tokens = max_tokens\n        self.log = [] if log else None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/ProblemInstance",
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\propagators\\propagators.py/Propagator"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "default_propagator",
      "md_content": [
        "**default_propagator**: The function of default_propagator is to return the default Propagator object of the optimizer.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The default_propagator function is a method within the FunctionOptimizer class. Its primary purpose is to return an instance of the GraphPropagator class. When this method is called, it creates and returns a new GraphPropagator object. The GraphPropagator class, which is a subclass of the Propagator class, is designed to collect all the nodes seen in a path and compute the propagated feedback to the parent nodes based on the child node's description, data, and feedback. This method does not take any parameters and simply returns a new GraphPropagator instance, which can then be used by the optimizer for its propagation tasks.\n\n**Note**: This method is straightforward and does not require any parameters. It is designed to provide a default propagator for the optimizer, ensuring that the optimizer has a predefined mechanism for handling propagation tasks.\n\n**Output Example**: \n```python\nGraphPropagator()\n```"
      ],
      "code_start_line": 279,
      "code_end_line": 281,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def default_propagator(self):\n        \"\"\"Return the default Propagator object of the optimizer.\"\"\"\n        return GraphPropagator()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "summarize",
      "md_content": [
        "**summarize**: The function of summarize is to aggregate feedback from all the parameters, construct variables and update others, and classify the root nodes into variables and others.\n\n**parameters**:\n- self: The instance of the class.\n\n**Code Description**:\nThe `summarize` function is a method of the `FunctionOptimizer` class. It aggregates feedback from all the parameters by calling the `aggregate` method of the `propagator` object. The feedbacks are obtained from the trainable parameters by iterating over the `parameters` attribute of the class instance and filtering out the non-trainable nodes. The feedbacks are then summed up using the `sum` function.\n\nAfter aggregating the feedback, the function converts the resulting `TraceGraph` object into a `FunctionFeedback` object by calling the `node_to_function_feedback` function. This function processes the nodes in the `TraceGraph` object, categorizes them into roots, intermediates, and outputs, and populates the corresponding attributes of the `FunctionFeedback` object.\n\nNext, the function constructs variables and updates others based on the trainable nodes. It creates a dictionary called `trainable_param_dict` that maps the parameter names to their corresponding parameter objects. It then updates the `variables` attribute of the `summary` object by filtering the `roots` dictionary based on the keys present in the `trainable_param_dict`. Similarly, it updates the `inputs` attribute of the `summary` object by filtering the `roots` dictionary based on the keys not present in the `trainable_param_dict`.\n\nFinally, the function returns the `summary` object, which represents the aggregated feedback, variables, and inputs.\n\nThe `summarize` function is called in the `_step` method of the `FunctionOptimizer` class. It is used to summarize the feedback from the trainable parameters and construct prompts for further processing. The `summarize` function relies on the `propagator` object and the `node_to_function_feedback` function to perform its tasks.\n\n**Note**:\n- The `summarize` function assumes that the `propagator` object is correctly initialized and contains the necessary methods and attributes.\n- The function assumes that the `parameters` attribute of the class instance contains the necessary trainable nodes.\n- The `node_to_function_feedback` function should be defined and accessible within the project for the `summarize` function to work correctly.\n- The resulting `summary` object represents the aggregated feedback, variables, and inputs from the trainable parameters.\n\n**Output Example**:\nA possible return value of the `summarize` function could be a `FunctionFeedback` object with the following attributes:\n- `graph`: [(0, \"function_call_1\"), (1, \"function_call_2\"), ...]\n- `others`: {\"node_name_1\": (data_1, constraint_1), \"node_name_2\": (data_2, constraint_2), ...}\n- `roots`: {\"root_name_1\": (data_1, constraint_1), \"root_name_2\": (data_2, constraint_2), ...}\n- `output`: {\"output_name_1\": (data_1, constraint_1), \"output_name_2\": (data_2, constraint_2), ...}\n- `user_feedback`: \"User feedback string\"\n- `documentation`: {\"node_name_1\": \"Node description 1\", \"node_name_2\": \"Node description 2\", ...}"
      ],
      "code_start_line": 283,
      "code_end_line": 301,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def summarize(self):\n        # Aggregate feedback from all the parameters\n        feedbacks = [self.propagator.aggregate(node.feedback) for node in self.parameters if node.trainable]\n        summary = sum(feedbacks)  # TraceGraph\n        # Construct variables and update others\n        # Some trainable nodes might not receive feedback, because they might not be connected to the output\n        summary = node_to_function_feedback(summary)\n        # Classify the root nodes into variables and others\n        # summary.variables = {p.py_name: p.data for p in self.parameters if p.trainable and p.py_name in summary.roots}\n\n        trainable_param_dict = {p.py_name: p for p in self.parameters if p.trainable}\n        summary.variables = {\n            py_name: data for py_name, data in summary.roots.items() if py_name in trainable_param_dict\n        }\n        summary.inputs = {\n            py_name: data for py_name, data in summary.roots.items() if py_name not in trainable_param_dict\n        }  # non-variable roots\n\n        return summary\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback",
        "opto\\optimizers\\optimizers.py/Optimizer/propagator",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/Node/feedback",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/aggregate"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "repr_node_value",
      "md_content": [
        "**repr_node_value**: The function of repr_node_value is to generate a formatted string representation of the values in a given dictionary, excluding keys that contain the substring \"__code\".\n\n**parameters**: The parameters of this Function.\n· node_dict: A dictionary where each key is a string and each value is a list, with the first element of the list being the value to be represented.\n\n**Code Description**: The repr_node_value function processes a dictionary (node_dict) and creates a list of formatted strings based on the dictionary's contents. It iterates over each key-value pair in the dictionary. For each pair, if the key does not contain the substring \"__code\", it appends a string to the list in the format \"(type) key=value\", where \"type\" is the type of the first element in the value list, and \"key\" and \"value\" are the key and the first element of the value list, respectively. If the key contains the substring \"__code\", it appends a string in the format \"(code) key:value\". Finally, the function joins all the strings in the list with newline characters and returns the resulting string.\n\nThis function is utilized in the probelm_instance method of the FunctionOptimizer class. In this context, repr_node_value is called to generate string representations of various components of a summary object, such as variables, inputs, outputs, and others. These string representations are then used to construct a ProblemInstance object, which encapsulates the details of a problem instance in a structured format.\n\n**Note**: \n- Ensure that the input dictionary (node_dict) has lists as values, with the first element of each list being the value to be represented.\n- Keys containing the substring \"__code\" will be treated differently and formatted as \"(code) key:value\".\n\n**Output Example**: \nGiven the input dictionary:\n{\n    \"var1\": [10],\n    \"var2\": [\"example\"],\n    \"func__code\": [\"def func(): pass\"]\n}\nThe function would return:\n```\n(int) var1=10\n(str) var2=example\n(code) func__code:def func(): pass\n```"
      ],
      "code_start_line": 304,
      "code_end_line": 311,
      "params": [
        "node_dict"
      ],
      "have_return": true,
      "code_content": "    def repr_node_value(node_dict):\n        temp_list = []\n        for k, v in node_dict.items():\n            if \"__code\" not in k:\n                temp_list.append(f\"({type(v[0]).__name__}) {k}={v[0]}\")\n            else:\n                temp_list.append(f\"(code) {k}:{v[0]}\")\n        return \"\\n\".join(temp_list)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/probelm_instance"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "repr_node_constraint",
      "md_content": [
        "**repr_node_constraint**: The function of repr_node_constraint is to generate a formatted string representation of the constraints in a given node dictionary.\n\n**parameters**: The parameters of this Function.\n· node_dict: A dictionary where keys are node identifiers and values are tuples containing node attributes.\n\n**Code Description**: The repr_node_constraint function processes a dictionary of nodes, where each key-value pair represents a node and its attributes. The function iterates through each item in the dictionary. For each key-value pair, it checks if the key does not contain the substring \"__code\". If this condition is met and the second element of the value tuple (v[1]) is not None, it appends a formatted string to a temporary list (temp_list). The formatted string includes the type of the first element of the value tuple (v[0]), the key, and the second element of the value tuple (v[1]). If the key contains the substring \"__code\" and the second element of the value tuple (v[1]) is not None, it appends a different formatted string to the temporary list, indicating that the key is related to code. Finally, the function joins all the strings in the temporary list with newline characters and returns the resulting string.\n\nThis function is called by the probelm_instance method of the FunctionOptimizer class. In this context, repr_node_constraint is used to generate a string representation of the constraints in the summary.variables dictionary, which is then included in the ProblemInstance object. This ensures that the constraints are properly formatted and included in the problem instance's representation.\n\n**Note**: Ensure that the node_dict parameter is correctly structured, with each value being a tuple where the second element can be None or a meaningful value to be included in the output.\n\n**Output Example**: \n```\n(int) node1: 10\n(str) node2: constraint_value\n(code) node3__code: some_code\n```"
      ],
      "code_start_line": 314,
      "code_end_line": 323,
      "params": [
        "node_dict"
      ],
      "have_return": true,
      "code_content": "    def repr_node_constraint(node_dict):\n        temp_list = []\n        for k, v in node_dict.items():\n            if \"__code\" not in k:\n                if v[1] is not None:\n                    temp_list.append(f\"({type(v[0]).__name__}) {k}: {v[1]}\")\n            else:\n                if v[1] is not None:\n                    temp_list.append(f\"(code) {k}: {v[1]}\")\n        return \"\\n\".join(temp_list)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/probelm_instance"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "probelm_instance",
      "md_content": [
        "**probelm_instance**: The function of probelm_instance is to generate a ProblemInstance object based on the provided summary and an optional mask. It encapsulates and formats the details of a problem instance for optimization tasks.\n\n**parameters**:\n- summary: A summary object containing the necessary information for the problem instance.\n- mask (optional): A list of strings specifying the sections to exclude from the ProblemInstance object.\n\n**Code Description**: The probelm_instance function takes a summary object and an optional mask as input. It first checks if a mask is provided, and if not, initializes it as an empty list. \n\nThe function then creates a ProblemInstance object by passing the following parameters:\n- instruction: The instruction for the problem instance, obtained from the summary object.\n- code: A string representing the code to be executed. It is obtained by joining the values of the sorted summary.graph dictionary, excluding the sections specified in the mask.\n- documentation: A string providing documentation for the code. It is obtained by joining the values of the summary.documentation dictionary, excluding the sections specified in the mask.\n- variables: A string listing the variables involved in the problem. It is obtained by calling the repr_node_value function on the summary.variables dictionary, excluding the sections specified in the mask.\n- constraints: A string outlining any constraints on the variables or the problem. It is obtained by calling the repr_node_constraint function on the summary.variables dictionary, excluding the sections specified in the mask.\n- inputs: A string detailing the inputs required for the code. It is obtained by calling the repr_node_value function on the summary.inputs dictionary, excluding the sections specified in the mask.\n- outputs: A string specifying the expected outputs of the code. It is obtained by calling the repr_node_value function on the summary.output dictionary, excluding the sections specified in the mask.\n- others: A string for any additional information related to the problem. It is obtained by calling the repr_node_value function on the summary.others dictionary, excluding the sections specified in the mask.\n- feedback: A string containing feedback on the problem instance. It is obtained from the summary.user_feedback attribute, excluding the sections specified in the mask.\n\nThe ProblemInstance object is then returned.\n\nThe probelm_instance function is utilized in the FunctionOptimizer class, specifically in its __init__ method and construct_prompt method. In the __init__ method, it is used to create an example problem instance using the ProblemInstance class. In the construct_prompt method, it is called to generate the problem instance string representation, which is included in the user prompt.\n\n**Note**: When using the probelm_instance function, ensure that the summary object is properly populated with the required information. The mask parameter can be used to exclude specific sections from the generated ProblemInstance object.\n\n**Output Example**:\n```\n#Instruction\nOptimize the function to achieve the desired output.\n\n#Code\ny = add(x=a,y=b)\nz = subtract(x=y, y=c)\n\n#Documentation\nadd: add x and y \nsubtract: subtract y from x\n\n#Variables\n(int) a = 5\n\n#Constraints\na: a > 0\n\n#Inputs\n(int) b = 1\n(int) c = 5\n\n#Others\n(int) y = 6\n\n#Outputs\n(int) z = 1\n\n#Feedback:\nThe result of the code is not as expected. The result should be 10, but the code returns 1\n```"
      ],
      "code_start_line": 325,
      "code_end_line": 339,
      "params": [
        "self",
        "summary",
        "mask"
      ],
      "have_return": true,
      "code_content": "    def probelm_instance(self, summary, mask=None):\n        mask = mask or []\n        return ProblemInstance(\n            instruction=self.objective,\n            code=\"\\n\".join([v for k, v in sorted(summary.graph)]) if \"#Code\" not in mask else \"\",\n            documentation=\"\\n\".join([v for v in summary.documentation.values()])\n            if \"#Documentation\" not in mask\n            else \"\",\n            variables=self.repr_node_value(summary.variables) if \"#Variables\" not in mask else \"\",\n            constraints=self.repr_node_constraint(summary.variables) if \"#Constraints\" not in mask else \"\",\n            inputs=self.repr_node_value(summary.inputs) if \"#Inputs\" not in mask else \"\",\n            outputs=self.repr_node_value(summary.output) if \"#Outputs\" not in mask else \"\",\n            others=self.repr_node_value(summary.others) if \"#Others\" not in mask else \"\",\n            feedback=summary.user_feedback if \"#Feedback\" not in mask else \"\",\n        )\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_prompt"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/ProblemInstance",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/repr_node_value",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/repr_node_constraint"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "construct_prompt",
      "md_content": [
        "**construct_prompt**: The function of construct_prompt is to construct the system and user prompts based on the provided summary and optional mask.\n\n**parameters**:\n- summary: A summary object containing the necessary information for the problem instance.\n- mask (optional): A list of strings specifying the sections to exclude from the ProblemInstance object.\n- *args: Additional positional arguments.\n- **kwargs: Additional keyword arguments.\n\n**Code Description**: The construct_prompt function is designed to generate system and user prompts for optimization tasks. It begins by creating a system prompt by concatenating the representation_prompt and output_format_prompt attributes, which provide a generic representation and output rules.\n\nNext, the function constructs a user prompt using the user_prompt_template attribute. It formats this template with a string representation of a problem instance, generated by calling the probelm_instance method with the provided summary and mask. This problem instance encapsulates and formats the details of the problem for the user prompt.\n\nIf the include_example attribute is set to True, the function prepends an example problem and response to the user prompt. This is done by formatting the example_problem_template attribute with the example_problem and example_response attributes.\n\nFinally, the function appends the final_prompt attribute to the user prompt and returns both the system prompt and the user prompt.\n\nThe construct_prompt function is called within the _step method of the FunctionOptimizer class. In this context, it is used to generate the necessary prompts for interacting with a language model, which then provides suggestions for optimizing the function.\n\n**Note**: Ensure that the summary object is properly populated with the required information before calling construct_prompt. The mask parameter can be used to exclude specific sections from the generated ProblemInstance object.\n\n**Output Example**:\n```\nsystem_prompt: \"Generic representation and output rules\"\nuser_prompt: \"Example problem and response (if include_example is True) + Problem instance details + Final prompt\"\n```"
      ],
      "code_start_line": 341,
      "code_end_line": 355,
      "params": [
        "self",
        "summary",
        "mask"
      ],
      "have_return": true,
      "code_content": "    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        system_prompt = self.representation_prompt + self.output_format_prompt  # generic representation + output rule\n        user_prompt = self.user_prompt_template.format(\n            problem_instance=str(self.probelm_instance(summary, mask=mask))\n        )  # problem instance\n        if self.include_example:\n            user_prompt = (\n                self.example_problem_template.format(\n                    example_problem=self.example_problem, example_response=self.example_response\n                )\n                + user_prompt\n            )\n        user_prompt += self.final_prompt\n        return system_prompt, user_prompt\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/probelm_instance"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_step",
      "md_content": [
        "**_step**: The `_step` function is responsible for executing a single optimization step in the `FunctionOptimizer` class. It performs various operations such as summarizing feedback, constructing prompts, calling the language model, extracting suggestions, constructing an update dictionary, and logging the interaction.\n\n**parameters**:\n- `self`: The instance of the `FunctionOptimizer` class.\n- `verbose` (optional): A boolean indicating whether to print verbose output. Default is `False`.\n- `mask` (optional): A list of strings specifying sections to exclude from the problem instance. Default is `None`.\n- `*args`: Additional positional arguments.\n- `**kwargs`: Additional keyword arguments.\n\n**Code Description**:\nThe `_step` function begins by asserting that the `propagator` attribute of the `FunctionOptimizer` instance is an instance of the `GraphPropagator` class. This ensures that the necessary methods and attributes are available for the subsequent operations.\n\nNext, the function calls the `summarize` method of the `FunctionOptimizer` class to aggregate feedback from all the parameters. This is done by invoking the `summarize` function defined in the `function_optimizer.py` file. The `summarize` function aggregates feedback by calling the `aggregate` method of the `propagator` object and processes the resulting `TraceGraph` object.\n\nAfter summarizing the feedback, the function constructs system and user prompts by calling the `construct_prompt` method of the `FunctionOptimizer` class. This method formats the prompts using the `representation_prompt`, `output_format_prompt`, and `user_prompt_template` attributes of the class. It also generates a problem instance string by calling the `problem_instance` method with the provided summary and mask. The prompts are then concatenated and stored in the `system_prompt` and `user_prompt` variables.\n\nThe function proceeds to call the `call_llm` method of the `FunctionOptimizer` class to interact with a language model. This method sends the system and user prompts to the language model and retrieves the generated response. The response is stored in the `response` variable.\n\nIf the response contains the string \"TERMINATE\", the function returns an empty dictionary.\n\nOtherwise, the function calls the `extract_llm_suggestion` method of the `FunctionOptimizer` class to extract a suggestion dictionary from the response. This method attempts to parse the response as JSON and retrieve the \"suggestion\" key. If the parsing fails, it falls back to extracting key-value pairs using regular expressions. The extracted suggestion dictionary is stored in the `suggestion` variable.\n\nThe function then calls the `construct_update_dict` method of the `FunctionOptimizer` class to convert the suggestion into the appropriate data types. This method iterates over the parameters of the optimizer and checks if each parameter is trainable and if its name exists in the suggestion dictionary. If both conditions are met, it attempts to convert the suggestion value to the data type of the parameter using the `type` function. The parameter and its updated value are added to the `update_dict` dictionary.\n\nIf the `log` attribute of the optimizer is not `None`, the function appends a dictionary containing the system prompt, user prompt, and response to the log.\n\nFinally, the function returns the `update_dict` dictionary, which maps `ParameterNode` objects to their corresponding updated values.\n\nThe `_step` function is an essential part of the optimization process in the `FunctionOptimizer` class. It relies on the `summarize`, `construct_prompt`, `call_llm`, `extract_llm_suggestion`, and `construct_update_dict` methods to perform its tasks. The function assumes that the necessary methods and attributes are correctly initialized and accessible within the class.\n\n**Note**:\n- The `summarize` function assumes that the `propagator` object is correctly initialized and contains the necessary methods and attributes.\n- The `summarize` function assumes that the `parameters` attribute of the class instance contains the necessary trainable nodes.\n- The `node_to_function_feedback` function should be defined and accessible within the project for the `summarize` function to work correctly.\n- The resulting `summary` object represents the aggregated feedback, variables, and inputs from the trainable parameters.\n- The `construct_prompt` function assumes that the summary object is properly populated with the required information before calling it.\n- The `construct_prompt` function assumes that the `representation_prompt`, `output_format_prompt`, `user_prompt_template`, `example_problem_template`, `example_problem`, `example_response`, and `final_prompt` attributes are correctly initialized within the class.\n- The `call_llm` function assumes that the `llm` object is correctly initialized and contains the necessary methods and attributes.\n- The `extract_llm_suggestion` function assumes that the response string contains a \"suggestion\" key within a JSON object.\n- The `construct_update_dict` function assumes that the `parameters` attribute exists and is a list of `ParameterNode` objects.\n- The `construct_update_dict` function assumes that the suggestion dictionary contains the keys corresponding to the `py_name` attribute of the `ParameterNode` objects.\n- If the suggestion is missing a key or the conversion fails, an exception is raised unless the `ignore_extraction_error` flag is set to `True`.\n- The `_step` function assumes that the necessary methods and attributes are correctly initialized within the class.\n\n**Output Example**:\nA possible return value of the `_step` function could be a dictionary mapping `ParameterNode` objects to their corresponding updated values:\n```\n{\n    <ParameterNode object>: <updated value>,\n    <ParameterNode object>: <updated value>,\n    ...\n}\n```"
      ],
      "code_start_line": 357,
      "code_end_line": 374,
      "params": [
        "self",
        "verbose",
        "mask"
      ],
      "have_return": true,
      "code_content": "    def _step(self, verbose=False, mask=None, *args, **kwargs) -> Dict[ParameterNode, Any]:\n        assert isinstance(self.propagator, GraphPropagator)\n        summary = self.summarize()\n        system_prompt, user_prompt = self.construct_prompt(summary, mask=mask)\n        response = self.call_llm(\n            system_prompt=system_prompt, user_prompt=user_prompt, verbose=verbose, max_tokens=self.max_tokens\n        )\n\n        if \"TERMINATE\" in response:\n            return {}\n\n        suggestion = self.extract_llm_suggestion(response)\n        update_dict = self.construct_update_dict(suggestion)\n\n        if self.log is not None:\n            self.log.append({\"system_prompt\": system_prompt, \"user_prompt\": user_prompt, \"response\": response})\n\n        return update_dict\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_prompt",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_update_dict",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/extract_llm_suggestion",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/call_llm",
        "opto\\optimizers\\optimizers.py/Optimizer/propagator",
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "construct_update_dict",
      "md_content": [
        "**construct_update_dict**: The function of construct_update_dict is to convert the suggestion in text into the right data type.\n\n**parameters**:\n- suggestion: A dictionary containing suggestions in text form.\n    - Type: Dict[str, Any]\n- return: A dictionary mapping ParameterNode objects to their corresponding updated values.\n    - Type: Dict[ParameterNode, Any]\n\n**Code Description**:\nThe `construct_update_dict` function takes a suggestion in text form and converts it into the appropriate data type. It iterates over the `parameters` list of the current instance and checks if each parameter is trainable and if its name exists in the suggestion dictionary. If both conditions are met, it attempts to convert the suggestion value to the data type of the parameter using the `type` function. If the conversion is successful, the parameter and its updated value are added to the `update_dict` dictionary.\n\nIn case the suggestion is missing the key or the conversion fails due to an incorrect data type, an exception is raised. However, if the `ignore_extraction_error` flag is set to True, a warning is issued instead of raising an exception.\n\nThe `update_dict` dictionary, containing the ParameterNode objects and their updated values, is then returned as the output of the function.\n\nThis function is called by the `_step` method of the `FunctionOptimizer` class in the `function_optimizer.py` file. In the `_step` method, the `construct_update_dict` function is used to convert the suggestion obtained from the language model into the appropriate data types for updating the parameters of the optimizer.\n\n**Note**:\n- The `construct_update_dict` function assumes that the `parameters` attribute exists and is a list of ParameterNode objects.\n- The `construct_update_dict` function assumes that the suggestion dictionary contains the keys corresponding to the `py_name` attribute of the ParameterNode objects.\n- If the suggestion is missing a key or the conversion fails, an exception is raised unless the `ignore_extraction_error` flag is set to True.\n\n**Output Example**:\nA possible return value of the `construct_update_dict` function could be a dictionary mapping ParameterNode objects to their corresponding updated values. For example:\n```\n{\n    <ParameterNode object>: <updated value>,\n    <ParameterNode object>: <updated value>,\n    ...\n}\n```"
      ],
      "code_start_line": 376,
      "code_end_line": 392,
      "params": [
        "self",
        "suggestion"
      ],
      "have_return": true,
      "code_content": "    def construct_update_dict(self, suggestion: Dict[str, Any]) -> Dict[ParameterNode, Any]:\n        \"\"\"Convert the suggestion in text into the right data type.\"\"\"\n        # TODO: might need some automatic type conversion\n        update_dict = {}\n        for node in self.parameters:\n            if node.trainable and node.py_name in suggestion:\n                try:\n                    update_dict[node] = type(node.data)(suggestion[node.py_name])\n                except (ValueError, KeyError) as e:\n                    # catch error due to suggestion missing the key or wrong data type\n                    if self.ignore_extraction_error:\n                        warnings.warn(\n                            f\"Cannot convert the suggestion '{suggestion[node.py_name]}' for {node.py_name} to the right data type\"\n                        )\n                    else:\n                        raise e\n        return update_dict\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false,
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "extract_llm_suggestion",
      "md_content": [
        "**extract_llm_suggestion**: The function of extract_llm_suggestion is to extract a suggestion dictionary from a given response string.\n\n**parameters**: The parameters of this Function.\n· response: A string containing the response from which the suggestion needs to be extracted.\n\n**Code Description**: The extract_llm_suggestion function is designed to parse a response string, typically from a language model, and extract a dictionary of suggestions. The function attempts to decode the response as JSON and retrieve the \"suggestion\" key. If the initial attempt fails due to a JSONDecodeError, the function tries to clean the response by extracting content within curly braces and attempts to decode it again. If the suggestion dictionary is still empty, the function uses a regular expression to manually extract key-value pairs from the response string.\n\nThe function is called by the _step method within the same class, FunctionOptimizer. In the _step method, the extract_llm_suggestion function is used to process the response from a language model call and extract meaningful suggestions, which are then used to construct an update dictionary. This update dictionary is crucial for the subsequent steps in the optimization process.\n\n**Note**: \n- The function makes two attempts to decode the response as JSON before resorting to regular expression parsing.\n- If the suggestion dictionary remains empty after all attempts, the function prints an error message indicating the failure to extract suggestions.\n- The function assumes that the response string contains a \"suggestion\" key within a JSON object.\n\n**Output Example**: \nIf the response string is '{\"suggestion\": {\"param1\": \"value1\", \"param2\": \"value2\"}}', the function will return:\n```\n{\n    \"param1\": \"value1\",\n    \"param2\": \"value2\"\n}\n```"
      ],
      "code_start_line": 394,
      "code_end_line": 431,
      "params": [
        "self",
        "response"
      ],
      "have_return": true,
      "code_content": "    def extract_llm_suggestion(self, response: str):\n        \"\"\"Extract the suggestion from the response.\"\"\"\n        suggestion = {}\n        attempt_n = 0\n        while attempt_n < 2:\n            try:\n                suggestion = json.loads(response)[\"suggestion\"]\n                break\n            except json.JSONDecodeError:  # TODO try to fix it\n                # Remove things outside the brackets\n                response = re.findall(r\"{.*}\", response, re.DOTALL)\n                if len(response) > 0:\n                    response = response[0]\n                attempt_n += 1\n            except Exception:\n                attempt_n += 1\n\n        if len(suggestion) == 0:\n            # we try to extract key/value separately and return it as a dictionary\n            pattern = r'\"suggestion\"\\s*:\\s*\\{(.*?)\\}'\n            suggestion_match = re.search(pattern, str(response), re.DOTALL)\n            if suggestion_match:\n                suggestion = {}\n                # Extract the entire content of the suggestion dictionary\n                suggestion_content = suggestion_match.group(1)\n                # Regex to extract each key-value pair;\n                # This scheme assumes double quotes but is robust to missing cammas at the end of the line\n                pair_pattern = r'\"([a-zA-Z0-9_]+)\"\\s*:\\s*\"(.*)\"'\n                # Find all matches of key-value pairs\n                pairs = re.findall(pair_pattern, suggestion_content, re.DOTALL)\n                for key, value in pairs:\n                    suggestion[key] = value\n\n        if len(suggestion) == 0:\n            print(\"Cannot extract suggestion from LLM's response:\")\n            print(response)\n\n        return suggestion\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "call_llm",
      "md_content": [
        "**call_llm**: The function of call_llm is to interact with a language model (LLM) using provided prompts and return the generated response.\n\n**parameters**: The parameters of this Function.\n· system_prompt: A string representing the initial prompt given to the LLM, typically setting the context or instructions for the LLM.\n· user_prompt: A string representing the user's input or query that follows the system prompt.\n· verbose: A boolean or string parameter that controls the verbosity of the function. If set to True or \"output\", the prompts and responses are printed to the console.\n· max_tokens: An integer specifying the maximum number of tokens the LLM should generate in its response. The default value is 4096.\n\n**Code Description**: The call_llm function is designed to facilitate communication with a language model by sending it a structured prompt and retrieving its response. The function first checks the verbosity setting; if verbose is set to True or \"output\", it prints the combined system and user prompts. It then constructs a message list with roles \"system\" and \"user\" to format the prompts appropriately for the LLM.\n\nThe function attempts to generate a response from the LLM in JSON format. If this attempt fails, it falls back to a simpler response generation method, using the max_tokens parameter to limit the response length. The response content is extracted from the LLM's output and, if verbosity is enabled, printed to the console. Finally, the function returns the LLM's response content.\n\nThis function is called by the _step method within the same module. The _step method uses call_llm to generate suggestions or updates based on the current state summarized by the system and user prompts. The response from call_llm is then processed to extract actionable suggestions, which are used to update the system's state.\n\n**Note**: \n- Ensure that the LLM instance (self.llm) is properly initialized before calling this function.\n- The verbose parameter can be used to debug or log the interaction with the LLM by printing the prompts and responses.\n- Handle exceptions appropriately when the LLM fails to generate a JSON response.\n\n**Output Example**: \nA possible return value of the function might look like:\n```\n\"Sure, I can help you with that. What specific information are you looking for?\"\n```"
      ],
      "code_start_line": 433,
      "code_end_line": 453,
      "params": [
        "self",
        "system_prompt",
        "user_prompt",
        "verbose",
        "max_tokens"
      ],
      "have_return": true,
      "code_content": "    def call_llm(\n        self, system_prompt: str, user_prompt: str, verbose: Union[bool, str] = False, max_tokens: int = 4096\n    ):  # TODO Get this from utils?\n        \"\"\"Call the LLM with a prompt and return the response.\"\"\"\n        if verbose not in (False, \"output\"):\n            print(\"Prompt\\n\", system_prompt + user_prompt)\n\n        messages = [{\"role\": \"system\", \"content\": system_prompt}, {\"role\": \"user\", \"content\": user_prompt}]\n\n        try:  # Try tp force it to be a json object\n            response = self.llm.create(\n                messages=messages,\n                response_format={\"type\": \"json_object\"},\n            )\n        except Exception:\n            response = self.llm.create(messages=messages, max_tokens=max_tokens)\n        response = response.choices[0].message.content\n\n        if verbose:\n            print(\"LLM response:\\n\", response)\n        return response\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "FunctionOptimizerV2",
      "md_content": [
        "**FunctionOptimizerV2**: The function of FunctionOptimizerV2 is to serve as an enhanced version of the FunctionOptimizer class, providing additional functionality and improvements to the optimization process.\n\n**attributes**:\n- output_format_prompt: A string that defines the output format of the optimizer's response.\n- example_problem_template: A string template for an example problem instance and response.\n- user_prompt_template: A string template for the user prompt.\n- example_prompt: A string that provides feasible but not optimal solutions for the current problem instance as a hint.\n- final_prompt: A string template for the final prompt.\n\n**Code Description**:\nThe FunctionOptimizerV2 class is a subclass of the FunctionOptimizer class and provides an enhanced version of the optimization process. It extends the FunctionOptimizer class and overrides some of its methods to add additional functionality.\n\nThe `__init__` method initializes the FunctionOptimizerV2 object by calling the superclass's `__init__` method and passing the arguments. It also initializes the `memory` attribute, which is a FIFOBuffer object used to store past variables and feedbacks.\n\nThe `construct_prompt` method overrides the superclass's method to add examples from the memory to the user prompt. It checks if the memory is not empty and adds the variables and feedbacks from the memory to the user prompt.\n\n**Note**:\n- The FunctionOptimizerV2 class is designed to enhance the optimization process by adding memory functionality.\n- The class extends the FunctionOptimizer class and overrides some of its methods to add the desired functionality.\n- The `memory` attribute stores past variables and feedbacks.\n- The `construct_prompt` method adds examples from the memory to the user prompt.\n\n**Output Example**:\n{\n    \"reasoning\": \"In this case, the desired response would be to change the value of input a to 14, as that would make the code return 10.\",\n    \"answer\": {},\n    \"suggestion\": {\n        \"a\": 10\n    }\n}"
      ],
      "code_start_line": 456,
      "code_end_line": 480,
      "params": [],
      "have_return": false,
      "code_content": "class FunctionOptimizerV2(FunctionOptimizer):\n    # Make the reasoning part more explicit\n\n    output_format_prompt = dedent(\n        \"\"\"\n        Output_format: Your output should be in the following json format, satisfying the json syntax:\n\n        {{\n        \"reasoning\": <Your reasoning>,\n        \"answer\": <Your answer>,\n        \"suggestion\": {{\n            <variable_1>: <suggested_value_1>,\n            <variable_2>: <suggested_value_2>,\n        }}\n        }}\n\n        In \"reasoning\", explain the problem: 1. what the #Instruction means 2. what the #Feedback on #Output means to #Variables considering how #Variables are used in #Code and other values in #Documentation, #Inputs, #Others. 3. Reasoning about the suggested changes in #Variables (if needed) and the expected result.\n\n        If #Instruction asks for an answer, write it down in \"answer\".\n\n        If you need to suggest a change in the values of #Variables, write down the suggested values in \"suggestion\". Remember you can change only the values in #Variables, not others. When <type> of a variable is (code), you should write the new definition in the format of python code without syntax errors, and you should not change the function name or the function signature.\n\n        If no changes or answer are needed, just output TERMINATE.\n        \"\"\"\n    )\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\__init__.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizerV2Memory"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "FunctionOptimizerV2Memory",
      "md_content": [
        "**FunctionOptimizerV2Memory**: The function of FunctionOptimizerV2Memory is to enhance the optimization process by incorporating a memory mechanism that stores past variables and feedbacks.\n\n**attributes**: The attributes of this Class.\n· memory: A FIFOBuffer object that stores past variables and feedbacks.\n\n**Code Description**: The FunctionOptimizerV2Memory class extends the FunctionOptimizerV2 class by adding a memory mechanism to the optimization process. This class is designed to improve the optimization process by utilizing past experiences stored in memory.\n\nThe `__init__` method initializes the FunctionOptimizerV2Memory object. It calls the superclass's `__init__` method with the provided arguments and initializes the `memory` attribute as a FIFOBuffer object with a specified memory size.\n\nThe `construct_prompt` method constructs the system and user prompts by calling the superclass's `construct_prompt` method. It then checks if the memory contains any past variables and feedbacks. If the memory is not empty, it adds these examples to the user prompt. The method splits the user prompt at the final prompt, adds a section containing past variables and feedbacks, and then reconstructs the user prompt. Finally, it adds the current summary's variables and user feedback to the memory.\n\nThis class is used within the project to enhance the functionality of the FunctionOptimizerV2 by adding a memory component, which allows the optimizer to consider past experiences when constructing prompts.\n\n**Note**:\n- The memory attribute is a FIFOBuffer that stores past variables and feedbacks.\n- The construct_prompt method enhances the user prompt by including examples from the memory.\n- This class is designed to improve the optimization process by leveraging past experiences.\n\n**Output Example**:\n```json\n{\n    \"system_prompt\": \"System prompt content here...\",\n    \"user_prompt\": \"User prompt content here...\\nBelow are some variables and their feedbacks you received in the past.\\n\\n{\\n    \\\"variables\\\": {\\n        \\\"var1\\\": \\\"value1\\\",\\n        \\\"var2\\\": \\\"value2\\\"\\n    },\\n    \\\"feedback\\\": \\\"feedback content\\\"\\n}\\n\\nFinal prompt content here...\"\n}\n```"
      ],
      "code_start_line": 483,
      "code_end_line": 513,
      "params": [],
      "have_return": true,
      "code_content": "class FunctionOptimizerV2Memory(FunctionOptimizerV2):\n    # Add memory to the optimizer\n    def __init__(self, *args, memory_size=0, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.memory = FIFOBuffer(memory_size)\n\n    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        system_prompt, user_prompt = super().construct_prompt(summary, mask=mask)\n        if len(self.memory) > 0:  # Add examples\n            prefix = user_prompt.split(self.final_prompt)[0]\n            examples = []\n            for variables, feedback in self.memory:\n                examples.append(\n                    json.dumps(\n                        {\n                            \"variables\": {k: v[0] for k, v in variables.items()},\n                            \"feedback\": feedback,\n                        },\n                        indent=4,\n                    )\n                )\n            examples = \"\\n\".join(examples)\n            user_prompt = (\n                prefix\n                + f\"\\nBelow are some variables and their feedbacks you received in the past.\\n\\n{examples}\\n\\n\"\n                + self.final_prompt\n            )\n        self.memory.add((summary.variables, summary.user_feedback))\n\n        return system_prompt, user_prompt\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\__init__.py"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizerV2"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the FunctionOptimizerV2Memory class with optional memory size and other parameters.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· memory_size: An optional integer parameter that specifies the size of the FIFO buffer. Default is 0.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The __init__ method is the constructor for the FunctionOptimizerV2Memory class. It begins by calling the constructor of its superclass using `super().__init__(*args, **kwargs)`, ensuring that any initialization logic in the parent class is executed. Following this, it initializes a FIFOBuffer instance with the specified memory size by passing the `memory_size` parameter to the FIFOBuffer constructor. The FIFOBuffer is assigned to the `self.memory` attribute of the FunctionOptimizerV2Memory instance.\n\nThe FIFOBuffer class, which is used here, manages a First-In-First-Out (FIFO) buffer of a specified size. This buffer is designed to store a limited number of items, automatically discarding the oldest items when new ones are added beyond its capacity. In the context of FunctionOptimizerV2Memory, the FIFOBuffer likely serves to maintain a history of optimization states or results, ensuring that only the most recent entries are kept.\n\n**Note**: \n- Ensure that the `memory_size` parameter is a non-negative integer to avoid unexpected behavior.\n- The FIFOBuffer will automatically discard the oldest items when new items are added beyond its capacity, maintaining the specified buffer size."
      ],
      "code_start_line": 485,
      "code_end_line": 487,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, *args, memory_size=0, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.memory = FIFOBuffer(memory_size)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\buffers.py/FIFOBuffer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "construct_prompt",
      "md_content": [
        "**construct_prompt**: The function of construct_prompt is to construct the system and user prompt.\n\n**parameters**: The parameters of this Function.\n· summary: A summary object containing variables and user feedback.\n· mask: An optional parameter to mask certain parts of the prompt.\n· *args: Additional positional arguments.\n· **kwargs: Additional keyword arguments.\n\n**Code Description**: The construct_prompt function is designed to create both system and user prompts by leveraging the functionality of its superclass. Initially, it calls the superclass's construct_prompt method to generate the base system and user prompts. \n\nIf the memory buffer contains any entries, the function enhances the user prompt by adding examples from past interactions. It does this by splitting the user prompt at a predefined final prompt and then appending a formatted string that includes past variables and their corresponding feedback. These examples are formatted as JSON strings for clarity and are joined together with newline characters.\n\nAfter constructing the enhanced user prompt, the function adds the current summary's variables and user feedback to the memory buffer using the add method from the FIFOBuffer class. This ensures that the memory buffer is updated with the latest interaction, maintaining a record of past interactions for future use.\n\n**Note**: \n- The memory buffer must be properly initialized and managed to ensure that past interactions are correctly stored and retrieved.\n- Proper handling of the mask parameter is essential if masking functionality is required.\n- The function relies on the superclass's construct_prompt method, so any changes to the superclass method may affect this function's behavior.\n\n**Output Example**: \nA possible return value of the function could be:\n```\nsystem_prompt: \"System prompt content\"\nuser_prompt: \"User prompt content\\nBelow are some variables and their feedbacks you received in the past.\\n\\n{\\n    \\\"variables\\\": {\\n        \\\"var1\\\": \\\"value1\\\",\\n        \\\"var2\\\": \\\"value2\\\"\\n    },\\n    \\\"feedback\\\": \\\"positive\\\"\\n}\\n\\nFinal prompt content\"\n```"
      ],
      "code_start_line": 489,
      "code_end_line": 513,
      "params": [
        "self",
        "summary",
        "mask"
      ],
      "have_return": true,
      "code_content": "    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        system_prompt, user_prompt = super().construct_prompt(summary, mask=mask)\n        if len(self.memory) > 0:  # Add examples\n            prefix = user_prompt.split(self.final_prompt)[0]\n            examples = []\n            for variables, feedback in self.memory:\n                examples.append(\n                    json.dumps(\n                        {\n                            \"variables\": {k: v[0] for k, v in variables.items()},\n                            \"feedback\": feedback,\n                        },\n                        indent=4,\n                    )\n                )\n            examples = \"\\n\".join(examples)\n            user_prompt = (\n                prefix\n                + f\"\\nBelow are some variables and their feedbacks you received in the past.\\n\\n{examples}\\n\\n\"\n                + self.final_prompt\n            )\n        self.memory.add((summary.variables, summary.user_feedback))\n\n        return system_prompt, user_prompt\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\buffers.py/FIFOBuffer/add"
      ],
      "special_reference_type": [
        false
      ]
    }
  ],
  "opto\\optimizers\\opro.py": [
    {
      "type": "ClassDef",
      "name": "OPRO",
      "md_content": [
        "**OPRO**: The function of OPRO is to serve as a subclass of the FunctionOptimizer class, implementing the optimization process for a specific problem. It overrides the `_step` method to propose new parameter values based on feedback and constructs the update dictionary. It also provides methods for constructing prompts, extracting suggestions, and calling the Language Model (LLM).\n\n**attributes**:\n- user_prompt_template: A template for the user prompt, including placeholders for the problem instance and the instruction.\n- output_format_prompt: A template for the output format of the optimizer's response, specifying the JSON format and providing a structure for the response.\n- default_objective: The default objective of the optimizer, which is to change the values of the variables in the `#Variables` section to improve the output according to the feedback.\n- buffer: A list used to store the variables and feedback from each step of the optimization process.\n\n**Code Description**:\nThe OPRO class is a subclass of the FunctionOptimizer class and provides a specific implementation for optimizing a problem. It extends the FunctionOptimizer class and overrides the `_step` method to propose new parameter values based on feedback and construct the update dictionary.\n\nThe `__init__` method initializes the OPRO object by calling the superclass's `__init__` method and passing the arguments. It also initializes the `buffer` attribute as an empty list.\n\nThe `construct_prompt` method constructs the system and user prompts based on the summary and a mask. It uses the `user_prompt_template` attribute to format the user prompt, including the problem instance and the instruction.\n\nThe `_step` method is responsible for proposing new parameter values based on feedback. It calls the LLM with the system and user prompts and extracts the suggestion from the response. It then constructs the update dictionary using the `construct_update_dict` method.\n\nThe `construct_update_dict` method converts the suggestion in text format into the right data type and constructs an update dictionary. It iterates over the trainable parameters and checks if the parameter is present in the suggestion. If it is, it tries to convert the suggestion value to the data type of the parameter and adds it to the update dictionary.\n\nThe `extract_llm_suggestion` method extracts the suggestion from the response received from the LLM. It first tries to parse the response as a JSON object and extract the suggestion from the \"suggestion\" field. If that fails, it tries to extract the suggestion key-value pairs using regular expressions.\n\nThe `call_llm` method calls the LLM with a prompt and returns the response. It formats the prompt as a list of messages with system and user roles and calls the LLM's `create` method. It then retrieves the response from the LLM's `choices` attribute.\n\n**Note**:\n- The OPRO class is designed to be subclassed and extended to create specific optimizers for different types of problems.\n- Subclasses of OPRO must implement the `_step` method.\n- The OPRO class provides methods for constructing prompts, extracting suggestions, and calling the LLM.\n- The class uses the FunctionOptimizer class as its superclass and inherits its attributes and methods.\n\n**Output Example**:\n{\n    \"reasoning\": \"In this case, the desired response would be to change the value of input a to 14, as that would make the code return 10.\",\n    \"answer\": {},\n    \"suggestion\": {\n        \"a\": 10\n    }\n}"
      ],
      "code_start_line": 18,
      "code_end_line": 72,
      "params": [],
      "have_return": true,
      "code_content": "class OPRO(FunctionOptimizer):\n    user_prompt_template = dedent(\n        \"\"\"\n        Below are some example variables and their feedbacks.\n\n        {examples}\n\n        ================================\n\n        {instruction}\n        \"\"\"\n    )\n\n    output_format_prompt = dedent(\n        \"\"\"\n        Output_format: Your output should be in the following json format, satisfying the json syntax:\n\n        {{\n        \"suggestion\": {{\n            <variable_1>: <suggested_value_1>,\n            <variable_2>: <suggested_value_2>,\n        }}\n        }}\n\n        When suggestion variables, write down the suggested values in \"suggestion\".  When <type> of a variable is (code), you should write the new definition in the format of python code without syntax errors, and you should not change the function name or the function signature.\n\n        If no changes or answer are needed, just output TERMINATE.\n        \"\"\"\n    )\n\n    default_objective = \"Come up with a new variable in accordance to feedback.\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.buffer = []\n\n    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        self.buffer.append((summary.variables, summary.user_feedback))\n\n        examples = []\n        for variables, feedback in self.buffer:\n            examples.append(\n                json.dumps(\n                    {\n                        \"variables\": {k: v[0] for k, v in variables.items()},\n                        \"feedback\": feedback,\n                    },\n                    indent=4,\n                )\n            )\n        examples = \"\\n\".join(examples)\n\n        user_prompt = self.user_prompt_template.format(examples=examples, instruction=self.objective)\n        return self.output_format_prompt, user_prompt",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\__init__.py"
      ],
      "reference_who": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the OPRO class.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The __init__ method is a constructor that initializes an instance of the OPRO class. It begins by calling the __init__ method of its superclass using the super() function, passing along any arguments (*args) and keyword arguments (**kwargs) it received. This ensures that the parent class is properly initialized. After the superclass initialization, it creates an instance variable named 'buffer' and initializes it as an empty list. This 'buffer' can be used to store data or objects that are relevant to the instance of the OPRO class.\n\n**Note**: \n- Ensure that the superclass of OPRO is correctly defined and its __init__ method is compatible with the arguments passed.\n- The 'buffer' list is initialized as empty and can be used to store any necessary data during the lifecycle of the OPRO instance."
      ],
      "code_start_line": 50,
      "code_end_line": 52,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.buffer = []\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "construct_prompt",
      "md_content": [
        "**construct_prompt**: The function of construct_prompt is to construct the system and user prompt based on the provided summary and optional mask.\n\n**parameters**: The parameters of this Function.\n· summary: An object containing variables and user feedback.\n· mask: An optional parameter that can be used to filter or modify the prompt construction process.\n· *args: Additional positional arguments.\n· **kwargs: Additional keyword arguments.\n\n**Code Description**: The construct_prompt function begins by appending a tuple of summary variables and user feedback to the buffer. It then iterates over the buffer to create a list of examples. Each example is a JSON-formatted string that includes the variables and feedback. The variables are formatted such that only the first element of each variable's value is included. These examples are joined into a single string with newline characters separating them.\n\nNext, the function constructs the user prompt by formatting the user_prompt_template with the examples and the objective. Finally, it returns a tuple containing the output_format_prompt and the constructed user prompt.\n\n**Note**: \n- Ensure that the summary object contains the necessary attributes: variables and user_feedback.\n- The buffer is assumed to be an attribute of the class instance and should be initialized before calling this function.\n- The user_prompt_template and objective should also be defined as attributes of the class instance.\n\n**Output Example**: \nAssuming the buffer contains two entries with the following data:\n1. variables: {'var1': ['value1'], 'var2': ['value2']}\n   feedback: 'Good'\n2. variables: {'var3': ['value3'], 'var4': ['value4']}\n   feedback: 'Needs improvement'\n\nThe returned tuple might look like:\n('output_format_prompt_value', 'User prompt with examples:\\n{\\n    \"variables\": {\\n        \"var1\": \"value1\",\\n        \"var2\": \"value2\"\\n    },\\n    \"feedback\": \"Good\"\\n}\\n{\\n    \"variables\": {\\n        \"var3\": \"value3\",\\n        \"var4\": \"value4\"\\n    },\\n    \"feedback\": \"Needs improvement\"\\n}\\nInstruction: objective_value')"
      ],
      "code_start_line": 54,
      "code_end_line": 72,
      "params": [
        "self",
        "summary",
        "mask"
      ],
      "have_return": true,
      "code_content": "    def construct_prompt(self, summary, mask=None, *args, **kwargs):\n        \"\"\"Construct the system and user prompt.\"\"\"\n        self.buffer.append((summary.variables, summary.user_feedback))\n\n        examples = []\n        for variables, feedback in self.buffer:\n            examples.append(\n                json.dumps(\n                    {\n                        \"variables\": {k: v[0] for k, v in variables.items()},\n                        \"feedback\": feedback,\n                    },\n                    indent=4,\n                )\n            )\n        examples = \"\\n\".join(examples)\n\n        user_prompt = self.user_prompt_template.format(examples=examples, instruction=self.objective)\n        return self.output_format_prompt, user_prompt",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\optimizers\\optimizers.py": [
    {
      "type": "ClassDef",
      "name": "AbstractOptimizer",
      "md_content": [
        "**AbstractOptimizer**: The function of AbstractOptimizer is to serve as a base class for optimizers, responsible for updating parameters based on feedback.\n\n**attributes**: The attributes of this Class.\n· parameters: A list of ParameterNode objects that the optimizer will manage and update.\n\n**Code Description**: The AbstractOptimizer class is designed to be a foundational class for creating various optimizers. It ensures that any derived optimizer class will have a consistent interface and behavior for managing and updating parameters.\n\n- The `__init__` method initializes the optimizer with a list of ParameterNode objects. It asserts that the provided parameters are indeed a list and that each element in the list is an instance of ParameterNode. This ensures type safety and consistency in the parameters being managed.\n\n- The `step` method is an abstract method intended to be overridden by subclasses. It is supposed to contain the logic for updating the parameters based on feedback. Since it is not implemented in AbstractOptimizer, any subclass must provide an implementation for this method.\n\n- The `zero_feedback` method is another abstract method that must be implemented by subclasses. It is intended to reset the feedback for all parameters, preparing them for the next optimization step.\n\n- The `propagator` property is designed to return a Propagator object, which can be used to propagate feedback backward through the network. This property must also be implemented by any subclass.\n\nThe AbstractOptimizer class is called by the Optimizer class, which extends its functionality. The Optimizer class provides concrete implementations for the abstract methods defined in AbstractOptimizer. For instance, it implements the `step` method to propose new parameter values based on feedback and then update the parameters accordingly. It also provides a `zero_feedback` method to reset feedback for all parameters and a `propagator` property to return the appropriate Propagator object.\n\n**Note**: \n- Any subclass of AbstractOptimizer must implement the `step`, `zero_feedback`, and `propagator` methods.\n- The parameters passed to the AbstractOptimizer must be a list of ParameterNode instances.\n- The class ensures a consistent interface for optimizers, making it easier to extend and create new optimization algorithms."
      ],
      "code_start_line": 12,
      "code_end_line": 31,
      "params": [],
      "have_return": false,
      "code_content": "class AbstractOptimizer:\n    \"\"\"An optimizer is responsible for updating the parameters based on the feedback.\"\"\"\n\n    def __init__(self, parameters: List[ParameterNode], *args, **kwargs):\n        assert type(parameters) is list\n        assert all([isinstance(p, ParameterNode) for p in parameters])\n        self.parameters = parameters\n\n    def step(self):\n        \"\"\"Update the parameters based on the feedback.\"\"\"\n        raise NotImplementedError\n\n    def zero_feedback(self):\n        \"\"\"Reset the feedback.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def propagator(self):\n        \"\"\"Return a Propagator object that can be used to propagate feedback in backward.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\optimizers.py/Optimizer"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the AbstractOptimizer class with a list of ParameterNode objects.\n\n**parameters**: The parameters of this Function.\n· parameters: A list of ParameterNode objects that represent the parameters to be optimized.\n· *args: Additional positional arguments.\n· **kwargs: Additional keyword arguments.\n\n**Code Description**: The __init__ method of the AbstractOptimizer class is responsible for initializing the optimizer with a set of parameters. It takes a list of ParameterNode objects as its primary argument. The method first asserts that the provided parameters argument is indeed a list. It then checks that every element in this list is an instance of the ParameterNode class. If these conditions are met, the parameters are assigned to the instance variable self.parameters.\n\nThe ParameterNode class, which is used in this context, represents a trainable node in a computational graph. It is initialized with various attributes such as value, name, trainable status, description, constraint, and additional info. The ParameterNode class inherits from a generic Node class and adds itself to a set of dependencies upon initialization.\n\n**Note**: \n- Ensure that the parameters argument passed to the __init__ method is a list of ParameterNode objects.\n- The method uses assertions to enforce type checking, which will raise an AssertionError if the conditions are not met.\n- Additional positional and keyword arguments (*args and **kwargs) are accepted but not utilized within this method."
      ],
      "code_start_line": 15,
      "code_end_line": 18,
      "params": [
        "self",
        "parameters"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, parameters: List[ParameterNode], *args, **kwargs):\n        assert type(parameters) is list\n        assert all([isinstance(p, ParameterNode) for p in parameters])\n        self.parameters = parameters\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "step",
      "md_content": [
        "**step**: The function of step is to update the parameters based on the feedback.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The step function is designed to update the parameters of an optimizer based on feedback. However, in its current form, it is an abstract method, meaning it is intended to be overridden by subclasses of the AbstractOptimizer class. The method raises a NotImplementedError, which indicates that any subclass must provide its own implementation of the step method. This design enforces that the specific logic for updating parameters must be defined in the subclasses, ensuring that the AbstractOptimizer class remains flexible and adaptable to various optimization strategies.\n\n**Note**: \n- This method must be implemented in any subclass of AbstractOptimizer.\n- Attempting to call this method directly from an instance of AbstractOptimizer will result in a NotImplementedError.\n- Ensure that the subclass provides a concrete implementation of the step method to perform the actual parameter update logic."
      ],
      "code_start_line": 20,
      "code_end_line": 22,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def step(self):\n        \"\"\"Update the parameters based on the feedback.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "zero_feedback",
      "md_content": [
        "**zero_feedback**: The function of zero_feedback is to reset the feedback.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The zero_feedback function is designed to reset the feedback mechanism within an optimizer. However, the function is currently not implemented and raises a NotImplementedError when called. This indicates that any subclass inheriting from the class containing this function must provide its own implementation of the zero_feedback method. The purpose of this function is to ensure that subclasses define how the feedback should be reset, which is crucial for the proper functioning of the optimizer.\n\n**Note**: When using this function, it is important to implement the zero_feedback method in any subclass that inherits from the parent class. Failure to do so will result in a NotImplementedError being raised, which will halt the execution of the program. This function serves as a placeholder to enforce the implementation of feedback resetting logic in derived classes."
      ],
      "code_start_line": 24,
      "code_end_line": 26,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def zero_feedback(self):\n        \"\"\"Reset the feedback.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "propagator",
      "md_content": [
        "**propagator**: The function of propagator is to return a Propagator object that can be used to propagate feedback in backward.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The propagator function is designed to return a Propagator object, which is intended to be used for propagating feedback in a backward pass. However, the current implementation of this function raises a NotImplementedError. This indicates that the function is meant to be overridden in a subclass, where the actual logic for returning a Propagator object should be provided. The NotImplementedError serves as a placeholder to remind developers that they need to implement this method in any concrete subclass derived from the abstract class.\n\n**Note**: When using this function, ensure that it is properly overridden in any subclass. Attempting to call this method directly from the abstract class without overriding it will result in a NotImplementedError."
      ],
      "code_start_line": 29,
      "code_end_line": 31,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def propagator(self):\n        \"\"\"Return a Propagator object that can be used to propagate feedback in backward.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Optimizer",
      "md_content": [
        "**Optimizer**: The function of Optimizer is to serve as a base class for optimizers, responsible for updating parameters based on feedback.\n\n**attributes**:\n- parameters: A list of ParameterNode objects that the optimizer will manage and update.\n\n**Code Description**:\nThe Optimizer class is a base class for creating various optimizers. It provides a consistent interface and behavior for managing and updating parameters based on feedback. The class extends the AbstractOptimizer class and implements the abstract methods defined in it.\n\nThe `__init__` method initializes the optimizer with a list of ParameterNode objects. It ensures that the provided parameters are a list and that each element in the list is an instance of ParameterNode. This ensures type safety and consistency in the parameters being managed. The method also sets the propagator attribute to the default propagator returned by the default_propagator method.\n\nThe `propagator` property returns the propagator object associated with the optimizer.\n\nThe `step` method is responsible for proposing new parameter values based on feedback and updating the parameters accordingly. It calls the `propose` method to get the proposed update dictionary and then calls the `update` method to update the trainable parameters with the new data.\n\nThe `propose` method is a helper method that calls the `_step` method to get the new data of the parameters based on the feedback.\n\nThe `update` method updates the trainable parameters with the new data provided in the update dictionary. It iterates over the items in the update dictionary and updates the data of each trainable parameter if it is marked as trainable.\n\nThe `zero_feedback` method resets the feedback for all parameters by calling the `zero_feedback` method of each parameter.\n\nThe `_step` method is an abstract method that must be implemented by subclasses. It returns the new data of parameter nodes based on the feedback. Subclasses should provide their own implementation of this method.\n\nThe `default_propagator` method is an abstract method that must be implemented by subclasses. It returns the default Propagator object of the optimizer. Subclasses should provide their own implementation of this method.\n\nThe `backward` method propagates the feedback backward by calling the `backward` method of the given node with the propagator object.\n\n**Note**:\n- Any subclass of Optimizer must implement the `_step`, `default_propagator`, and `backward` methods.\n- The parameters passed to the Optimizer must be a list of ParameterNode instances.\n- The class ensures a consistent interface for optimizers, making it easier to extend and create new optimization algorithms.\n\n**Output Example**:\n```python\n{\n    'parameter1': value1,\n    'parameter2': value2,\n    ...\n}\n```"
      ],
      "code_start_line": 34,
      "code_end_line": 74,
      "params": [],
      "have_return": true,
      "code_content": "class Optimizer(AbstractOptimizer):\n    def __init__(self, parameters: List[ParameterNode], *args, propagator: Propagator = None, **kwargs):\n        super().__init__(parameters)\n        propagator = propagator if propagator is not None else self.default_propagator()\n        assert isinstance(propagator, Propagator)\n        self._propagator = propagator\n\n    @property\n    def propagator(self):\n        return self._propagator\n\n    def step(self, *args, **kwargs):\n        update_dict = self.propose(*args, **kwargs)\n        self.update(update_dict)\n\n    def propose(self, *args, **kwargs):\n        \"\"\"Propose the new data of the parameters based on the feedback.\"\"\"\n        return self._step(*args, **kwargs)\n\n    def update(self, update_dict: Dict[ParameterNode, Any]):\n        \"\"\"Update the trainable parameters given a dictionary of new data.\"\"\"\n        for p, d in update_dict.items():\n            if p.trainable:\n                p._data = d\n\n    def zero_feedback(self):\n        for p in self.parameters:\n            p.zero_feedback()\n\n    # Subclass should implement the methods below.\n    def _step(self, *args, **kwargs) -> Dict[ParameterNode, Any]:\n        \"\"\"Return the new data of parameter nodes based on the feedback.\"\"\"\n        raise NotImplementedError\n\n    def default_propagator(self):\n        \"\"\"Return the default Propagator object of the optimizer.\"\"\"\n        raise NotImplementedError\n\n    def backward(self, node: Node, *args, **kwargs):\n        \"\"\"Propagate the feedback backward.\"\"\"\n        return node.backward(*args, propagator=self.propagator, **kwargs)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer",
        "opto\\optimizers\\opro.py"
      ],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/AbstractOptimizer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the Optimizer class with specified parameters and an optional propagator.\n\n**parameters**: The parameters of this Function.\n· parameters: A list of ParameterNode objects that represent the parameters to be optimized.\n· *args: Additional positional arguments.\n· propagator: An optional Propagator object. If not provided, a default Propagator will be used.\n· **kwargs: Additional keyword arguments.\n\n**Code Description**: The __init__ method initializes an Optimizer instance. It first calls the superclass's __init__ method with the provided parameters. Then, it checks if a propagator is provided. If not, it calls the default_propagator method to obtain a default Propagator. The method ensures that the propagator is an instance of the Propagator class. Finally, it assigns the propagator to the instance's _propagator attribute. This setup ensures that the Optimizer always has a valid Propagator, either provided explicitly or obtained through the default_propagator method.\n\n**Note**: When using this class, ensure that the parameters argument is a list of ParameterNode objects and that the propagator, if provided, is an instance of the Propagator class. If no propagator is provided, the default_propagator method must be properly implemented in a subclass to avoid a NotImplementedError."
      ],
      "code_start_line": 35,
      "code_end_line": 39,
      "params": [
        "self",
        "parameters"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, parameters: List[ParameterNode], *args, propagator: Propagator = None, **kwargs):\n        super().__init__(parameters)\n        propagator = propagator if propagator is not None else self.default_propagator()\n        assert isinstance(propagator, Propagator)\n        self._propagator = propagator\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/Optimizer/default_propagator",
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\propagators\\propagators.py/Propagator"
      ],
      "special_reference_type": [
        false,
        true,
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "propagator",
      "md_content": [
        "**propagator**: The function of propagator is to return the internal `_propagator` attribute of the class.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The `propagator` function is a simple accessor method that returns the value of the `_propagator` attribute from the class instance. This method does not take any parameters and directly provides access to the internal `_propagator` attribute, which is presumably an instance of a propagator object used within the class.\n\nThe `propagator` function is utilized in several other methods within the project. For instance, in the `summarize` method of the `FunctionOptimizer` class, it is used to aggregate feedback from all trainable parameters. The `propagator` is called to perform the aggregation of feedbacks, which are then summed up to create a summary.\n\nIn the `_step` method of the `FunctionOptimizer` class, the `propagator` is asserted to be an instance of `GraphPropagator` before summarizing the feedback and constructing prompts for further processing.\n\nAdditionally, in the `backward` method of the `Optimizer` class, the `propagator` is passed as an argument to the `backward` method of a node, facilitating the backward propagation of feedback.\n\n**Note**: This function is a straightforward accessor and does not perform any additional logic or validation. It is essential that the `_propagator` attribute is correctly initialized within the class for this method to function as expected.\n\n**Output Example**: The return value of the `propagator` function would be the internal `_propagator` object, which could be an instance of a class responsible for propagating information or feedback within the optimization process. For example:\n```\n<GraphPropagator object at 0x7f8b9c0d1d30>\n```"
      ],
      "code_start_line": 42,
      "code_end_line": 43,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def propagator(self):\n        return self._propagator\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step",
        "opto\\optimizers\\optimizers.py/Optimizer/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "step",
      "md_content": [
        "**step**: The function of step is to execute a single optimization step by proposing new parameter data and updating the parameters accordingly.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The step function is a method within the Optimizer class that orchestrates the process of updating the trainable parameters. It performs this task in two main stages:\n\n1. **Propose New Data**: The function first calls the propose method, passing along any positional and keyword arguments it receives. The propose method generates a dictionary (update_dict) containing new data for the parameters. This dictionary is created based on feedback and is essential for the subsequent update process.\n\n2. **Update Parameters**: After obtaining the update_dict from the propose method, the step function calls the update method. The update method takes the update_dict as input and iterates over its key-value pairs. For each pair, it checks if the parameter node (key) is marked as trainable. If the node is trainable, it updates the node's internal data (_data) with the new data provided in the dictionary.\n\nThe step function is integral to the optimization process, as it ensures that the parameters are updated based on the latest feedback. It relies on the propose method to generate the necessary updates and the update method to apply these updates to the parameters.\n\n**Note**:\n- The propose method must be correctly implemented to generate a valid update_dict.\n- The update method will only modify the parameters that are marked as trainable.\n- The step function is designed to be flexible, accepting any number of positional and keyword arguments, which are passed through to the propose method."
      ],
      "code_start_line": 45,
      "code_end_line": 47,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def step(self, *args, **kwargs):\n        update_dict = self.propose(*args, **kwargs)\n        self.update(update_dict)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py"
      ],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/Optimizer/propose",
        "opto\\optimizers\\optimizers.py/Optimizer/update"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "propose",
      "md_content": [
        "**propose**: The function of propose is to propose the new data of the parameters based on the feedback.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The propose function is a method within the Optimizer class designed to generate new parameter data based on feedback. It serves as a public interface for proposing updates to the parameters. The function accepts any number of positional and keyword arguments, which are then passed directly to the _step method.\n\nThe propose method internally calls the _step method, which is responsible for the actual computation of the new parameter data. The _step method is abstract and must be implemented by any subclass of the Optimizer class. This design allows for different optimization strategies to be implemented by overriding the _step method in subclasses.\n\nThe propose method is also called by the step method within the same class. The step method uses propose to generate the update dictionary, which is then applied to update the parameters.\n\n**Note**: \n- The _step method must be implemented in any subclass of the Optimizer class; otherwise, a NotImplementedError will be raised.\n- The propose method relies on the _step method to perform the actual parameter updates, making it essential to provide a correct and efficient implementation of _step in subclasses.\n- The function is designed to be flexible, accepting any number of positional and keyword arguments.\n\n**Output Example**: A possible appearance of the code's return value could be a dictionary where keys are instances of ParameterNode and values can be of any type, representing the new data for each parameter node."
      ],
      "code_start_line": 49,
      "code_end_line": 51,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def propose(self, *args, **kwargs):\n        \"\"\"Propose the new data of the parameters based on the feedback.\"\"\"\n        return self._step(*args, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\optimizers.py/Optimizer/step"
      ],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/Optimizer/_step"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "update",
      "md_content": [
        "**update**: The function of update is to update the trainable parameters given a dictionary of new data.\n\n**parameters**: The parameters of this Function.\n· update_dict: A dictionary where keys are instances of ParameterNode and values are the new data to update the parameters with.\n\n**Code Description**: The update function is designed to modify the trainable parameters of an optimizer. It takes a dictionary, update_dict, as input. The keys of this dictionary are instances of ParameterNode, and the values are the new data to be assigned to these nodes.\n\nThe function iterates over each key-value pair in the update_dict. For each pair, it checks if the ParameterNode (key) is marked as trainable. If the node is trainable, it updates the node's internal data (_data) with the new data provided in the dictionary.\n\nThis function is called by the step function within the same Optimizer class. The step function first generates an update_dict by calling the propose method and then passes this dictionary to the update function to apply the updates.\n\n**Note**: \n- Ensure that the keys in the update_dict are instances of ParameterNode.\n- Only the nodes marked as trainable will be updated.\n- This function directly modifies the internal state (_data) of the ParameterNode instances."
      ],
      "code_start_line": 53,
      "code_end_line": 57,
      "params": [
        "self",
        "update_dict"
      ],
      "have_return": false,
      "code_content": "    def update(self, update_dict: Dict[ParameterNode, Any]):\n        \"\"\"Update the trainable parameters given a dictionary of new data.\"\"\"\n        for p, d in update_dict.items():\n            if p.trainable:\n                p._data = d\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\optimizers.py/Optimizer/step"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "zero_feedback",
      "md_content": [
        "**zero_feedback**: The function of zero_feedback is to reset the feedback values of all parameters managed by the optimizer to zero.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The zero_feedback function iterates over all the parameters contained within the optimizer instance and calls the zero_feedback method on each parameter. This effectively resets any feedback-related values or states associated with the parameters to zero. This function is crucial in scenarios where feedback mechanisms are used to adjust parameters during optimization, and there is a need to reset these adjustments, possibly at the beginning of a new optimization cycle or after a certain number of iterations.\n\nThe function is called within the context of unit tests located in tests\\unit_tests\\test_optimizer.py, indicating its importance in ensuring that the feedback resetting mechanism works correctly. This is essential for maintaining the integrity and expected behavior of the optimizer during its operation.\n\n**Note**: \n- Ensure that each parameter object within the optimizer has a zero_feedback method implemented; otherwise, this function will raise an AttributeError.\n- This function should be used when there is a need to clear feedback states, typically before starting a new optimization phase or after specific intervals to maintain the stability and performance of the optimization process."
      ],
      "code_start_line": 59,
      "code_end_line": 61,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def zero_feedback(self):\n        for p in self.parameters:\n            p.zero_feedback()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_step",
      "md_content": [
        "**_step**: The function of _step is to return the new data of parameter nodes based on the feedback.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The _step function is designed to be a core method within an optimizer class, responsible for updating the data of parameter nodes based on feedback. This function is abstract and raises a NotImplementedError, indicating that any subclass must provide an implementation for this method. The return type of the function is a dictionary where keys are instances of ParameterNode and values can be of any type.\n\nThe _step function is called by the propose method within the same class. The propose method serves as a public interface to generate new parameter data based on feedback, and it delegates the actual computation to the _step method. This design allows for flexibility and extensibility, as different optimization strategies can be implemented by overriding the _step method in subclasses.\n\nThe ParameterNode class, which is referenced in the return type, represents a trainable node in a computational graph. It inherits from a generic Node class and includes additional attributes such as name, trainable status, description, constraint, and info. The ParameterNode class also maintains a set of dependencies, specifically adding itself to a 'parameter' dependency set.\n\n**Note**: \n- The _step function must be implemented in any subclass of the optimizer class; otherwise, a NotImplementedError will be raised.\n- The function is designed to be flexible, accepting any number of positional and keyword arguments.\n- The propose method relies on _step to perform the actual parameter updates, making it essential to provide a correct and efficient implementation of _step in subclasses."
      ],
      "code_start_line": 64,
      "code_end_line": 66,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def _step(self, *args, **kwargs) -> Dict[ParameterNode, Any]:\n        \"\"\"Return the new data of parameter nodes based on the feedback.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\optimizers.py/Optimizer/propose"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "default_propagator",
      "md_content": [
        "**default_propagator**: The function of default_propagator is to return the default Propagator object of the optimizer.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The default_propagator function is designed to return the default Propagator object associated with the optimizer. However, in its current implementation, it raises a NotImplementedError. This indicates that the function is intended to be overridden in a subclass, where the actual logic for returning a default Propagator will be provided. The function is called within the __init__ method of the Optimizer class. During the initialization of an Optimizer object, if no Propagator is explicitly provided, the default_propagator function is invoked to obtain a default Propagator. The returned Propagator is then assigned to the _propagator attribute of the Optimizer instance. This ensures that the Optimizer always has a valid Propagator, either provided explicitly or obtained through the default_propagator method.\n\n**Note**: When implementing a subclass of the Optimizer, it is essential to override the default_propagator method to provide a concrete implementation that returns a valid Propagator object. Failure to do so will result in a NotImplementedError being raised during the initialization of the Optimizer if no Propagator is provided."
      ],
      "code_start_line": 68,
      "code_end_line": 70,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def default_propagator(self):\n        \"\"\"Return the default Propagator object of the optimizer.\"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\optimizers.py/Optimizer/__init__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "backward",
      "md_content": [
        "**backward**: The function of backward is to perform a backward pass in the optimization process. It propagates feedback from a node to its parents by calling the propagator function and updating the feedback values. \n\n**parameters**:\n- node: The node from which the feedback is propagated.\n- *args: Additional positional arguments that can be passed to the node's backward method.\n- **kwargs: Additional keyword arguments that can be passed to the node's backward method.\n\n**Code Description**: The backward function is responsible for propagating feedback from a node to its parents in the optimization process. It first checks if a propagator function is provided, and if not, it imports the GraphPropagator class from the opto.trace.propagators.graph_propagator module. \n\nThe function then adds the feedback from the node to a feedback dictionary using the _add_feedback method of the node. The feedback is obtained by calling the propagator function with the node as an argument. The feedback dictionary is used to store the feedback from each child node, where each key is a child node and the value is a list of feedbacks from that child.\n\nAfter adding the feedback, the function iterates over the parents of the node and propagates the feedback to each parent. If a parent is present in the propagated feedback dictionary, the feedback is added to the parent using the _add_feedback method. \n\nThe function also supports visualization of the propagation process by creating a graph using the graphviz library. The graph is created in reverse order if the reverse_plot parameter is set to True. \n\nFinally, the function sets the _backwarded attribute of the node to True, indicating that the backward pass has been performed. The value of the retain_graph parameter determines whether the feedback should be retained or zeroed out after propagation.\n\n**Note**: It is important to ensure that the propagator function is correctly initialized before calling the backward function. The function relies on the propagator to perform the feedback propagation. If the propagator is not provided or initialized correctly, the backward pass may not function as expected.\n\n**Output Example**: The backward function returns a graph (digraph) object if the visualize parameter is set to True. Otherwise, it returns None."
      ],
      "code_start_line": 72,
      "code_end_line": 74,
      "params": [
        "self",
        "node"
      ],
      "have_return": true,
      "code_content": "    def backward(self, node: Node, *args, **kwargs):\n        \"\"\"Propagate the feedback backward.\"\"\"\n        return node.backward(*args, propagator=self.propagator, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\optimizers\\optimizers.py/Optimizer/propagator",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        true
      ]
    }
  ],
  "opto\\optimizers\\__init__.py": [],
  "opto\\trace\\broadcast.py": [
    {
      "type": "FunctionDef",
      "name": "apply_op",
      "md_content": [
        "**apply_op**: The function of apply_op is to perform a broadcasting operation that applies a given operator to a container of Nodes.\n\n**parameters**:\n- op (callable): The operator to be applied.\n- output (Any): The container to be updated.\n- *args (Any): The positional inputs of the operator.\n- **kwargs (Any): The keyword inputs of the operator.\n\n**Code Description**:\nThe apply_op function takes an operator (op), an output container, and positional and keyword inputs. It first combines the positional and keyword inputs into a single list called \"inputs\". It then checks if there are any containers in the inputs list. If there are no containers, indicating that all inputs are Nodes, the function simply applies the operator to the inputs and returns the result.\n\nIf there is at least one container in the inputs list, the function performs the broadcasting operation. It iterates over the output container and applies the operator recursively to each element of the output container, along with the corresponding elements from the positional and keyword inputs. The result of each recursive call is assigned back to the corresponding element in the output container.\n\nThe function handles different types of output containers:\n- If the output is a list or tuple, the function checks that the output and inputs have the same length. It then applies the operator to each element of the output container, along with the corresponding elements from the positional and keyword inputs.\n- If the output is a dictionary, the function iterates over the key-value pairs of the output and applies the operator to each value, along with the corresponding elements from the positional and keyword inputs.\n- If the output is an instance of the NodeContainer class, the function iterates over the attributes of the output and applies the operator to each attribute, along with the corresponding elements from the positional and keyword inputs.\n\nThe apply_op function ensures that all inputs are either Nodes or have the same type as the output. It raises an assertion error if this condition is not met.\n\n**Note**:\n- The apply_op function relies on the NodeContainer class to identify containers of Nodes and apply the operator recursively to each attribute of the container.\n- The function supports broadcasting operations on different types of output containers, including lists, tuples, dictionaries, and instances of the NodeContainer class.\n- It is important to ensure that the inputs and output are compatible in terms of length and type to avoid errors during the broadcasting operation.\n\n**Output Example**:\nThe updated output container after applying the operator to the inputs."
      ],
      "code_start_line": 6,
      "code_end_line": 54,
      "params": [
        "op",
        "output"
      ],
      "have_return": true,
      "code_content": "def apply_op(op, output, *args, **kwargs):\n    \"\"\"A broadcasting operation that applies an op to container of Nodes.\n\n    Args:\n        op (callable): the operator to be applied.\n        output (Any): the container to be updated.\n        *args (Any): the positional inputs of the operator.\n        **kwargs (Any): the keyword inputs of the operator.\n    \"\"\"\n\n    inputs = list(args) + list(kwargs.values())\n    containers = [x for x in inputs if not isinstance(x, Node)]\n    if len(containers) == 0:  # all inputs are Nodes, we just apply op\n        return op(*args, **kwargs)\n\n    # # there is at least one container\n    # output = copy.deepcopy(containers[0])  # this would be used as the template of the output\n\n    def admissible_type(x, base):\n        return type(x) == type(base) or isinstance(x, Node)\n\n    assert all(admissible_type(x, output) for x in inputs)  # All inputs are either Nodes or the same type as output\n\n    if isinstance(output, list) or isinstance(output, tuple):\n        assert all(\n            isinstance(x, Node) or len(output) == len(x) for x in inputs\n        ), f\"output {output} and inputs {inputs} are of different lengths.\"\n        for k in range(len(output)):\n            _args = [x if isinstance(x, Node) else x[k] for x in args]\n            _kwargs = {kk: vv if isinstance(vv, Node) else vv[k] for kk, vv in kwargs.items()}\n            output[k] = apply_op(op, output[k], *_args, **_kwargs)\n        if isinstance(output, tuple):\n            output = tuple(output)\n\n    elif isinstance(output, dict):\n        for k, v in output.items():\n            _args = [x if isinstance(x, Node) else x[k] for x in args]\n            _kwargs = {kk: vv if isinstance(vv, Node) else vv[k] for kk, vv in kwargs.items()}\n            output[k] = apply_op(op, output[k], *_args, **_kwargs)\n\n    elif isinstance(output, NodeContainer):  # this is a NodeContainer object instance\n        for k, v in output.__dict__.items():\n            _args = [x if isinstance(x, Node) else getattr(x, k) for x in args]\n            _kwargs = {kk: vv if isinstance(v, Node) else getattr(vv, k) for kk, vv in kwargs.items()}\n            new_v = apply_op(op, v, *_args, **_kwargs)\n            setattr(output, k, new_v)\n    else:\n        pass\n    return output\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "tests\\unit_tests\\test_apply_op.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/NodeContainer",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "admissible_type",
      "md_content": [
        "**admissible_type**: The function of admissible_type is to determine whether the type of an object is admissible for a given base type or if it is an instance of the Node class.\n\n**parameters**:\n- x: The object whose type needs to be checked.\n- base: The base type against which the object's type is compared.\n\n**Code Description**:\nThe admissible_type function takes two parameters, x and base, and returns a boolean value indicating whether the type of x is equal to the type of base or if x is an instance of the Node class.\n\nThe function first checks if the type of x is equal to the type of base using the \"type\" function. If the types are equal, it returns True.\n\nIf the types are not equal, the function uses the \"isinstance\" function to check if x is an instance of the Node class. If x is an instance of Node, it returns True. Otherwise, it returns False.\n\nThis function is useful when you want to check if an object's type is admissible for a specific base type or if it is an instance of a specific class.\n\n**Note**:\n- The function assumes that the Node class is defined and imported correctly.\n- The function only checks for exact type equality, not inheritance relationships.\n\n**Output Example**:\n- admissible_type(5, int) returns True\n- admissible_type(\"hello\", str) returns True\n- admissible_type(5, str) returns False\n- admissible_type(Node(), Node) returns True"
      ],
      "code_start_line": 24,
      "code_end_line": 25,
      "params": [
        "x",
        "base"
      ],
      "have_return": true,
      "code_content": "    def admissible_type(x, base):\n        return type(x) == type(base) or isinstance(x, Node)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    }
  ],
  "opto\\trace\\bundle.py": [
    {
      "type": "FunctionDef",
      "name": "bundle",
      "md_content": [
        "**bundle**: The function of bundle is to wrap a function as a FunModule, which returns node objects.\n\n**parameters**:\n- description: A string that describes the function.\n- n_outputs: An integer that specifies the number of outputs the wrapped function should have.\n- node_dict: Either \"auto\" or a dictionary that maps input names to node objects.\n- traceable_code: A boolean value indicating whether the code should be traced using nodes.\n- wrap_output: A boolean value indicating whether the output should be wrapped as a node object.\n- unpack_input: A boolean value indicating whether the input should be unpacked.\n- trainable: A boolean value indicating whether the wrapped function is trainable.\n- catch_execution_error: A boolean value indicating whether execution errors should be caught.\n- allow_external_dependencies: A boolean value indicating whether external dependencies are allowed.\n- overwrite_python_recursion: A boolean value indicating whether Python recursion should be overwritten.\n\n**Code Description**: The bundle function is a decorator that wraps a function as a FunModule. It takes in various parameters to customize the behavior of the wrapped function. Inside the decorator, it creates a FunModule object with the specified parameters and returns it.\n\nThe decorator function also captures the locals of the calling function using the inspect module. This allows the wrapped function to access the locals of the calling function.\n\nThe wrapped function can be called with the same input signature as the original function. The output of the wrapped function is a node object, which represents the result of the function computation. The node object can be used in further computations or as inputs to other functions.\n\nThe bundle function provides flexibility in customizing the behavior of the wrapped function. It allows specifying the number of outputs, mapping input names to node objects, tracing the code using nodes, wrapping the output as a node object, unpacking the input, making the wrapped function trainable, catching execution errors, allowing external dependencies, and overwriting Python recursion.\n\n**Note**: \n- The wrapped function should have a consistent input signature.\n- The wrapped function can access the locals of the calling function.\n- The output of the wrapped function is a node object.\n- The behavior of the wrapped function can be customized using the parameters of the bundle function.\n\n**Output Example**: \n```python\n@bundle(description=\"This is a bundled function\", n_outputs=2)\ndef add(a, b):\n    return a + b, a - b\n\noutput = add(3, 2)\nprint(output)\n# Output: (5, 1)\n```"
      ],
      "code_start_line": 18,
      "code_end_line": 51,
      "params": [
        "description",
        "n_outputs",
        "node_dict",
        "traceable_code",
        "wrap_output",
        "unpack_input",
        "trainable",
        "catch_execution_error",
        "allow_external_dependencies",
        "overwrite_python_recursion"
      ],
      "have_return": true,
      "code_content": "def bundle(\n    description=None,\n    n_outputs=1,\n    node_dict=\"auto\",\n    traceable_code=False,\n    wrap_output=True,\n    unpack_input=True,\n    trainable=False,\n    catch_execution_error=True,\n    allow_external_dependencies=False,\n    overwrite_python_recursion=True,\n):\n    \"\"\"\n    Wrap a function as a FunModule, which returns node objects.\n    The input signature to the wrapped function stays the same.\n    \"\"\"\n    prev_f_locals = inspect.stack()[1].frame.f_locals\n    def decorator(fun):\n        fun_module= FunModule(\n            fun=fun,\n            description=description,\n            n_outputs=n_outputs,\n            node_dict=node_dict,\n            traceable_code=traceable_code,\n            wrap_output=wrap_output,\n            unpack_input=unpack_input,\n            trainable=trainable,\n            catch_execution_error=catch_execution_error,\n            allow_external_dependencies=allow_external_dependencies,\n            overwrite_python_recursion=overwrite_python_recursion,\n            ldict=prev_f_locals,  # Get the locals of the calling function\n        )\n        return fun_module\n    return decorator\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "opto\\trace\\containers.py",
        "opto\\trace\\operators.py",
        "tests\\unit_tests\\not_covered_usage_cases.py",
        "tests\\unit_tests\\test_backward.py",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_containers.py",
        "tests\\unit_tests\\test_error_handling.py",
        "tests\\unit_tests\\test_modules.py",
        "tests\\unit_tests\\test_modules.py/BaseModule",
        "tests\\unit_tests\\test_modules.py/ChildModule/__init__",
        "tests\\unit_tests\\test_modules.py/ChildModule",
        "tests\\unit_tests\\test_modules.py/BaseClass",
        "tests\\unit_tests\\test_modules.py/ChildClass/__init__",
        "tests\\unit_tests\\test_modules.py/ChildClass",
        "tests\\unit_tests\\test_optimizer.py",
        "tests\\unit_tests\\test_python_funcs.py",
        "tests\\unit_tests\\test_randomness.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "decorator",
      "md_content": [
        "**decorator**: The decorator function is used to trace a given function and return a FunModule object.\n\n**parameters**:\n- fun (callable): The function to be traced.\n- description (str): A description of the operator.\n- n_outputs (int): The number of outputs of the operator.\n- node_dict (dict|str): A dictionary to describe the inputs.\n- traceable_code (bool): Indicates if the code block is already traceable.\n- wrap_output (bool): Indicates if the output of the operator should be wrapped as a MessageNode.\n- unpack_input (bool): Indicates if the input should be extracted from the container of nodes.\n- trainable (bool): Indicates if the block of code is treated as a variable in the optimization.\n- catch_execution_error (bool): Indicates if the operator catches the exception raised during execution.\n- allow_external_dependencies (bool): Indicates if the operator allows external dependencies to be used.\n- overwrite_python_recursion (bool): Indicates if the operator allows the python recursion behavior to be overwritten.\n- ldict (dict): The local dictionary to execute the code block.\n\n**Code Description**:\nThe decorator function is used to trace a given function. It creates a FunModule object with the provided parameters and returns it. The FunModule object is responsible for executing the wrapped function and tracing the nodes used in the operator.\n\nThe decorator function first initializes a FunModule object with the provided parameters. It validates the input parameters and constructs the info dictionary, which contains information about the function being traced. The description of the operator is generated based on the function name and docstring.\n\nNext, the decorator function calls the forward method of the FunModule object to execute the wrapped function and trace the nodes used in the operator. It uses the trace_nodes context manager to capture the nodes used in the operator. The inputs of the MessageNode are constructed based on the function inputs or the set of used_nodes. External dependencies are identified and stored in the info dictionary.\n\nFinally, the decorator function calls the wrap method of the FunModule object to wrap the output as a MessageNode or an ExceptionNode, depending on the output type. If the output is None, it returns a MessageNode with a None value. If the output is an Exception, it raises an ExecutionError with an ExceptionNode. Otherwise, it wraps the output as a MessageNode with the provided inputs and external dependencies.\n\n**Note**:\n- The decorator function is used to trace a given function and return a FunModule object.\n- The FunModule object is responsible for executing the wrapped function and tracing the nodes used in the operator.\n- The decorator function takes in various parameters to customize the behavior of the FunModule object.\n- The decorator function uses the trace_nodes context manager to capture the nodes used in the operator.\n- The decorator function wraps the output as a MessageNode or an ExceptionNode.\n\n**Output Example**:\n```python\n@decorator\ndef my_function(x):\n    return x * 2\n\nresult = my_function(5)\nprint(result)  # Output: MessageNode(10)\n```"
      ],
      "code_start_line": 35,
      "code_end_line": 50,
      "params": [
        "fun"
      ],
      "have_return": true,
      "code_content": "    def decorator(fun):\n        fun_module= FunModule(\n            fun=fun,\n            description=description,\n            n_outputs=n_outputs,\n            node_dict=node_dict,\n            traceable_code=traceable_code,\n            wrap_output=wrap_output,\n            unpack_input=unpack_input,\n            trainable=trainable,\n            catch_execution_error=catch_execution_error,\n            allow_external_dependencies=allow_external_dependencies,\n            overwrite_python_recursion=overwrite_python_recursion,\n            ldict=prev_f_locals,  # Get the locals of the calling function\n        )\n        return fun_module\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/FunModule"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "trace_nodes",
      "md_content": [
        "**trace_nodes**: The function of trace_nodes is to act as a context manager for tracking which nodes are read or used in an operator.\n\n**attributes**: The attributes of this Class.\n· No explicit attributes are defined within this class.\n\n**Code Description**: The trace_nodes class is designed to manage the tracking of nodes that are accessed during the execution of an operator. It achieves this by leveraging Python's context management protocol, which includes the `__enter__` and `__exit__` methods.\n\n- The `__enter__` method initializes a new set to store the nodes that will be used and appends this set to the global `USED_NODES` list. It then returns this set, allowing it to be used within the context.\n- The `__exit__` method is called when the context is exited. It removes the set of used nodes from the global `USED_NODES` list, ensuring that the tracking is properly cleaned up.\n\nIn the context of its usage within the `forward` method of the `FunModule` class, the trace_nodes context manager is used to keep track of all nodes that are accessed during the execution of the operator function (`self.fun`). When the `forward` method is called, it enters the trace_nodes context, which starts tracking the nodes. After the function execution, the context is exited, and the set of used nodes is then available for further processing.\n\nThe `forward` method uses this set of nodes to construct the inputs of a `MessageNode` from the function inputs or the set of used nodes. It also identifies any external dependencies, which are nodes used to create the outputs but not included in the inputs. If external dependencies are not allowed and are detected, an exception is raised.\n\n**Note**: \n- Ensure that the global `USED_NODES` list is properly managed to avoid any unintended side effects.\n- The trace_nodes context manager should be used within a controlled environment where the global state can be safely modified and restored.\n\n**Output Example**: \nWhen used within the `forward` method of the `FunModule` class, the trace_nodes context manager might return a set of nodes that were accessed during the function execution. For example:\n```\nwith trace_nodes() as used_nodes:\n    # Function execution that accesses nodes\n    pass\n# used_nodes might contain: {Node1, Node2, Node3}\n```"
      ],
      "code_start_line": 54,
      "code_end_line": 63,
      "params": [],
      "have_return": true,
      "code_content": "class trace_nodes:\n    \"\"\"This is a context manager for keeping track which nodes are read/used in an operator.\"\"\"\n\n    def __enter__(self):\n        nodes = set()\n        USED_NODES.append(nodes)\n        return nodes\n\n    def __exit__(self, type, value, traceback):\n        USED_NODES.pop()\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/forward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__enter__",
      "md_content": [
        "**__enter__**: The function of __enter__ is to initialize and return a new set of nodes, and to append this set to the global list USED_NODES.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class in which this method is defined.\n\n**Code Description**: The __enter__ method is a special method used in the context management protocol. When an instance of the class containing this method is used in a with statement, the __enter__ method is automatically invoked at the beginning of the block. In this implementation, the method performs the following actions:\n1. Initializes an empty set named `nodes`.\n2. Appends this set to the global list `USED_NODES`.\n3. Returns the set `nodes`.\n\nThis allows the set of nodes to be used within the with block and ensures that it is tracked in the global `USED_NODES` list.\n\n**Note**: \n- Ensure that the global list `USED_NODES` is defined before using this method.\n- This method is typically paired with an `__exit__` method to handle cleanup actions when the with block is exited.\n\n**Output Example**: \nWhen the __enter__ method is called, it returns an empty set. For example:\n```\nwith some_instance as nodes:\n    # nodes is an empty set\n    print(nodes)  # Output: set()\n```"
      ],
      "code_start_line": 57,
      "code_end_line": 60,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __enter__(self):\n        nodes = set()\n        USED_NODES.append(nodes)\n        return nodes\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__exit__",
      "md_content": [
        "**__exit__**: The function of __exit__ is to handle the cleanup process when exiting a context managed by a with statement.\n\n**parameters**: The parameters of this Function.\n· type: The exception type, if an exception was raised.\n· value: The exception instance, if an exception was raised.\n· traceback: The traceback object, if an exception was raised.\n\n**Code Description**: The __exit__ method is a special method used in context management to define cleanup actions when exiting a context. In this specific implementation, the __exit__ method removes the last element from the USED_NODES list by calling the pop() method. This indicates that the context manager is maintaining a stack of nodes, and upon exiting the context, it ensures that the most recently added node is removed from the stack. This is a common pattern in resource management where resources are pushed onto a stack when entering a context and popped off when exiting to ensure proper cleanup and resource deallocation.\n\n**Note**: \n- Ensure that the USED_NODES list is properly initialized and managed elsewhere in the code to avoid potential errors.\n- This method does not handle exceptions; it simply performs the cleanup action. If exception handling is required, it should be implemented separately."
      ],
      "code_start_line": 62,
      "code_end_line": 63,
      "params": [
        "self",
        "type",
        "value",
        "traceback"
      ],
      "have_return": false,
      "code_content": "    def __exit__(self, type, value, traceback):\n        USED_NODES.pop()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "FunModule",
      "md_content": [
        "**FunModule**: The FunModule class is a decorator used to trace a function. It wraps the provided function and returns a MessageNode as the output.\n\n**attributes**:\n- fun (callable): The operator to be traced.\n- description (str): A description of the operator; see the MessageNode for syntax.\n- n_outputs (int): The number of outputs of the operator; default is 1.\n- node_dict (dict|str): A dictionary to describe the inputs, where the key is a node used in this operator and the value is the node's name as described in the description. When node_dict is provided, all the used_nodes need to be in node_dict. Providing node_dict can give a correspondence between the inputs and the description of the operator.\n- traceable_code (bool): If True, the code block is already traceable; if False, the code block is not traceable.\n- wrap_output (bool): If True, the output of the operator is wrapped as a MessageNode; if False, the output is returned as is if the output is a Node.\n- unpack_input (bool): If True, the input is extracted from the container of nodes; if False, the inputs are passed directly to the underlying function.\n- trainable (bool): If True, the block of code is treated as a variable in the optimization.\n- catch_execution_error (bool): If True, the operator catches the exception raised during the execution of the operator and returns ExecutionError.\n- allow_external_dependencies (bool): If True, the operator allows external dependencies to be used in the operator. Namely, not all nodes used to create the output are in the inputs. In this case, the extra dependencies are stored in the info dictionary with key 'extra_dependencies'.\n- overwrite_python_recursion (bool): If True, the operator allows the python recursion behavior of calling the decorated function to be overwritten. When true, applying bundle on a recursive function would be the same as calling the function directly. When False, the Python's original recursion behavior of decorated functions is preserved.\n- ldict (dict): The local dictionary to execute the code block.\n\n**Code Description**: \nThe FunModule class is a decorator that can be used to trace a function. It takes in various parameters to customize the behavior of the decorator. The wrapped function is executed within the decorator, and the output is returned as a MessageNode.\n\nThe constructor of the FunModule class initializes the object with the provided parameters. It validates the input parameters and constructs the info dictionary, which contains information about the function being traced. The description of the operator is generated based on the function name and docstring.\n\nThe filter_global_namespaces method filters out global namespaces that already exist in the current global namespace.\n\nThe fun property returns the wrapped function. If the function is trainable, it creates a new op eval and sets the code parameter as the parent.\n\nThe name property returns the name of the operator, which is derived from the description.\n\nThe forward method is responsible for executing the wrapped function and tracing the nodes used in the operator. It uses the trace_nodes context manager to capture the nodes used in the operator. The inputs of the MessageNode are constructed based on the function inputs or the set of used_nodes. External dependencies are identified and stored in the info dictionary.\n\nThe wrap method wraps the output as a MessageNode or an ExceptionNode, depending on the output type. If the output is None, it returns a MessageNode with a None value. If the output is an Exception, it raises an ExecutionError with an ExceptionNode. Otherwise, it wraps the output as a MessageNode with the provided inputs and external dependencies.\n\nThe is_valid_output method checks if the output is a valid Node or a tuple of Nodes.\n\nThe __get__ method supports instance methods by returning a partial function that calls the forward method with the provided arguments.\n\n**Note**: \n- The FunModule class is a decorator used to trace a function and return a MessageNode as the output.\n- The wrapped function can be accessed using the fun property.\n- The forward method executes the wrapped function and traces the nodes used in the operator.\n- The wrap method wraps the output as a MessageNode or an ExceptionNode.\n- The is_valid_output method checks if the output is a valid Node.\n- The __get__ method supports instance methods.\n\n**Output Example**:\n```python\n@FunModule\ndef my_function(x):\n    return x * 2\n\nresult = my_function(5)\nprint(result)  # Output: MessageNode(10)\n```"
      ],
      "code_start_line": 66,
      "code_end_line": 368,
      "params": [],
      "have_return": true,
      "code_content": "class FunModule(Module):\n    \"\"\"This is a decorator to trace a function. The wrapped function returns a MessageNode.\n\n    Args:\n        fun (callable): the operator to be traced.\n        description (str): a description of the operator; see the MessageNode for syntax.\n        n_outputs (int); the number of outputs of the operator; default is 1.\n        node_dict (dict|str):\n            None : (deprecated) the inputs are represented as a list of nodes.\n            'auto': the inputs are represented as a dictionary, where the keys are the parameter names and the values are the nodes.\n            dict : a dictionary to describe the inputs, where the key is a node used in this operator and the value is the node's name as described in description ; when node_dict is provided, all the used_nodes need to be in node_dict. Providing node_dict can give a correspondence between the inputs and the description of the operator.\n        traceable_code (bool): if True, the code block is already traceable; if False, the code block is not traceable.\n        wrap_output (bool): if True, the output of the operator is wrapped as a MessageNode; if False, the output is returned as is if the output is a Node.\n        unpack_input (bool): if True, the input is extracted from the container of nodes; if False, the inputs are passed directly to the underlying function.\n        trainable (bool): if True, the block of code is treated as a variable in the optimization\n        catch_execution_error (bool): if True, the operator catches the exception raised during the execution of the operator and return ExecutionError.\n        allow_external_dependencies (bool): if True, the operator allows external dependencies to be used in the operator. Namely, not all nodes used to create the output are in the inputs. In this case, the extra dependencies are stored in the info dictionary with key 'extra_dependencies'.\n        overwrite_python_recursion (bool): if True, the operator allows the python recursion behavior of calling the decorated function to be overwritten. When true, applying bundle on a recursive function, would be the same as calling the function directly. When False, the Python's oriignal recursion behavior of decorated functions is preserved.\n        ldict (dict): the local dictionary to execute the code block.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        fun: Callable,\n        description: str = None,\n        n_outputs: int = 1,\n        node_dict: Union[dict, None, str] = \"auto\",\n        traceable_code: bool = False,\n        wrap_output: bool = True,\n        unpack_input: bool = True,\n        trainable=False,\n        catch_execution_error=True,\n        allow_external_dependencies=False,\n        overwrite_python_recursion=True,\n        ldict=None,\n    ):\n\n        assert ldict is None or isinstance(ldict, dict), \"ldict must be a dictionary. or None\"\n        self.ldict = {} if ldict is None else ldict.copy()\n\n        if traceable_code:\n            # if the code is traceable, we don't need to unpack the input and there may be new nodes created in the code block.\n            unpack_input = False\n            allow_external_dependencies = True\n\n        assert callable(fun), \"fun must be a callable.\"\n        assert (\n            isinstance(node_dict, dict) or (node_dict is None) or (node_dict == \"auto\")\n        ), \"node_dict must be a dictionary or None or 'auto.\"\n\n        # Get the source code of the function, excluding the decorator line\n        source = inspect.getsource(fun)\n        if '@' == source.strip()[0]:\n            assert 'def ' in source, \"The decorator must be followed by a function definition.\"\n            # The usecase of\n            # @bundle(...)\n            # def fun(...):\n            #   ...\n            match = re.search(r\".*(def.*)\", source, re.DOTALL)\n            source = match.group(1).strip()\n        else:\n            # The inline usecase of\n            # fun = @bundle(...)fun(...)\n            #   ...\n            source = inspect.getsource(fun).strip()\n\n        # Construct the info dictionary\n        docstring = inspect.getdoc(fun)\n        self.info = dict(\n            fun_name=fun.__qualname__,\n            doc=inspect.cleandoc(docstring) if docstring is not None else \"\",\n            signature=inspect.signature(fun),\n            source=source,\n            output=None,\n            external_dependencies=None,\n            node_dict=node_dict,\n        )\n\n        if description is None:\n            # Generate the description from the function name and docstring.\n            description = f\"[{self.info['fun_name']}] {self.info['doc']}.\"\n        assert len(get_op_name(description)) > 0\n\n        self._fun = fun\n        self.node_dict = node_dict\n        self.description = description\n        if n_outputs > 1:\n            warnings.warn(\"Setting n_outputs>1 will be deprecated.\")\n        self.n_outputs = n_outputs\n        self.wrap_output = wrap_output\n        self.unpack_input = unpack_input\n        self.catch_execution_error = catch_execution_error\n        self.allow_external_dependencies = allow_external_dependencies\n        self.parameter = None\n        self.overwrite_python_recursion = overwrite_python_recursion\n        if trainable:\n            assert overwrite_python_recursion, \"trainable requires overwrite_python_recursion to be True.\"\n\n            signature_sr = re.search(r\"\\s*(def.*\\\"\\\"\\\")\", source, re.DOTALL)\n            if signature_sr is None:  # if there is no docstring just take the first line\n                signature = re.search(r\"\\s*(def.*:)\", source).group(1)\n            else:\n                signature = signature_sr.group(1)\n            self.parameter = ParameterNode(\n                self.info[\"source\"], name=\"__code\", constraint=\"The code should start with:\\n\" + signature\n            )\n\n    def filter_global_namespaces(self, keys):\n        \"\"\"\n        We don't import methods that already exist in our current global namespace\n        \"\"\"\n        filtered_keys = []\n        for k in keys:\n            if k in globals().keys():\n                continue\n            else:\n                filtered_keys.append(k)\n        return filtered_keys\n\n    @property\n    def fun(self, *args, **kwargs):\n        # This is called within trace_nodes context manager.\n        if self.parameter is None:\n            return self._fun\n        else:\n            code = self.parameter._data  # This is not traced, but we will add this as the parent later.\n            # before we execute,  we should try to import all the global name spaces from the original function\n            try:\n                ldict = {}\n                gdict = self._fun.__globals__.copy()\n                gdict.update(self.ldict)\n                exec(code, gdict, ldict)  # define the function\n                fun_name = re.search(r\"\\s*def\\s+(\\w+)\", code).group(1)\n                fun = ldict[fun_name]\n                fun.__globals__[fun_name] = fun  # for recursive calls\n\n            except (SyntaxError, NameError, KeyError, OSError) as e:\n                # Temporary fix for the issue of the code block not being able to be executed\n                e_node = ExceptionNode(\n                    e,\n                    inputs={\"code\": self.parameter},\n                    description=f\"[exception] The code parameter {self.parameter.py_name} has an error.\",\n                    name=\"exception_\" + self.parameter.py_name,\n                    info=self.info,\n                )\n                raise ExecutionError(e_node)\n            return fun\n\n    @property\n    def name(self):\n        return get_op_name(self.description)\n\n    def forward(self, *args, **kwargs):\n        \"\"\"\n        All nodes used in the operator fun are added to used_nodes during\n        the execution. If the output is not a Node, we wrap it as a\n        MessageNode, whose inputs are nodes in used_nodes.\n        \"\"\"\n\n        # _func_stack = defaultdict(list)  # stack of functions\n        _bundled_func = None\n        def tracer(frame, event, arg = None):\n            \"\"\" This tracer modifies the local/global dict of the frame, so that\n            when a recursive call of the wrapped function is made, it calls the\n            unwrapped function.\"\"\"\n            nonlocal _bundled_func\n\n            if frame.f_code == self._fun.__code__:  # entering the wrapped function\n                # Use the original function, rather than the bundled function\n                if event == 'call':  # Detect potential recursive calls\n                    if frame.f_code.co_name in frame.f_locals:\n                        # # the function is not defined globally at the top level\n                        current_fun = frame.f_locals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            update_local(frame, frame.f_code.co_name, self._fun)\n                    elif frame.f_code.co_name in frame.f_globals:\n                        current_fun = frame.f_globals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            assert isinstance(current_fun, FunModule)\n                            _bundled_func = current_fun  # save the original function\n                            frame.f_globals[frame.f_code.co_name] = self._fun\n\n                elif event == 'return':\n                    if frame.f_code.co_name in frame.f_globals:\n                        frame.f_globals[frame.f_code.co_name] = _bundled_func\n            return tracer\n\n\n        ## Execute self.fun\n        with trace_nodes() as used_nodes:\n            # After exit, used_nodes contains the nodes whose data attribute is read in the operator fun.\n            _args, _kwargs = args, kwargs\n            if self.unpack_input:  # extract data from container of nodes\n                _args = to_data(args)\n                _kwargs = to_data(kwargs)\n\n            oldtracer = sys.gettrace()\n            if self.overwrite_python_recursion and self.parameter is None:  # Overwrite the python recursion behavior\n                sys.settrace(tracer)\n            # add an except here\n            if self.catch_execution_error:\n                try:\n                    outputs = self.fun(*_args, **_kwargs)\n                except Exception as e:\n                    outputs = e\n            else:\n                outputs = self.fun(*_args, **_kwargs)\n            sys.settrace(oldtracer)\n\n        ## Construct the inputs of the MessageNode from function inputs or the set used_nodes\n        # TODO simplify this\n        if self.node_dict is None:\n            warnings.warn(\"Setting node_dict as None will be deprecated.\")\n            inputs = {n.name: n for n in used_nodes}\n\n        else:  # Otherwise we represent inputs as dict\n            assert self.node_dict == \"auto\" or isinstance(self.node_dict, dict)\n            # Get the input signature of the operator fun\n            spec = inspect.getcallargs(self.fun, *args, **kwargs)  # Read the input values from the input signature\n            if isinstance(self.node_dict, dict):\n                spec.update(self.node_dict)  # include additional nodes passed in by the user\n            assert isinstance(spec, dict)\n\n            # Construct the inputs of the MessageNode from the set used_nodes\n            inputs = {}\n            # args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann\n            _, varargs, varkw, _, _, _, _ = inspect.getfullargspec(self.fun)\n\n            def create_node(n):\n                if isinstance(n, FunModule) and n.parameter is not None:\n                    n = n.parameter\n                return node(n)\n\n            for k, v in spec.items():\n                if k == varargs:  # unpack varargs\n                    for i, n in enumerate(v):\n                        inputs[f\"args_{i}\"] = create_node(n)\n                elif k == varkw:  # unpack varkw\n                    for kk, n in v.items():\n                        inputs[kk] = create_node(n)\n                else:\n                    inputs[k] = create_node(v)\n        # Nodes used to create the outputs but not in the inputs are external dependencies.\n        external_dependencies = [node for node in used_nodes if not contain(inputs.values(), node)]\n        self.info[\"external_dependencies\"] = external_dependencies\n\n        # Make sure all nodes in used_nodes are in the parents of the returned node.\n        if len(external_dependencies) > 0 and not self.allow_external_dependencies:\n            raise TraceMissingInputsError(\n                f\"Not all nodes used in the operator {self.fun} are specified as inputs of the returned node. Missing {[node.name for node in external_dependencies]} \"\n            )\n\n        if not GRAPH.TRACE:\n            inputs = {}  # We don't need to keep track of the inputs if we are not tracing.\n        # Wrap the output as a MessageNode or an ExceptionNode\n        if self.n_outputs == 1 or isinstance(outputs, Exception):\n            nodes = self.wrap(outputs, inputs, external_dependencies)\n        else:\n            nodes = tuple(self.wrap(outputs[i], inputs, external_dependencies) for i in range(self.n_outputs))\n\n        return nodes\n\n    def wrap(self, output: Any, inputs: Union[List[Node], Dict[str, Node]], external_dependencies: List[Node]):\n        \"\"\"Wrap the output as a MessageNode of inputs as the parents.\"\"\"\n        # Some nodes are used in the operator fun, we need to wrap the output as a MessageNode.\n        if not self.wrap_output:  # TODO do we ever use this?\n            # If the output is already a Node, we don't need to wrap it.\n            # NOTE User who implements fun is responsible for the graph structure.\n            assert isinstance(output, Node)\n            return output\n        if self.parameter is not None:\n            # This is a trainiable op. Create a new op eval.\n            inputs.update({\"__code\": self.parameter})\n            description = \"[eval] This operator eval(__code, *args, **kwargs) evaluates the code block, where __code is the code (str) and *args and **kwargs are the arguments of the function. The output is the result of the evaluation, i.e., __code(*args, **kwargs).\"\n            name = \"eval\"\n            self.info[\"fun_name\"] = \"eval\"\n        else:\n            description = self.description\n            name = self.name\n        if output is None:\n            return MessageNode(None, description=self.description, inputs=inputs, name=self.name, info=self.info)\n        if isinstance(output, Exception):\n            e_node = ExceptionNode(\n                output,\n                inputs=inputs,\n                description=f'[exception] The operator {self.info[\"fun_name\"]} raises an exception.',\n                name=\"exception_\" + name,\n                info=self.info,\n            )\n            raise ExecutionError(e_node)\n        else:\n            info = self.info.copy()\n            info[\"output\"] = output  # We keep the original output node in case one needs to access the subgraph.\n            return MessageNode(output, description=description, inputs=inputs, name=name, info=info)\n\n    @staticmethod\n    def is_valid_output(output):\n        return isinstance(output, Node) or (isinstance(output, tuple) and all([isinstance(o, Node) for o in output]))\n\n    def __get__(self, obj, objtype):\n        # Support instance methods.\n        return functools.partial(self.__call__, obj)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/bundle/decorator",
        "opto\\trace\\containers.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/Module"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the FunModule class.\n\n**Parameters**:\n- self: The instance of the FunModule class.\n- fun: A callable object representing the function to be wrapped.\n- description: An optional string describing the function module.\n- n_outputs: An integer indicating the number of outputs of the function.\n- node_dict: A dictionary, None, or \"auto\" representing the node dictionary.\n- traceable_code: A boolean indicating whether the code is traceable or not.\n- wrap_output: A boolean indicating whether to wrap the output or not.\n- unpack_input: A boolean indicating whether to unpack the input or not.\n- trainable: A boolean indicating whether the function is trainable or not.\n- catch_execution_error: A boolean indicating whether to catch execution errors or not.\n- allow_external_dependencies: A boolean indicating whether to allow external dependencies or not.\n- overwrite_python_recursion: A boolean indicating whether to overwrite Python recursion or not.\n- ldict: A dictionary or None representing the local dictionary.\n\n**Code Description**: The __init__ function initializes an instance of the FunModule class. It takes in various parameters such as fun, description, n_outputs, node_dict, traceable_code, wrap_output, unpack_input, trainable, catch_execution_error, allow_external_dependencies, overwrite_python_recursion, and ldict.\n\nThe function starts by asserting that the ldict parameter is either None or a dictionary. If ldict is None, an empty dictionary is assigned to self.ldict. Otherwise, a copy of ldict is assigned to self.ldict.\n\nIf traceable_code is True, the unpack_input parameter is set to False and the allow_external_dependencies parameter is set to True. This is because when the code is traceable, there is no need to unpack the input and there may be new nodes created in the code block.\n\nThe function then asserts that the fun parameter is callable and that the node_dict parameter is either a dictionary, None, or \"auto\".\n\nNext, the source code of the function is obtained using the inspect.getsource() function. If the source code starts with a decorator line, the decorator line is removed and only the function definition is kept. Otherwise, the source code is trimmed.\n\nThe function constructs an info dictionary containing information about the function module. This includes the function name, docstring, signature, source code, output, external dependencies, and node dictionary.\n\nIf the description parameter is None, a description is generated using the function name and docstring. The get_op_name() function is called to extract the operator type from the description. The extracted operator type is combined with the function name and docstring to create a meaningful description.\n\nThe function assigns the provided parameters to the corresponding attributes of the FunModule instance. It also sets the parameter attribute to None.\n\nIf the n_outputs parameter is greater than 1, a warning message is displayed indicating that setting n_outputs>1 will be deprecated.\n\nFinally, if the trainable parameter is True, the function asserts that overwrite_python_recursion is also True. It then searches for the function signature in the source code and creates a ParameterNode object with the source code as the value and \"__code\" as the name. This ParameterNode represents the code constraint for the trainable function.\n\n**Note**: \n- The ldict parameter must be a dictionary or None.\n- The fun parameter must be a callable object.\n- The node_dict parameter must be a dictionary, None, or \"auto\".\n- The description parameter will be generated if it is None.\n- The n_outputs parameter should be used with caution as setting n_outputs>1 will be deprecated.\n- The trainable parameter requires overwrite_python_recursion to be True.\n- The source code of the function is obtained using the inspect.getsource() function.\n- The get_op_name() function is used to extract the operator type from the description.\n- The info dictionary contains information about the function module.\n- The parameter attribute is set to None unless the trainable parameter is True."
      ],
      "code_start_line": 88,
      "code_end_line": 172,
      "params": [
        "self",
        "fun",
        "description",
        "n_outputs",
        "node_dict",
        "traceable_code",
        "wrap_output",
        "unpack_input",
        "trainable",
        "catch_execution_error",
        "allow_external_dependencies",
        "overwrite_python_recursion",
        "ldict"
      ],
      "have_return": false,
      "code_content": "    def __init__(\n        self,\n        fun: Callable,\n        description: str = None,\n        n_outputs: int = 1,\n        node_dict: Union[dict, None, str] = \"auto\",\n        traceable_code: bool = False,\n        wrap_output: bool = True,\n        unpack_input: bool = True,\n        trainable=False,\n        catch_execution_error=True,\n        allow_external_dependencies=False,\n        overwrite_python_recursion=True,\n        ldict=None,\n    ):\n\n        assert ldict is None or isinstance(ldict, dict), \"ldict must be a dictionary. or None\"\n        self.ldict = {} if ldict is None else ldict.copy()\n\n        if traceable_code:\n            # if the code is traceable, we don't need to unpack the input and there may be new nodes created in the code block.\n            unpack_input = False\n            allow_external_dependencies = True\n\n        assert callable(fun), \"fun must be a callable.\"\n        assert (\n            isinstance(node_dict, dict) or (node_dict is None) or (node_dict == \"auto\")\n        ), \"node_dict must be a dictionary or None or 'auto.\"\n\n        # Get the source code of the function, excluding the decorator line\n        source = inspect.getsource(fun)\n        if '@' == source.strip()[0]:\n            assert 'def ' in source, \"The decorator must be followed by a function definition.\"\n            # The usecase of\n            # @bundle(...)\n            # def fun(...):\n            #   ...\n            match = re.search(r\".*(def.*)\", source, re.DOTALL)\n            source = match.group(1).strip()\n        else:\n            # The inline usecase of\n            # fun = @bundle(...)fun(...)\n            #   ...\n            source = inspect.getsource(fun).strip()\n\n        # Construct the info dictionary\n        docstring = inspect.getdoc(fun)\n        self.info = dict(\n            fun_name=fun.__qualname__,\n            doc=inspect.cleandoc(docstring) if docstring is not None else \"\",\n            signature=inspect.signature(fun),\n            source=source,\n            output=None,\n            external_dependencies=None,\n            node_dict=node_dict,\n        )\n\n        if description is None:\n            # Generate the description from the function name and docstring.\n            description = f\"[{self.info['fun_name']}] {self.info['doc']}.\"\n        assert len(get_op_name(description)) > 0\n\n        self._fun = fun\n        self.node_dict = node_dict\n        self.description = description\n        if n_outputs > 1:\n            warnings.warn(\"Setting n_outputs>1 will be deprecated.\")\n        self.n_outputs = n_outputs\n        self.wrap_output = wrap_output\n        self.unpack_input = unpack_input\n        self.catch_execution_error = catch_execution_error\n        self.allow_external_dependencies = allow_external_dependencies\n        self.parameter = None\n        self.overwrite_python_recursion = overwrite_python_recursion\n        if trainable:\n            assert overwrite_python_recursion, \"trainable requires overwrite_python_recursion to be True.\"\n\n            signature_sr = re.search(r\"\\s*(def.*\\\"\\\"\\\")\", source, re.DOTALL)\n            if signature_sr is None:  # if there is no docstring just take the first line\n                signature = re.search(r\"\\s*(def.*:)\", source).group(1)\n            else:\n                signature = signature_sr.group(1)\n            self.parameter = ParameterNode(\n                self.info[\"source\"], name=\"__code\", constraint=\"The code should start with:\\n\" + signature\n            )\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/get_op_name",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "filter_global_namespaces",
      "md_content": [
        "**filter_global_namespaces**: The function of filter_global_namespaces is to filter out keys that already exist in the current global namespace.\n\n**parameters**: The parameters of this Function.\n· keys: A list of keys to be filtered.\n\n**Code Description**: The filter_global_namespaces function takes a list of keys as input and returns a new list containing only those keys that do not already exist in the current global namespace. The function initializes an empty list called filtered_keys to store the keys that pass the filtering criteria. It then iterates over each key in the input list. For each key, it checks if the key exists in the global namespace using the globals() function. If the key is found in the global namespace, it is skipped. Otherwise, the key is appended to the filtered_keys list. Finally, the function returns the filtered_keys list.\n\n**Note**: \n- This function relies on the current global namespace, which means its behavior can vary depending on the existing global variables and functions at the time of execution.\n- Ensure that the input list keys does not contain any unintended or sensitive keys that might be skipped due to their presence in the global namespace.\n\n**Output Example**: \nIf the global namespace contains the keys 'a' and 'b', and the input list is ['a', 'b', 'c', 'd'], the function will return ['c', 'd']."
      ],
      "code_start_line": 174,
      "code_end_line": 184,
      "params": [
        "self",
        "keys"
      ],
      "have_return": true,
      "code_content": "    def filter_global_namespaces(self, keys):\n        \"\"\"\n        We don't import methods that already exist in our current global namespace\n        \"\"\"\n        filtered_keys = []\n        for k in keys:\n            if k in globals().keys():\n                continue\n            else:\n                filtered_keys.append(k)\n        return filtered_keys\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [
        "**fun**: The function of fun is to execute dynamically generated code and return the resulting function.\n\n**parameters**:\n- self: The instance of the class.\n- *args: Variable length argument list.\n- **kwargs: Arbitrary keyword arguments.\n\n**Code Description**:\nThe `fun` function is a method of the current class. It is responsible for executing dynamically generated code and returning the resulting function. The function takes in variable length arguments (`*args`) and arbitrary keyword arguments (`**kwargs`).\n\nThe function first checks if the `parameter` attribute of the instance is `None`. If it is `None`, it returns the `_fun` attribute of the instance, which is the original function.\n\nIf the `parameter` attribute is not `None`, the function retrieves the code from the `parameter` attribute and stores it in the `code` variable. It then tries to import all the global namespaces from the original function by creating a local dictionary (`ldict`) and copying the global dictionary (`gdict`) from the `_fun` attribute. The local dictionary is updated with the `ldict` attribute of the instance. The `exec` function is then called to define the function using the code, the global dictionary, and the local dictionary. The name of the function is extracted from the code using regular expression. The resulting function is stored in the `fun` variable.\n\nIf there is an exception during the execution of the code (SyntaxError, NameError, KeyError, or OSError), an `ExecutionError` instance is created with details about the exception. The `ExecutionError` instance is then raised to indicate the error.\n\nFinally, the function returns the resulting function (`fun`).\n\n**Note**:\n- The `fun` function is used within the `trace_nodes` context manager.\n- The `fun` function relies on the `parameter` attribute to retrieve the dynamically generated code.\n- The resulting function may be different from the original function if the code modifies the global namespaces.\n\n**Output Example**:\nThe output of the `fun` function is the resulting function that is executed from the dynamically generated code."
      ],
      "code_start_line": 187,
      "code_end_line": 213,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def fun(self, *args, **kwargs):\n        # This is called within trace_nodes context manager.\n        if self.parameter is None:\n            return self._fun\n        else:\n            code = self.parameter._data  # This is not traced, but we will add this as the parent later.\n            # before we execute,  we should try to import all the global name spaces from the original function\n            try:\n                ldict = {}\n                gdict = self._fun.__globals__.copy()\n                gdict.update(self.ldict)\n                exec(code, gdict, ldict)  # define the function\n                fun_name = re.search(r\"\\s*def\\s+(\\w+)\", code).group(1)\n                fun = ldict[fun_name]\n                fun.__globals__[fun_name] = fun  # for recursive calls\n\n            except (SyntaxError, NameError, KeyError, OSError) as e:\n                # Temporary fix for the issue of the code block not being able to be executed\n                e_node = ExceptionNode(\n                    e,\n                    inputs={\"code\": self.parameter},\n                    description=f\"[exception] The code parameter {self.parameter.py_name} has an error.\",\n                    name=\"exception_\" + self.parameter.py_name,\n                    info=self.info,\n                )\n                raise ExecutionError(e_node)\n            return fun\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/forward"
      ],
      "reference_who": [
        "opto\\trace\\errors.py/ExecutionError",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/ExceptionNode"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "name",
      "md_content": [
        "**name**: The function of `name` is to retrieve the operator type from the description attribute of the FunModule instance.\n\n**parameters**: This method does not take any parameters other than `self`.\n\n**Code Description**: The `name` method is a member of the `FunModule` class in the `bundle.py` file. It is designed to extract and return the operator type from the `description` attribute of the `FunModule` instance. This is achieved by calling the `get_op_name` function, which processes the `description` string to find and return the operator type enclosed in square brackets at the beginning of the description.\n\nThe `get_op_name` function uses a regular expression to search for the operator type. If the operator type is found, it is returned; otherwise, a `ValueError` is raised. This ensures that the `description` attribute of the `FunModule` instance is correctly formatted and contains the necessary operator type information.\n\nThe `name` method is utilized within the `wrap` method of the same class. In the `wrap` method, the `name` method is used to set the `name` attribute of the `MessageNode` or `ExceptionNode` that is created based on the output of the function. This ensures that the nodes have a meaningful and accurate name that reflects the operator type.\n\n**Note**: \n- The `description` attribute of the `FunModule` instance must contain the operator type enclosed in square brackets at the beginning.\n- If the `description` does not contain the operator type, a `ValueError` will be raised by the `get_op_name` function.\n\n**Output Example**: \nIf the `description` attribute of the `FunModule` instance is \"[Add] Add two numbers\", the `name` method will return \"Add\"."
      ],
      "code_start_line": 216,
      "code_end_line": 217,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def name(self):\n        return get_op_name(self.description)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/wrap"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/get_op_name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [
        "**forward**: The `forward` function is responsible for executing the operator function (`self.fun`) and returning the resulting nodes. It takes in variable length arguments (`*args`) and arbitrary keyword arguments (`**kwargs`).\n\n**parameters**:\n- `self`: The instance of the class.\n- `*args`: Variable length argument list.\n- `**kwargs`: Arbitrary keyword arguments.\n\n**Code Description**:\nThe `forward` function is a method of the `FunModule` class in the `bundle.py` file. It is the main function that executes the operator function and handles the processing of inputs and outputs. \n\nThe function starts by initializing the `_args` and `_kwargs` variables with the provided arguments (`args` and `kwargs`). If the `unpack_input` attribute of the instance is `True`, the function extracts the data from the container of nodes by calling the `to_data` function on the arguments.\n\nNext, the function checks if the `overwrite_python_recursion` attribute is `True` and the `parameter` attribute is `None`. If both conditions are met, it sets the Python tracer to the `tracer` function defined within the `forward` function. This tracer modifies the local/global dictionary of the frame to ensure that recursive calls of the wrapped function call the unwrapped function.\n\nThe function then enters a `trace_nodes` context manager using the `with` statement. This context manager tracks the nodes that are read or used in the operator function. The `used_nodes` set is created and appended to the global `USED_NODES` list. This set will contain the nodes that are accessed during the execution of the operator function.\n\nWithin the context manager, the operator function (`self.fun`) is executed with the provided arguments (`_args` and `_kwargs`). If the `catch_execution_error` attribute is `True`, the function wraps the execution of the operator function in a try-except block. If an exception occurs during the execution, it is stored in the `outputs` variable. Otherwise, the `outputs` variable contains the result of the operator function.\n\nAfter the execution of the operator function, the context manager is exited, and the set of used nodes is available for further processing.\n\nThe function then constructs the inputs of the `MessageNode` from the function inputs or the set of used nodes. If the `node_dict` attribute of the instance is `None`, the function generates a warning and creates a dictionary of inputs using the names of the nodes in the `used_nodes` set. If the `node_dict` attribute is not `None`, the function updates the input signature (`spec`) with the `node_dict` dictionary. It then iterates over the input signature and creates nodes for each input value using the `create_node` function. The resulting inputs dictionary is stored in the `inputs` variable.\n\nNext, the function identifies any external dependencies, which are nodes used to create the outputs but not included in the inputs. It creates a list of external dependencies by iterating over the `used_nodes` set and checking if each node is present in the `inputs` dictionary using the `contain` function.\n\nIf the number of external dependencies is greater than 0 and the `allow_external_dependencies` attribute is `False`, the function raises a `TraceMissingInputsError` exception. This exception indicates that not all nodes used in the operator function are specified as inputs of the returned node.\n\nIf the `GRAPH.TRACE` attribute is `False`, the `inputs` dictionary is cleared, as there is no need to keep track of the inputs if tracing is not enabled.\n\nFinally, the function wraps the output as a `MessageNode` or an `ExceptionNode` depending on the type of the output. If the `n_outputs` attribute of the instance is 1 or the output is an instance of `Exception`, the function calls the `wrap` function with the output, inputs, and external dependencies. Otherwise, it creates a tuple of wrapped nodes by calling the `wrap` function for each output element.\n\nThe function returns the resulting nodes.\n\n**Note**:\n- The `forward` function is the main function that executes the operator function and handles the processing of inputs and outputs.\n- The `trace_nodes` context manager is used to track the nodes that are accessed during the execution of the operator function.\n- The `tracer` function modifies the local/global dictionary of the frame to ensure that recursive calls of the wrapped function call the unwrapped function.\n- The `to_data` function is used to extract the data from a node or a container of nodes.\n- The `wrap` function is used to wrap the output of the operator function as a `MessageNode` or an `ExceptionNode`.\n- The `TraceMissingInputsError` exception is raised when not all nodes used in the operator function are specified as inputs of the returned node.\n- The `contain` function is used to check if a given node is present in a container of nodes.\n\n**Output Example**:\nThe `forward` function returns the resulting nodes of the operator function. The output can be a single `MessageNode` or `ExceptionNode` if the `n_outputs` attribute is 1 or the output is an exception. If the `n_outputs` attribute is greater than 1, the output is a tuple of `MessageNode` or `ExceptionNode` objects."
      ],
      "code_start_line": 219,
      "code_end_line": 327,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def forward(self, *args, **kwargs):\n        \"\"\"\n        All nodes used in the operator fun are added to used_nodes during\n        the execution. If the output is not a Node, we wrap it as a\n        MessageNode, whose inputs are nodes in used_nodes.\n        \"\"\"\n\n        # _func_stack = defaultdict(list)  # stack of functions\n        _bundled_func = None\n        def tracer(frame, event, arg = None):\n            \"\"\" This tracer modifies the local/global dict of the frame, so that\n            when a recursive call of the wrapped function is made, it calls the\n            unwrapped function.\"\"\"\n            nonlocal _bundled_func\n\n            if frame.f_code == self._fun.__code__:  # entering the wrapped function\n                # Use the original function, rather than the bundled function\n                if event == 'call':  # Detect potential recursive calls\n                    if frame.f_code.co_name in frame.f_locals:\n                        # # the function is not defined globally at the top level\n                        current_fun = frame.f_locals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            update_local(frame, frame.f_code.co_name, self._fun)\n                    elif frame.f_code.co_name in frame.f_globals:\n                        current_fun = frame.f_globals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            assert isinstance(current_fun, FunModule)\n                            _bundled_func = current_fun  # save the original function\n                            frame.f_globals[frame.f_code.co_name] = self._fun\n\n                elif event == 'return':\n                    if frame.f_code.co_name in frame.f_globals:\n                        frame.f_globals[frame.f_code.co_name] = _bundled_func\n            return tracer\n\n\n        ## Execute self.fun\n        with trace_nodes() as used_nodes:\n            # After exit, used_nodes contains the nodes whose data attribute is read in the operator fun.\n            _args, _kwargs = args, kwargs\n            if self.unpack_input:  # extract data from container of nodes\n                _args = to_data(args)\n                _kwargs = to_data(kwargs)\n\n            oldtracer = sys.gettrace()\n            if self.overwrite_python_recursion and self.parameter is None:  # Overwrite the python recursion behavior\n                sys.settrace(tracer)\n            # add an except here\n            if self.catch_execution_error:\n                try:\n                    outputs = self.fun(*_args, **_kwargs)\n                except Exception as e:\n                    outputs = e\n            else:\n                outputs = self.fun(*_args, **_kwargs)\n            sys.settrace(oldtracer)\n\n        ## Construct the inputs of the MessageNode from function inputs or the set used_nodes\n        # TODO simplify this\n        if self.node_dict is None:\n            warnings.warn(\"Setting node_dict as None will be deprecated.\")\n            inputs = {n.name: n for n in used_nodes}\n\n        else:  # Otherwise we represent inputs as dict\n            assert self.node_dict == \"auto\" or isinstance(self.node_dict, dict)\n            # Get the input signature of the operator fun\n            spec = inspect.getcallargs(self.fun, *args, **kwargs)  # Read the input values from the input signature\n            if isinstance(self.node_dict, dict):\n                spec.update(self.node_dict)  # include additional nodes passed in by the user\n            assert isinstance(spec, dict)\n\n            # Construct the inputs of the MessageNode from the set used_nodes\n            inputs = {}\n            # args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann\n            _, varargs, varkw, _, _, _, _ = inspect.getfullargspec(self.fun)\n\n            def create_node(n):\n                if isinstance(n, FunModule) and n.parameter is not None:\n                    n = n.parameter\n                return node(n)\n\n            for k, v in spec.items():\n                if k == varargs:  # unpack varargs\n                    for i, n in enumerate(v):\n                        inputs[f\"args_{i}\"] = create_node(n)\n                elif k == varkw:  # unpack varkw\n                    for kk, n in v.items():\n                        inputs[kk] = create_node(n)\n                else:\n                    inputs[k] = create_node(v)\n        # Nodes used to create the outputs but not in the inputs are external dependencies.\n        external_dependencies = [node for node in used_nodes if not contain(inputs.values(), node)]\n        self.info[\"external_dependencies\"] = external_dependencies\n\n        # Make sure all nodes in used_nodes are in the parents of the returned node.\n        if len(external_dependencies) > 0 and not self.allow_external_dependencies:\n            raise TraceMissingInputsError(\n                f\"Not all nodes used in the operator {self.fun} are specified as inputs of the returned node. Missing {[node.name for node in external_dependencies]} \"\n            )\n\n        if not GRAPH.TRACE:\n            inputs = {}  # We don't need to keep track of the inputs if we are not tracing.\n        # Wrap the output as a MessageNode or an ExceptionNode\n        if self.n_outputs == 1 or isinstance(outputs, Exception):\n            nodes = self.wrap(outputs, inputs, external_dependencies)\n        else:\n            nodes = tuple(self.wrap(outputs[i], inputs, external_dependencies) for i in range(self.n_outputs))\n\n        return nodes\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/trace_nodes",
        "opto\\trace\\bundle.py/FunModule/fun",
        "opto\\trace\\bundle.py/FunModule/wrap",
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\errors.py/TraceMissingInputsError",
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\utils.py/contain"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "tracer",
      "md_content": [
        "**tracer**: The function of tracer is to modify the local and global dictionaries of a frame to ensure that recursive calls of a wrapped function invoke the unwrapped function.\n\n**parameters**: The parameters of this Function.\n· frame: The frame object representing the current execution context.\n· event: A string representing the type of event that occurred (e.g., 'call', 'return').\n· arg: An optional argument that may be passed to the tracer function (default is None).\n\n**Code Description**: The tracer function is designed to handle recursive calls within a wrapped function by modifying the local and global dictionaries of the frame. When the function is called, it first checks if the current frame's code object matches the code object of the wrapped function (`self._fun.__code__`). If it does, the function proceeds to handle different types of events:\n\n- **Call Event**: When the event is 'call', the function checks if the function name exists in the frame's local or global dictionaries. If the function name is found in the local dictionary and it does not match the wrapped function (`self._fun`), the `update_local` function is called to update the local variable to the wrapped function. If the function name is found in the global dictionary and it does not match the wrapped function, the original function (an instance of `FunModule`) is saved in `_bundled_func`, and the global dictionary is updated to point to the wrapped function.\n\n- **Return Event**: When the event is 'return', the function checks if the function name exists in the global dictionary. If it does, the global dictionary is restored to the original function saved in `_bundled_func`.\n\nThe `update_local` function is used within the tracer to update the local variables in the frame. This ensures that recursive calls invoke the unwrapped function, maintaining the correct function behavior.\n\n**Note**: Points to note about the use of the code\n- Ensure that the frame object passed to the tracer function is valid and corresponds to the correct execution context.\n- Be cautious when modifying local and global variables in a frame, as it can affect the execution flow and state of the program.\n- The tracer function relies on the `update_local` function to update local variables, which uses the `ctypes` module to interact with the Python C API. This may have implications for portability and compatibility across different Python versions and implementations.\n\n**Output Example**: The tracer function returns itself, allowing it to be used as a callback for tracing events."
      ],
      "code_start_line": 228,
      "code_end_line": 252,
      "params": [
        "frame",
        "event",
        "arg"
      ],
      "have_return": true,
      "code_content": "        def tracer(frame, event, arg = None):\n            \"\"\" This tracer modifies the local/global dict of the frame, so that\n            when a recursive call of the wrapped function is made, it calls the\n            unwrapped function.\"\"\"\n            nonlocal _bundled_func\n\n            if frame.f_code == self._fun.__code__:  # entering the wrapped function\n                # Use the original function, rather than the bundled function\n                if event == 'call':  # Detect potential recursive calls\n                    if frame.f_code.co_name in frame.f_locals:\n                        # # the function is not defined globally at the top level\n                        current_fun = frame.f_locals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            update_local(frame, frame.f_code.co_name, self._fun)\n                    elif frame.f_code.co_name in frame.f_globals:\n                        current_fun = frame.f_globals[frame.f_code.co_name]\n                        if current_fun != self._fun:\n                            assert isinstance(current_fun, FunModule)\n                            _bundled_func = current_fun  # save the original function\n                            frame.f_globals[frame.f_code.co_name] = self._fun\n\n                elif event == 'return':\n                    if frame.f_code.co_name in frame.f_globals:\n                        frame.f_globals[frame.f_code.co_name] = _bundled_func\n            return tracer\n",
      "name_column": 12,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/update_local"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "create_node",
      "md_content": [
        "**create_node**: The function of create_node is to convert an input into a Node object, specifically handling instances of FunModule by extracting their parameters if they exist.\n\n**parameters**: The parameters of this Function.\n· n: The input to be converted into a Node. This can be an instance of FunModule or any other type that the node function can handle.\n\n**Code Description**: The create_node function is designed to facilitate the creation of Node objects from various inputs. It first checks if the input n is an instance of FunModule and whether it has a non-None parameter attribute. If both conditions are met, it assigns n to its parameter attribute. This step ensures that if n is a FunModule with a parameter, the parameter is used for the Node creation instead of the FunModule itself. After this check, the function calls the node function with n as its argument. The node function then processes n according to its own logic, which includes handling whether n is already a Node, and whether it should be trainable or have constraints.\n\n**Note**: \n- This function is particularly useful when dealing with FunModule instances, as it ensures that their parameters are used for Node creation.\n- The function relies on the node function to handle the actual creation of the Node object, including any additional parameters like name, trainable, and constraint.\n\n**Output Example**: A possible return value of the create_node function could be a Node object created from the parameter of a FunModule instance, or directly from the input if it is not a FunModule. For example, if n is a FunModule with a parameter, the return value would be a Node object created from that parameter. If n is a simple message, the return value would be a Node object created from that message."
      ],
      "code_start_line": 295,
      "code_end_line": 298,
      "params": [
        "n"
      ],
      "have_return": true,
      "code_content": "            def create_node(n):\n                if isinstance(n, FunModule) and n.parameter is not None:\n                    n = n.parameter\n                return node(n)\n",
      "name_column": 16,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "wrap",
      "md_content": [
        "**wrap**: The function of wrap is to wrap the output as a MessageNode of inputs as the parents.\n\n**parameters**:\n- output: The output of the operator function.\n- inputs: The input nodes of the MessageNode. It can be a list or a dictionary.\n- external_dependencies: A list of nodes that are used to create the outputs but not included in the inputs.\n\n**Code Description**:\nThe `wrap` function is a method of the `FunModule` class in the `bundle.py` file. It is designed to wrap the output of the operator function as a `MessageNode` with the specified inputs as its parents. The function takes three parameters: `output`, `inputs`, and `external_dependencies`.\n\nThe `wrap` function first checks if the `wrap_output` attribute of the `FunModule` instance is `False`. If it is `False`, the function returns the output as is, assuming it is already a `Node` object. This is because there is no need to wrap the output if it is already a `Node`.\n\nIf the `wrap_output` attribute is `True`, the function proceeds to check if the `parameter` attribute of the `FunModule` instance is not `None`. If it is not `None`, it means that the operator is a trainable operation and a new op eval needs to be created. In this case, the `inputs` dictionary is updated with the `__code` parameter, which is the code block of the function. The `description` and `name` variables are set accordingly to indicate that this is an eval operator. The `fun_name` attribute of the `FunModule` instance is also updated to \"eval\".\n\nIf the `parameter` attribute is `None`, the `description` and `name` variables are set to the `description` and `name` attributes of the `FunModule` instance, respectively.\n\nNext, the function checks if the `output` is `None`. If it is `None`, it creates a `MessageNode` with `None` as the value and the specified `description`, `inputs`, `name`, and `info` attributes. This is useful when the operator does not produce any output.\n\nIf the `output` is an instance of `Exception`, it creates an `ExceptionNode` with the `output` as the value and the specified `description`, `inputs`, `name`, and `info` attributes. The `ExceptionNode` represents an exception raised by the operator.\n\nIf the `output` is neither `None` nor an instance of `Exception`, it creates a copy of the `info` attribute and updates it with the `output` value. It then creates a `MessageNode` with the `output` as the value and the specified `description`, `inputs`, `name`, and updated `info` attributes.\n\nThe `wrap` function returns the created `MessageNode` or `ExceptionNode` depending on the type of the `output`.\n\n**Note**:\n- The `wrap` function is used to wrap the output of the operator function as a `MessageNode` or `ExceptionNode`.\n- The `wrap_output` attribute of the `FunModule` instance determines whether the output needs to be wrapped.\n- The `parameter` attribute of the `FunModule` instance determines whether the operator is a trainable operation.\n- The `description`, `name`, and `info` attributes of the `FunModule` instance are used to provide additional information for the created nodes.\n\n**Output Example**:\nIf the `output` is `None`, the function returns a `MessageNode` with `None` as the value:\n```\nMessageNode(None, description=\"[Node] This is a node in a computational graph.\", inputs=inputs, name=name, info=info)\n```\nIf the `output` is an exception, the function raises an `ExecutionError` with an `ExceptionNode` containing the exception details."
      ],
      "code_start_line": 329,
      "code_end_line": 360,
      "params": [
        "self",
        "output",
        "inputs",
        "external_dependencies"
      ],
      "have_return": true,
      "code_content": "    def wrap(self, output: Any, inputs: Union[List[Node], Dict[str, Node]], external_dependencies: List[Node]):\n        \"\"\"Wrap the output as a MessageNode of inputs as the parents.\"\"\"\n        # Some nodes are used in the operator fun, we need to wrap the output as a MessageNode.\n        if not self.wrap_output:  # TODO do we ever use this?\n            # If the output is already a Node, we don't need to wrap it.\n            # NOTE User who implements fun is responsible for the graph structure.\n            assert isinstance(output, Node)\n            return output\n        if self.parameter is not None:\n            # This is a trainiable op. Create a new op eval.\n            inputs.update({\"__code\": self.parameter})\n            description = \"[eval] This operator eval(__code, *args, **kwargs) evaluates the code block, where __code is the code (str) and *args and **kwargs are the arguments of the function. The output is the result of the evaluation, i.e., __code(*args, **kwargs).\"\n            name = \"eval\"\n            self.info[\"fun_name\"] = \"eval\"\n        else:\n            description = self.description\n            name = self.name\n        if output is None:\n            return MessageNode(None, description=self.description, inputs=inputs, name=self.name, info=self.info)\n        if isinstance(output, Exception):\n            e_node = ExceptionNode(\n                output,\n                inputs=inputs,\n                description=f'[exception] The operator {self.info[\"fun_name\"]} raises an exception.',\n                name=\"exception_\" + name,\n                info=self.info,\n            )\n            raise ExecutionError(e_node)\n        else:\n            info = self.info.copy()\n            info[\"output\"] = output  # We keep the original output node in case one needs to access the subgraph.\n            return MessageNode(output, description=description, inputs=inputs, name=name, info=info)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/forward"
      ],
      "reference_who": [
        "opto\\trace\\bundle.py/FunModule/name",
        "opto\\trace\\errors.py/ExecutionError",
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\nodes.py/ExceptionNode"
      ],
      "special_reference_type": [
        false,
        false,
        true,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "is_valid_output",
      "md_content": [
        "**is_valid_output**: The function of is_valid_output is to check whether the given output is a valid output for a computational graph node.\n\n**parameters**:\n- output: The output to be checked.\n\n**Code Description**:\nThe `is_valid_output` function takes an `output` as input and checks whether it is a valid output for a computational graph node. The function returns `True` if the `output` is an instance of the `Node` class or if it is a tuple containing only instances of the `Node` class. Otherwise, it returns `False`.\n\nThe function first checks if the `output` is an instance of the `Node` class using the `isinstance` function. If it is, the function returns `True`.\n\nIf the `output` is not an instance of the `Node` class, the function checks if it is a tuple using the `isinstance` function. If it is a tuple, the function uses a list comprehension and the `isinstance` function to check if all elements in the tuple are instances of the `Node` class. If all elements are instances of the `Node` class, the function returns `True`. Otherwise, it returns `False`.\n\n**Note**:\n- The `is_valid_output` function is used to validate the output of a computational graph node. It ensures that the output is compatible with the expected input types for further computations.\n- The function assumes that the `Node` class is defined and imported correctly.\n\n**Output Example**:\n- Example 1:\n    ```python\n    output = Node(5)\n    print(is_valid_output(output))\n    ```\n    Output:\n    ```\n    True\n    ```\n\n- Example 2:\n    ```python\n    output = (Node(1), Node(2), Node(3))\n    print(is_valid_output(output))\n    ```\n    Output:\n    ```\n    True\n    ```\n\n- Example 3:\n    ```python\n    output = (Node(1), 2, Node(3))\n    print(is_valid_output(output))\n    ```\n    Output:\n    ```\n    False\n    ```"
      ],
      "code_start_line": 363,
      "code_end_line": 364,
      "params": [
        "output"
      ],
      "have_return": true,
      "code_content": "    def is_valid_output(output):\n        return isinstance(output, Node) or (isinstance(output, tuple) and all([isinstance(o, Node) for o in output]))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__get__",
      "md_content": [
        "**__get__**: The function of __get__ is to support instance methods by binding the __call__ method to an instance of the Module class.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the FunModule class.\n· obj: The instance of the class where the FunModule instance is accessed as an attribute.\n· objtype: The type of the class where the FunModule instance is accessed as an attribute.\n\n**Code Description**: The __get__ method is a descriptor method used to support instance methods in the FunModule class. When an instance of FunModule is accessed as an attribute of another class instance, the __get__ method is invoked. This method uses functools.partial to bind the __call__ method of the FunModule instance to the obj parameter, which is the instance of the class where FunModule is accessed.\n\nBy doing this, the __call__ method of the FunModule instance is effectively converted into an instance method of the obj instance. This allows the __call__ method to be invoked with obj as its first argument, enabling it to operate in the context of the obj instance.\n\nIn the context of the project, the __call__ method of the FunModule class is designed to invoke the forward method of the Module class with the provided arguments. The __get__ method ensures that when the __call__ method is accessed through an instance of another class, it behaves as an instance method, maintaining the correct binding to the obj instance.\n\n**Note**: \n- The __get__ method is crucial for enabling the FunModule class to be used as a descriptor, allowing its __call__ method to be bound to instances of other classes.\n- Ensure that the obj parameter is an instance of a class that correctly utilizes the FunModule instance as an attribute.\n\n**Output Example**: The return value of the __get__ method is a functools.partial object that binds the __call__ method to the obj instance. This allows the __call__ method to be invoked as if it were an instance method of the obj instance. For example, if obj is an instance of a class that has a FunModule instance as an attribute, accessing this attribute and calling it will invoke the __call__ method with obj as its first argument."
      ],
      "code_start_line": 366,
      "code_end_line": 368,
      "params": [
        "self",
        "obj",
        "objtype"
      ],
      "have_return": true,
      "code_content": "    def __get__(self, obj, objtype):\n        # Support instance methods.\n        return functools.partial(self.__call__, obj)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/Module/__call__"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "to_data",
      "md_content": [
        "**to_data**: The function of to_data is to extract the data from a node or a container of nodes.\n\n**parameters**:\n- obj: The input object, which can be a node or a container of nodes.\n\n**Code Description**:\nThe to_data function is designed to extract the data from a node or a container of nodes. It takes an input object and recursively extracts the data from each node in the object. The function handles different types of objects and performs specific operations based on their type.\n\nFor node containers (tuple, list, dict, set, NodeContainer), the function recursively extracts the data from each node in the container. It uses list comprehension or dictionary comprehension to iterate over the nodes and call the to_data function recursively on each node.\n\nFor individual nodes (instances of the Node class), the function simply returns the data attribute of the node.\n\nIf the input object is an instance of NodeContainer, the function creates a copy of the object and iterates over its attributes using the __dict__ attribute. It then sets the corresponding attribute in the output object to the result of calling the to_data function recursively on the attribute value.\n\nIf the input object is not a node or a node container, the function simply returns the object as is.\n\n**Note**:\n- The function relies on the isinstance() function to determine the type of the input object and perform the appropriate operations.\n- The function uses the copy module to create a copy of the NodeContainer object.\n- The function assumes that the Node and NodeContainer classes are defined and imported correctly.\n\n**Output Example**:\n- Input: Node(5)\n  Output: 5\n\n- Input: [Node(1), Node(2), Node(3)]\n  Output: [1, 2, 3]\n\n- Input: {Node(1): Node(2), Node(3): Node(4)}\n  Output: {1: 2, 3: 4}"
      ],
      "code_start_line": 374,
      "code_end_line": 393,
      "params": [
        "obj"
      ],
      "have_return": true,
      "code_content": "def to_data(obj):\n    \"\"\"Extract the data from a node or a container of nodes.\"\"\"\n    # For node containers (tuple, list, dict, set, NodeContainer), we need to recursively extract the data from the nodes.\n    if isinstance(obj, Node):  # base case\n        return obj.data\n    elif isinstance(obj, tuple):\n        return tuple(to_data(x) for x in obj)\n    elif isinstance(obj, list):\n        return [to_data(x) for x in obj]\n    elif isinstance(obj, dict):\n        return {k: to_data(v) for k, v in obj.items()}\n    elif isinstance(obj, set):\n        return {to_data(x) for x in obj}\n    elif isinstance(obj, NodeContainer):\n        output = copy.copy(obj)\n        for k, v in obj.__dict__.items():\n            setattr(output, k, to_data(v))\n        return output\n    else:\n        return obj\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/forward",
        "tests\\unit_tests\\test_to_data.py",
        "tests\\unit_tests\\test_to_data.py/simple_test_unnested",
        "tests\\unit_tests\\test_to_data.py/simple_test_node_over_container",
        "tests\\unit_tests\\test_to_data.py/simple_test_container_over_node",
        "tests\\unit_tests\\test_to_data.py/test_container_over_container_over_node",
        "tests\\unit_tests\\test_to_data.py/test_node_over_container_over_container_over_node"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/NodeContainer",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "update_local",
      "md_content": [
        "**update_local**: The function of update_local is to update the value of a local variable in a given frame.\n\n**parameters**: The parameters of this Function.\n· frame: The frame object where the local variable resides.\n· name: The name of the local variable to be updated.\n· value: The new value to be assigned to the local variable.\n\n**Code Description**: The update_local function is designed to modify the value of a local variable within a specific frame. It takes three parameters: the frame object, the name of the local variable, and the new value to be assigned to that variable. The function first updates the local variable in the frame's f_locals dictionary. Then, it calls the PyFrame_LocalsToFast function from the ctypes.pythonapi module to ensure that the changes are reflected in the frame's fast locals array, which is used by the Python interpreter for efficient variable access.\n\nIn the context of its usage within the project, update_local is called by the tracer function in the FunModule class's forward method. The tracer function is responsible for modifying the local and global dictionaries of a frame to handle recursive calls of a wrapped function. Specifically, update_local is used to replace the current function in the frame's local variables with the original function when a recursive call is detected. This ensures that the recursive call invokes the unwrapped function rather than the bundled function, maintaining the correct function behavior.\n\n**Note**: Points to note about the use of the code\n- Ensure that the frame object passed to update_local is valid and corresponds to the correct execution context.\n- Be cautious when modifying local variables in a frame, as it can affect the execution flow and state of the program.\n- The ctypes module is used to interact with the Python C API, which may have implications for portability and compatibility across different Python versions and implementations."
      ],
      "code_start_line": 395,
      "code_end_line": 398,
      "params": [
        "frame",
        "name",
        "value"
      ],
      "have_return": false,
      "code_content": "def update_local(frame, name, value):\n    \"\"\" Update the value of a local variable in a frame.\"\"\"\n    frame.f_locals[name] = value\n    ctypes.pythonapi.PyFrame_LocalsToFast(ctypes.py_object(frame), ctypes.c_int(0))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/forward/tracer"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [
        "**test**: The function of test is to concatenate the string \" world\" to the data attribute of the input object.\n\n**parameters**: The parameters of this Function.\n· x: An object that must have a data attribute containing a string.\n\n**Code Description**: The test function takes a single parameter, x, which is expected to be an object with a data attribute. The function accesses the data attribute of the input object and concatenates the string \" world\" to it. The result of this concatenation is then returned as the output of the function.\n\n**Note**: \n- Ensure that the input object x has a data attribute that is a string; otherwise, the function will raise an AttributeError or TypeError.\n- This function does not perform any type checking or error handling, so it is crucial to pass an appropriate object to avoid runtime errors.\n\n**Output Example**: \nIf the input object x has a data attribute with the value \"Hello\", the function will return \"Hello world\"."
      ],
      "code_start_line": 405,
      "code_end_line": 406,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "    def test(x):\n        return x.data + \" world\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\trace\\containers.py": [
    {
      "type": "ClassDef",
      "name": "SeqIterable",
      "md_content": [
        "**SeqIterable**: The function of SeqIterable is to provide an iterable interface for a wrapped list-like object, allowing it to be iterated over in a sequential manner.\n\n**attributes**: The attributes of this Class.\n· _index: An integer that keeps track of the current position in the iteration.\n· wrapped_list: The list-like object that is being wrapped and iterated over.\n\n**Code Description**: The SeqIterable class is designed to wrap a list-like object and provide an iterator interface for it. This allows the wrapped object to be iterated over using Python's iterator protocol.\n\n- The `__init__` method initializes the SeqIterable object with a wrapped list-like object and sets the initial index to 0.\n- The `__iter__` method resets the index to 0 and returns the SeqIterable object itself as an iterator.\n- The `__next__` method retrieves the next item from the wrapped list. If the end of the list is reached, it raises a StopIteration exception to signal the end of the iteration. Each item retrieved is wrapped in a node object, and if the wrapped list is not already a parent of the node, it is added as a parent.\n\nThe SeqIterable class is utilized in the `iterate` function, which determines the appropriate iterable class to use based on the type of the input object. If the input is a list or tuple, it is wrapped in a SeqIterable object. If the input is a set, it is first converted to a list and then wrapped in a SeqIterable object. This ensures that various collection types can be iterated over in a consistent manner.\n\n**Note**: \n- The wrapped list-like object must have a `data` attribute that is a list or tuple.\n- The node function is used to wrap each item in the list, and it is assumed that this function and the Node class are defined elsewhere in the codebase.\n- The wrapped list-like object must support being checked for membership in the parents attribute of a node.\n\n**Output Example**: \nIf the wrapped list contains the elements [1, 2, 3], iterating over the SeqIterable object would yield:\n```\nnode(1)\nnode(2)\nnode(3)\n```\nEach element is wrapped in a node object before being returned."
      ],
      "code_start_line": 11,
      "code_end_line": 30,
      "params": [],
      "have_return": true,
      "code_content": "class SeqIterable:\n    def __init__(self, wrapped_list):\n        self._index = 0\n        self.wrapped_list = wrapped_list\n\n    def __iter__(self):\n        self._index = 0\n        return self\n\n    def __next__(self):\n        if self._index < len(self.wrapped_list.data):\n            result = self.wrapped_list[self._index]\n            self._index += 1\n            result_node = node(result)\n            # I'm not sure why this is necessary\n            if self.wrapped_list not in result_node.parents:\n                result_node._add_parent(self.wrapped_list)\n            return result_node\n        else:\n            raise StopIteration\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\containers.py/iterate"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the SeqIterable class with a given list.\n\n**parameters**: The parameters of this Function.\n· wrapped_list: A list that will be wrapped by the SeqIterable instance.\n\n**Code Description**: The __init__ method is a constructor that initializes an instance of the SeqIterable class. It takes one parameter, `wrapped_list`, which is expected to be a list. Inside the method, two instance variables are set:\n- `self._index`: This is initialized to 0 and will likely be used to keep track of the current position in the iteration process.\n- `self.wrapped_list`: This is assigned the value of the `wrapped_list` parameter, effectively storing the provided list within the instance for further operations.\n\n**Note**: Ensure that the `wrapped_list` parameter passed to the __init__ method is a list, as the class is designed to work with list-like structures."
      ],
      "code_start_line": 12,
      "code_end_line": 14,
      "params": [
        "self",
        "wrapped_list"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, wrapped_list):\n        self._index = 0\n        self.wrapped_list = wrapped_list\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__iter__",
      "md_content": [
        "**__iter__**: The function of __iter__ is to initialize the iteration process for the SeqIterable object and return the iterator itself.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters other than the implicit 'self' which refers to the instance of the SeqIterable class.\n\n**Code Description**: The __iter__ method is a special method in Python that is used to make an object iterable. When this method is called, it sets the internal index (_index) of the SeqIterable object to 0. This index is used to keep track of the current position during iteration. After initializing the index, the method returns the instance of the SeqIterable object itself, which will be used as the iterator. This allows the object to be used in iteration contexts such as loops.\n\n**Note**: \n- Ensure that the SeqIterable class has a properly defined __next__ method to work in conjunction with __iter__ for full iterator functionality.\n- The __iter__ method should be called before starting the iteration process to reset the index.\n\n**Output Example**: \nWhen the __iter__ method is called on an instance of SeqIterable, it returns the instance itself. For example:\n\n```python\nseq_iterable = SeqIterable()\niterator = iter(seq_iterable)\nprint(iterator is seq_iterable)  # Output: True\n```\n\nIn this example, calling iter(seq_iterable) invokes the __iter__ method, which returns the seq_iterable instance itself, confirming that the object is ready for iteration."
      ],
      "code_start_line": 16,
      "code_end_line": 18,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __iter__(self):\n        self._index = 0\n        return self\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__next__",
      "md_content": [
        "**__next__**: The function of __next__ is to iterate over the wrapped list of nodes and return the next node in the sequence.\n\n**parameters**:\n- self: Refers to the instance of the SeqIterable class that contains this method.\n\n**Code Description**:\nThe __next__ function is an implementation of the iterator protocol for the SeqIterable class. It allows users to iterate over the wrapped list of nodes and retrieve the next node in the sequence.\n\nThe function first checks if the current index (_index) is less than the length of the wrapped list of nodes. If it is, it retrieves the node at the current index using the wrapped_list attribute and assigns it to the result variable. It then increments the index by 1 to prepare for the next iteration.\n\nNext, the function creates a node object from the result using the node function from opto.trace.nodes. This step ensures that the result is always a valid node object, even if it was already a node or a different type of object.\n\nAfter creating the node object, the function checks if the wrapped_list is not already a parent of the result node. If it is not, it adds the wrapped_list as a parent of the result node using the _add_parent method from opto.trace.nodes. This step ensures that the hierarchical structure of the graph is maintained correctly.\n\nFinally, if the current index is equal to or greater than the length of the wrapped list, the function raises a StopIteration exception. This signals the end of the iteration and is the expected behavior for iterators.\n\nThe __next__ function is typically used in a loop or with the next() function to iterate over the nodes in a SeqIterable object. For example:\n\n```python\nseq_iterable = SeqIterable(wrapped_list)\nfor node in seq_iterable:\n    # Do something with each node\n```\n\n**Note**:\n- The __next__ function is part of the iterator protocol and is automatically called when iterating over a SeqIterable object.\n- The wrapped_list attribute should be a list-like object that supports indexing and has a length.\n- The function relies on the node function from opto.trace.nodes to create node objects from the elements of the wrapped list.\n- The _add_parent method from opto.trace.nodes is used to maintain the hierarchical structure of the graph.\n- The function raises a StopIteration exception when there are no more nodes to iterate over.\n\n**Output Example**: A possible return value of the __next__ function could be a node object representing the next node in the sequence."
      ],
      "code_start_line": 20,
      "code_end_line": 30,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __next__(self):\n        if self._index < len(self.wrapped_list.data):\n            result = self.wrapped_list[self._index]\n            self._index += 1\n            result_node = node(result)\n            # I'm not sure why this is necessary\n            if self.wrapped_list not in result_node.parents:\n                result_node._add_parent(self.wrapped_list)\n            return result_node\n        else:\n            raise StopIteration\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/AbstractNode/_add_parent"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "to_list_implicit",
      "md_content": [
        "**to_list_implicit**: The function of to_list_implicit is to convert any given iterable into a list.\n\n**parameters**: The parameters of this Function.\n· x: An iterable object of any type (e.g., set, tuple, etc.)\n\n**Code Description**: The to_list_implicit function takes a single parameter, x, which is expected to be an iterable. The function converts this iterable into a list using Python's built-in list() constructor and returns the resulting list. This conversion is implicit, meaning it does not check the type of the input explicitly but relies on the list() constructor to handle the conversion.\n\nIn the context of its usage within the project, to_list_implicit is called by the iterate function. The iterate function is designed to handle various types of data structures, including Node objects, lists, tuples, sets, and dictionaries. When iterate encounters a set, it uses to_list_implicit to convert the set into a list. This conversion is necessary because the subsequent processing within iterate, specifically the creation of a SeqIterable object, requires a list rather than a set.\n\n**Note**: \n- The input to to_list_implicit must be an iterable; otherwise, the list() constructor will raise a TypeError.\n- This function does not perform any type checking or validation on the input.\n\n**Output Example**: \nIf the input is a set {1, 2, 3}, the function will return [1, 2, 3].\nIf the input is a tuple (4, 5, 6), the function will return [4, 5, 6]."
      ],
      "code_start_line": 34,
      "code_end_line": 35,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def to_list_implicit(x: Any):\n    return list(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\containers.py/iterate"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "iterate",
      "md_content": [
        "**iterate**: The function of iterate is to provide an iterable interface for different types of objects, allowing them to be iterated over in a consistent manner.\n\n**parameters**:\n- x: The input object to be iterated over.\n\n**Code Description**: The iterate function is designed to handle various types of objects and determine the appropriate iterable class to use based on the type of the input object. It follows a series of conditional statements to check the type of the input object and returns the corresponding iterable object.\n\n- If the input object is a subclass of the Node class, it checks the type of the data attribute of the object. If the data attribute is a list or tuple, it creates a SeqIterable object and returns it. If the data attribute is a set, it converts the set to a list using the to_list_implicit function and then creates a SeqIterable object with the converted list. If the data attribute is a dictionary, it creates a DictIterable object and returns it. If the data attribute is of any other type, it raises an exception indicating that the object cannot be iterated over.\n\n- If the input object is a list or tuple, it creates a SeqIterable object with the input object and returns it.\n\n- If the input object is a set, it converts the set to a list using the to_list_implicit function and then creates a SeqIterable object with the converted list.\n\n- If the input object is a dictionary, it creates a DictIterable object with the input object and returns it.\n\n- If the input object is of any other type, it raises an exception indicating that the object cannot be iterated over.\n\nThe iterate function utilizes the SeqIterable and DictIterable classes defined in the code to provide the iterable interface for different types of objects. It ensures that objects of various collection types can be iterated over in a consistent manner.\n\n**Note**: \n- The input object must have a data attribute that is a list, tuple, set, or dictionary.\n- The to_list_implicit function is used to convert a set to a list.\n- The node function is used to wrap each item in the list or dictionary with a node object.\n- The Node class is assumed to be defined elsewhere in the codebase.\n\n**Output Example**: \nIf the input object is a list [1, 2, 3], iterating over the returned SeqIterable object would yield:\n```\nnode(1)\nnode(2)\nnode(3)\n```\nIf the input object is a dictionary {'a': 1, 'b': 2}, iterating over the returned DictIterable object would yield:\n```\n(node('a'), 1)\n(node('b'), 2)\n```"
      ],
      "code_start_line": 39,
      "code_end_line": 58,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def iterate(x: Any):\n    if issubclass(type(x), Node):\n        if type(x.data) == list or type(x.data) == tuple:\n            return SeqIterable(x)\n        elif type(x.data) == set:\n            converted_list = to_list_implicit(x)\n            return SeqIterable(converted_list)\n        elif type(x.data) == dict:\n            return DictIterable(x)\n        else:\n            raise Exception(\"Cannot iterate on an object of type {}\".format(type(x.data)))\n    elif type(x) == list or type(x) == tuple:\n        return SeqIterable(node(x))\n    elif type(x) == set:\n        converted_list = to_list_implicit(x)\n        return SeqIterable(converted_list)\n    elif type(x) == dict:\n        return DictIterable(node(x))\n    else:\n        raise Exception(\"Cannot iterate on an object of type {}\".format(type(x)))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__iter__"
      ],
      "reference_who": [
        "opto\\trace\\containers.py/SeqIterable",
        "opto\\trace\\containers.py/to_list_implicit",
        "opto\\trace\\containers.py/DictIterable",
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "DictIterable",
      "md_content": [
        "**DictIterable**: The function of DictIterable is to provide an iterable interface for dictionary-like objects, allowing iteration over key-value pairs.\n\n**attributes**: The attributes of this Class.\n· _index: An integer that keeps track of the current position in the iteration.\n· wrapped_dict: The dictionary-like object that is being wrapped and iterated over.\n· keys: A list of keys from the wrapped_dict, used to facilitate iteration.\n\n**Code Description**: The DictIterable class is designed to enable iteration over dictionary-like objects. When an instance of DictIterable is created, it takes a dictionary-like object (wrapped_dict) as an argument. The constructor initializes the _index attribute to 0, stores the wrapped_dict, and extracts the keys from the wrapped_dict's data attribute, storing them in the keys attribute.\n\nThe __iter__ method resets the _index to 0 and returns the instance itself, making the object an iterator.\n\nThe __next__ method is responsible for returning the next item in the iteration. It checks if the current _index is less than the length of the keys list. If so, it retrieves the key at the current index, constructs a tuple containing a node object created from the key and the corresponding value from the wrapped_dict, and increments the _index. Before returning the tuple, it adds the wrapped_dict as a parent to both the key and value nodes. If the _index exceeds the length of the keys list, a StopIteration exception is raised to signal the end of the iteration.\n\nThe DictIterable class is utilized in the iterate and items functions. The iterate function determines the type of the input object and returns an appropriate iterable object. If the input is a dictionary or a dictionary-like object, iterate returns an instance of DictIterable. Similarly, the items function checks if the input object's data attribute is a dictionary and returns a DictIterable instance if true.\n\n**Note**: \n- The wrapped_dict parameter must be a dictionary-like object with a data attribute that is a dictionary.\n- The node function and the _add_parent method must be defined elsewhere in the codebase for DictIterable to function correctly.\n\n**Output Example**: \nAssuming the wrapped_dict contains {'a': 1, 'b': 2}, iterating over an instance of DictIterable would yield:\n(node('a'), 1)\n(node('b'), 2)"
      ],
      "code_start_line": 61,
      "code_end_line": 82,
      "params": [],
      "have_return": true,
      "code_content": "class DictIterable:\n    def __init__(self, wrapped_dict):\n        self._index = 0\n        self.wrapped_dict = wrapped_dict\n        self.keys = list(wrapped_dict.data.keys())\n\n    def __iter__(self):\n        self._index = 0\n        return self\n\n    def __next__(self):\n        if self._index < len(self.keys):\n            key = self.keys[self._index]\n            result = (node(key), self.wrapped_dict[key])\n            self._index += 1\n\n            result[0]._add_parent(self.wrapped_dict)\n            result[1]._add_parent(self.wrapped_dict)\n\n            return result\n        else:\n            raise StopIteration\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\containers.py/iterate",
        "opto\\trace\\containers.py/items"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the DictIterable class with a given dictionary.\n\n**parameters**: The parameters of this Function.\n· wrapped_dict: A dictionary-like object that contains the data to be wrapped by the DictIterable instance.\n\n**Code Description**: The __init__ method initializes an instance of the DictIterable class. It takes one parameter, `wrapped_dict`, which is expected to be a dictionary-like object. Inside the method, the instance variable `_index` is initialized to 0, which will likely be used to keep track of the current position during iteration. The `wrapped_dict` parameter is assigned to the instance variable `wrapped_dict`, allowing the instance to store and access the provided dictionary. Additionally, the keys of the dictionary are extracted and converted into a list, which is then assigned to the instance variable `keys`. This list of keys will be used for iterating over the dictionary.\n\n**Note**: Ensure that the `wrapped_dict` parameter passed to the __init__ method is a dictionary-like object with a `data` attribute that contains the actual dictionary. This is crucial for the proper functioning of the DictIterable class."
      ],
      "code_start_line": 62,
      "code_end_line": 65,
      "params": [
        "self",
        "wrapped_dict"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, wrapped_dict):\n        self._index = 0\n        self.wrapped_dict = wrapped_dict\n        self.keys = list(wrapped_dict.data.keys())\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__iter__",
      "md_content": [
        "**__iter__**: The function of __iter__ is to initialize the iteration process for the DictIterable object.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The __iter__ method is a special method in Python that is used to make an object iterable. When this method is called, it sets the internal index `_index` of the object to 0. This index is likely used to keep track of the current position during iteration. After initializing the index, the method returns the object itself (`self`). This allows the object to be used in iteration contexts, such as in a for loop. By implementing the __iter__ method, the DictIterable object conforms to the iterator protocol, which requires an __iter__ method that returns the iterator object itself.\n\n**Note**: \n- Ensure that the DictIterable class has a corresponding __next__ method to complete the iterator protocol. The __next__ method should define how the iteration progresses and when it stops.\n- The __iter__ method should not modify the underlying data structure of the object; it should only initialize the state required for iteration.\n\n**Output Example**: \nWhen the __iter__ method is called on a DictIterable object, it does not produce a direct output but prepares the object for iteration. For example:\n\n```python\ndict_iterable = DictIterable()\niterator = iter(dict_iterable)\n```\n\nIn this example, `iterator` is the same as `dict_iterable`, now ready to be used in a loop or any other iteration context."
      ],
      "code_start_line": 67,
      "code_end_line": 69,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __iter__(self):\n        self._index = 0\n        return self\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__next__",
      "md_content": [
        "**__next__**: The function of __next__ is to iterate over the items in the wrapped dictionary, returning each key-value pair as a tuple of Node objects.\n\n**parameters**: The parameters of this Function.\n- This function does not take any parameters.\n\n**Code Description**: The __next__ method is designed to facilitate iteration over a dictionary wrapped within the DictIterable object. It maintains an internal index (_index) to keep track of the current position in the iteration. The method first checks if the current index is less than the length of the keys in the dictionary. If so, it retrieves the key at the current index and constructs a tuple (result) consisting of two elements:\n1. A Node object created from the key.\n2. A Node object created from the corresponding value in the wrapped dictionary.\n\nBoth elements of the tuple are created using the node function, which ensures that they are properly instantiated as Node objects. After creating the tuple, the method increments the internal index (_index) by one to move to the next item in the subsequent call.\n\nAdditionally, the method calls the _add_parent method on both elements of the tuple, passing the wrapped dictionary as the parent. This establishes a parent-child relationship between the nodes and the dictionary, which can be useful for tracking dependencies or maintaining hierarchical structures.\n\nIf the current index is equal to or greater than the length of the keys, the method raises a StopIteration exception, signaling that the iteration is complete.\n\n**Note**:\n- The __next__ method is intended to be used in conjunction with an iterator protocol, typically within a for loop or similar construct.\n- The method relies on the node function to create Node objects, ensuring consistency and proper initialization.\n- The _add_parent method is called on both the key and value nodes to establish a parent-child relationship with the wrapped dictionary.\n\n**Output Example**: A possible return value of the __next__ method could be:\n```\n(node('some_key'), node('some_value'))\n```\nwhere 'some_key' and 'some_value' are entries in the wrapped dictionary, and both are converted to Node objects."
      ],
      "code_start_line": 71,
      "code_end_line": 82,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __next__(self):\n        if self._index < len(self.keys):\n            key = self.keys[self._index]\n            result = (node(key), self.wrapped_dict[key])\n            self._index += 1\n\n            result[0]._add_parent(self.wrapped_dict)\n            result[1]._add_parent(self.wrapped_dict)\n\n            return result\n        else:\n            raise StopIteration\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "items",
      "md_content": [
        "**items**: The function of items is to return an iterable interface for dictionary-like objects, allowing iteration over key-value pairs if the input object's data attribute is a dictionary.\n\n**parameters**: The parameters of this Function.\n· x: An object that is expected to have a data attribute.\n\n**Code Description**: The items function is designed to facilitate iteration over the key-value pairs of an object's data attribute, provided that this attribute is a dictionary. The function first checks if the data attribute of the input object x is of type dict. If it is not, the function returns an AttributeError, indicating that items cannot be retrieved from the given type. If the data attribute is indeed a dictionary, the function returns an instance of DictIterable, which is a class designed to enable iteration over dictionary-like objects.\n\nThe DictIterable class, when instantiated, takes the dictionary-like object (wrapped_dict) and provides an iterable interface. It initializes an index to keep track of the current position in the iteration and extracts the keys from the wrapped_dict's data attribute. The __iter__ method resets the index and returns the instance itself, making it an iterator. The __next__ method retrieves the next item in the iteration, constructs a tuple containing a node object created from the key and the corresponding value from the wrapped_dict, and increments the index. If the index exceeds the length of the keys list, a StopIteration exception is raised to signal the end of the iteration.\n\n**Note**: \n- The input object x must have a data attribute that is a dictionary for the function to work correctly.\n- The node function and the _add_parent method must be defined elsewhere in the codebase for DictIterable to function correctly.\n\n**Output Example**: \nAssuming the input object's data attribute contains {'a': 1, 'b': 2}, calling the items function would yield:\n(node('a'), 1)\n(node('b'), 2)"
      ],
      "code_start_line": 85,
      "code_end_line": 88,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def items(x: Any):\n    if type(x.data) != dict:\n        return AttributeError(\"Cannot get items from an object of type {}\".format(type(x.data)))\n    return DictIterable(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\containers.py/DictIterable"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Seq",
      "md_content": [
        "**Seq**: The function of Seq is to represent a sequence with a defined length and index, converting Python's list or tuple into a Seq object.\n\n**attributes**: The attributes of this Class.\n· data: Inherited from UserList, it stores the sequence data.\n\n**Code Description**: The Seq class is a specialized container that inherits from both UserList and ParameterContainer. It is designed to handle sequences, converting Python lists or tuples into Seq objects. The class provides a method to retrieve a dictionary of parameters contained within the sequence.\n\nThe `__init__` method initializes the Seq object. It accepts a variable number of arguments (`*args`). If a single argument is passed and it has both `__len__` and `__getitem__` attributes (indicating it is a sequence), it is used directly as the sequence. Otherwise, the arguments are treated as individual elements of the sequence. The superclass initializer is then called with the sequence.\n\nThe `parameters_dict` method returns a dictionary of all parameters in the model, including both trainable and non-trainable parameters. It iterates over the elements in the sequence (`self.data`). If an element is an instance of ParameterNode, it adds it to the dictionary with its name as the key. If an element is an instance of ParameterContainer, it adds it to the dictionary with the string representation of the container as the key. The method ensures that all values in the dictionary are instances of either ParameterNode or ParameterContainer.\n\nThe Seq class leverages the functionality of the ParameterContainer class, which serves as a container for parameter nodes. The ParameterContainer class provides methods to retrieve a flattened list of parameters and a dictionary of all parameters in the model. The Seq class uses the `parameters_dict` method to gather parameters from its elements, ensuring they are correctly identified and stored.\n\n**Note**: \n- The Seq class is designed to work seamlessly with Python's list and tuple types, converting them into Seq objects.\n- When using the Seq class, ensure that the elements within the sequence are either ParameterNode or ParameterContainer instances to maintain the integrity of the `parameters_dict` method.\n\n**Output Example**:\n```python\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterNode object>,\n    'container1': <ParameterContainer object>,\n    'container2': <ParameterContainer object>\n}\n```"
      ],
      "code_start_line": 91,
      "code_end_line": 117,
      "params": [],
      "have_return": true,
      "code_content": "class Seq(UserList, ParameterContainer):\n    \"\"\"\n    Seq is defined as having a length and an index.\n    Python's list/tuple will be converted to Seq\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 1 and hasattr(args[0], \"__len__\") and hasattr(args[0], \"__getitem__\"):\n            seq = args[0]\n        else:\n            seq = args\n        super().__init__(initlist=seq)\n\n    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for attr in self.data:\n            if isinstance(attr, ParameterNode):\n                parameters[attr.name] = attr\n            elif isinstance(attr, ParameterContainer):\n                parameters[str(attr)] = attr  # TODO: what is the name of the container?\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n        return parameters\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_containers.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the Seq class.\n\n**parameters**: The parameters of this Function.\n· *args: A variable-length argument list that can contain one or more elements.\n\n**Code Description**: The __init__ method is designed to initialize an instance of the Seq class. It first checks if there is exactly one argument passed and if this argument has both the `__len__` and `__getitem__` attributes, which are typical of sequence-like objects (e.g., lists, tuples). If these conditions are met, the single argument is treated as a sequence and assigned to the variable `seq`. If the conditions are not met, all arguments are treated as individual elements and are collectively assigned to `seq` as a tuple. Finally, the method calls the `__init__` method of the superclass with `initlist=seq`, passing the sequence or tuple to the superclass for further initialization.\n\n**Note**: \n- Ensure that if a single argument is passed, it should be a sequence-like object (having `__len__` and `__getitem__` attributes) to be treated as such.\n- If multiple arguments are passed, they will be treated as individual elements and combined into a tuple.\n- This method leverages the flexibility of accepting both single sequence-like objects and multiple individual elements, making it versatile for different initialization scenarios."
      ],
      "code_start_line": 97,
      "code_end_line": 102,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, *args):\n        if len(args) == 1 and hasattr(args[0], \"__len__\") and hasattr(args[0], \"__getitem__\"):\n            seq = args[0]\n        else:\n            seq = args\n        super().__init__(initlist=seq)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parameters_dict",
      "md_content": [
        "**parameters_dict**: The function of parameters_dict is to return a dictionary of all the parameters in the model, including both trainable and non-trainable parameters.\n\n**parameters**:\n- No parameters are defined within the provided code snippet.\n\n**Code Description**:\nThe `parameters_dict` method is used to retrieve a dictionary of all the parameters in the model, including both trainable and non-trainable parameters. It iterates over the items in the `self.data` attribute, which is assumed to be a dictionary-like object. For each item, it checks if the value is an instance of `ParameterNode`. If it is, it adds the value to the `parameters` dictionary with the attribute name as the key. If the value is an instance of `ParameterContainer`, it adds the value to the `parameters` dictionary with the attribute name as the key. \n\nThe `parameters_dict` method ensures that all the values in the `parameters` dictionary are instances of `ParameterNode` or `ParameterContainer` by asserting that the `isinstance` condition holds true for all values.\n\nThe `parameters_dict` method is called internally by the `parameters` method to retrieve the parameters dictionary.\n\n**Note**: \n- The `parameters_dict` method assumes that the `self.data` attribute is a dictionary-like object containing the parameters.\n- The `parameters_dict` method does not specify the name of the container when adding a `ParameterContainer` to the `parameters` dictionary. This could be a potential improvement to consider.\n\n**Output Example**:\n```python\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterNode object>,\n    'container1': <ParameterContainer object>,\n    'container2': <ParameterContainer object>\n}\n```"
      ],
      "code_start_line": 104,
      "code_end_line": 117,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for attr in self.data:\n            if isinstance(attr, ParameterNode):\n                parameters[attr.name] = attr\n            elif isinstance(attr, ParameterContainer):\n                parameters[str(attr)] = attr  # TODO: what is the name of the container?\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n        return parameters\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Map",
      "md_content": [
        "**Map**: The function of Map is to serve as a specialized container that maps keys to values, converting Python's standard dictionary into a Map object.\n\n**attributes**: The attributes of this Class.\n· No specific attributes are defined within the provided code snippet.\n\n**Code Description**: \nThe `Map` class is a specialized container that inherits from both `UserDict` and `ParameterContainer`. It is designed to map keys to values, similar to a Python dictionary, but with additional functionality specific to handling parameters in a model.\n\n- **Initialization**: The `__init__` method initializes the `Map` object by calling the constructor of its parent classes with the provided `mapping`. This ensures that the `Map` object is initialized with the given key-value pairs.\n\n- **parameters_dict Method**: The `parameters_dict` method returns a dictionary of all the parameters in the model, including both trainable and non-trainable parameters. The dictionary contains `ParameterNode` or `ParameterContainer` objects. The method iterates over the items in the `data` attribute (inherited from `UserDict`), checking the type of each key and value:\n  - If the value is an instance of `ParameterNode`, it is added to the `parameters` dictionary.\n  - If the value is an instance of `ParameterContainer`, it is also added to the `parameters` dictionary, but the key is converted to a string representation.\n  - If the key is an instance of `ParameterNode`, it is added to the `parameters` dictionary with its string representation as the key.\n  - If the key is an instance of `ParameterContainer`, an exception is raised because a `Map` cannot have a container as a key.\n\nThe method asserts that all values in the `parameters` dictionary are instances of either `ParameterNode` or `ParameterContainer` before returning the dictionary.\n\n**Note**: \n- The `Map` class ensures that all keys and values adhere to specific types (`ParameterNode` or `ParameterContainer`), maintaining the integrity of the parameter mapping.\n- The `parameters_dict` method is crucial for retrieving a structured dictionary of parameters, which is essential for model optimization and parameter management.\n- The `Map` class cannot have a `ParameterContainer` as a key, which is enforced by raising an exception.\n\n**Output Example**:\n```python\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterNode object>,\n    'container1': <ParameterContainer object>\n}\n```"
      ],
      "code_start_line": 120,
      "code_end_line": 147,
      "params": [],
      "have_return": true,
      "code_content": "class Map(UserDict, ParameterContainer):\n    \"\"\"\n    Map is defined as key and value\n    Python's dict will be converted to Map\n    \"\"\"\n\n    def __init__(self, mapping):\n        super().__init__(mapping)\n\n    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for k, v in self.data.items():\n            if isinstance(v, ParameterNode):\n                parameters[k] = v\n            elif isinstance(v, ParameterContainer):\n                parameters[str(v)] = v  # TODO: what is the name of the container?\n\n            if isinstance(k, ParameterNode):\n                parameters[str(k)] = k\n            elif isinstance(k, ParameterContainer):\n                raise Exception(\"The key of a Map cannot be a container.\")\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n        return parameters\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_containers.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the Map class with a given mapping.\n\n**parameters**: The parameters of this Function.\n· mapping: A dictionary or any other mapping object that will be used to initialize the Map instance.\n\n**Code Description**: The __init__ method is a constructor for the Map class. It takes a single parameter, `mapping`, which is expected to be a dictionary or another type of mapping object. The method then calls the `__init__` method of its superclass with the provided `mapping` as an argument. This ensures that the Map instance is properly initialized with the given mapping data. The use of `super().__init__(mapping)` indicates that the Map class is likely inheriting from a parent class that requires initialization with a mapping object.\n\n**Note**: Ensure that the `mapping` parameter passed to the __init__ method is a valid mapping object, such as a dictionary, to avoid any initialization errors."
      ],
      "code_start_line": 126,
      "code_end_line": 127,
      "params": [
        "self",
        "mapping"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, mapping):\n        super().__init__(mapping)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parameters_dict",
      "md_content": [
        "**parameters_dict**: The function of parameters_dict is to return a dictionary of all the parameters in the model, including both trainable and non-trainable parameters.\n\n**parameters**:\n- self: The current object.\n\n**Code Description**:\nThe `parameters_dict` method is used to retrieve a dictionary of all the parameters in the model, including both trainable and non-trainable parameters. It iterates over the items in the `data` attribute of the current object and checks the type of each value. If the value is an instance of `ParameterNode`, it adds it to the `parameters` dictionary with the key as the corresponding key in the `data` attribute. If the value is an instance of `ParameterContainer`, it adds it to the `parameters` dictionary with the key as the string representation of the container. \n\nAdditionally, the method checks the type of each key in the `data` attribute. If the key is an instance of `ParameterNode`, it adds it to the `parameters` dictionary with the key as the string representation of the node. If the key is an instance of `ParameterContainer`, it raises an exception since the key of a Map cannot be a container.\n\nFinally, the method asserts that all the values in the `parameters` dictionary are instances of `ParameterNode` or `ParameterContainer` and returns the `parameters` dictionary.\n\n**Note**: \n- The `parameters_dict` method is called internally by the `parameters` method to retrieve the parameters dictionary.\n- The `parameters_dict` method includes both trainable and non-trainable parameters in the returned dictionary.\n\n**Output Example**:\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterNode object>,\n    'container1': <ParameterContainer object>,\n    'container2': <ParameterContainer object>\n}"
      ],
      "code_start_line": 129,
      "code_end_line": 147,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for k, v in self.data.items():\n            if isinstance(v, ParameterNode):\n                parameters[k] = v\n            elif isinstance(v, ParameterContainer):\n                parameters[str(v)] = v  # TODO: what is the name of the container?\n\n            if isinstance(k, ParameterNode):\n                parameters[str(k)] = k\n            elif isinstance(k, ParameterContainer):\n                raise Exception(\"The key of a Map cannot be a container.\")\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n        return parameters\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    }
  ],
  "opto\\trace\\errors.py": [
    {
      "type": "ClassDef",
      "name": "ExecutionError",
      "md_content": [
        "**ExecutionError**: The function of ExecutionError is to serve as a base class for handling execution errors in code tracing.\n\n**attributes**: The attributes of this Class.\n· exception_node: An instance of ExceptionNode that contains details about the exception.\n\n**Code Description**: The ExecutionError class is designed to encapsulate errors that occur during the execution of code within a tracing context. It inherits from the built-in Exception class, providing additional context through the exception_node attribute.\n\n- The `__init__` method initializes the ExecutionError instance with an ExceptionNode object, which contains detailed information about the exception, including the error message, inputs, and other metadata. The base Exception class is then initialized with the data from the exception_node.\n\n- The `__str__` method provides a string representation of the ExecutionError, which includes the data from the exception_node. This makes it easier to understand the nature of the error when it is printed or logged.\n\nIn the project, ExecutionError is used in the following contexts:\n\n1. **opto\\trace\\bundle.py/FunModule/fun**: Within the `fun` method, ExecutionError is raised when there is a SyntaxError, NameError, KeyError, or OSError during the execution of dynamically generated code. The ExceptionNode is created with details about the error and passed to ExecutionError, which is then raised to signal the issue.\n\n2. **opto\\trace\\bundle.py/FunModule/wrap**: In the `wrap` method, ExecutionError is raised if the output of a function is an exception. An ExceptionNode is created with the exception details and passed to ExecutionError, which is then raised to indicate the error.\n\n3. **opto\\trace\\nodes.py/ExceptionNode/__init__**: The ExceptionNode class's `__init__` method checks if the value is an instance of ExecutionError. If not, it formats the exception message accordingly. This ensures that ExecutionError instances are handled correctly within the ExceptionNode.\n\n**Note**: When using ExecutionError, ensure that the exception_node provided contains all necessary information about the error, as this will be used to initialize the base Exception class and provide a meaningful error message.\n\n**Output Example**: \nIf an ExecutionError is raised due to a SyntaxError in the dynamically executed code, the string representation might look like:\n```\nExecutionError: (SyntaxError) invalid syntax (<string>, line 1)\n```\nThis output indicates that a SyntaxError occurred, providing the specific error message and location."
      ],
      "code_start_line": 5,
      "code_end_line": 13,
      "params": [],
      "have_return": true,
      "code_content": "class ExecutionError(Exception):\n    \"\"\"Base class for execution error in code tracing.\"\"\"\n\n    def __init__(self, exception_node: ExceptionNode):\n        self.exception_node = exception_node\n        super().__init__(self.exception_node.data)\n\n    def __str__(self):\n        return f\"ExecutionError: {self.exception_node.data}\"\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/fun",
        "opto\\trace\\bundle.py/FunModule/wrap",
        "opto\\trace\\nodes.py/ExceptionNode/__init__",
        "tests\\unit_tests\\test_error_handling.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the ExecutionError class with a given ExceptionNode.\n\n**parameters**: The parameters of this Function.\n· exception_node: An instance of ExceptionNode that contains the exception message and related data.\n\n**Code Description**: The __init__ method of the ExecutionError class is responsible for initializing an instance of the class. It takes one parameter, exception_node, which is an instance of ExceptionNode. This ExceptionNode contains the exception message and related data.\n\nUpon initialization, the method assigns the provided exception_node to the instance variable self.exception_node. It then calls the __init__ method of its superclass with the data retrieved from the exception_node. This is achieved by accessing the data attribute of the exception_node, which returns the internal data of the node. The superclass's __init__ method is thus provided with this data, ensuring that the ExecutionError instance is properly initialized with the relevant exception information.\n\nThe relationship with its callees in the project is as follows:\n- The data method of the ExceptionNode class is called to retrieve the internal data of the node. This data is then passed to the superclass's __init__ method to complete the initialization process.\n\n**Note**: It is important to ensure that the exception_node parameter is a valid instance of ExceptionNode, as the method relies on the data attribute of this object to function correctly. If the exception_node does not have the expected structure, the initialization process may fail."
      ],
      "code_start_line": 8,
      "code_end_line": 10,
      "params": [
        "self",
        "exception_node"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, exception_node: ExceptionNode):\n        self.exception_node = exception_node\n        super().__init__(self.exception_node.data)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/ExceptionNode"
      ],
      "special_reference_type": [
        false,
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to provide a string representation of the ExecutionError object, specifically detailing the error message associated with the exception node.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the ExecutionError class.\n\n**Code Description**: The __str__ method is designed to return a formatted string that represents the ExecutionError instance. It accesses the `exception_node` attribute of the ExecutionError object and retrieves its data using the `data` method. The `data` method, defined in the AbstractNode class, returns the internal data of the node, which in this context is the error message or relevant data associated with the exception. The __str__ method then formats this data into a string prefixed with \"ExecutionError: \", providing a clear and concise description of the error for debugging and logging purposes.\n\n**Note**: This method assumes that the `exception_node` attribute is properly initialized and contains a valid node object with accessible data. If the `exception_node` is not set or its data is not retrievable, this could lead to unexpected behavior or errors.\n\n**Output Example**: A possible return value of the __str__ method could be:\n```\nExecutionError: File not found\n```\nThis output indicates that the error message stored in the `exception_node` is \"File not found\"."
      ],
      "code_start_line": 12,
      "code_end_line": 13,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self):\n        return f\"ExecutionError: {self.exception_node.data}\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "TraceMissingInputsError",
      "md_content": [
        "**TraceMissingInputsError**: The TraceMissingInputsError class represents an exception that is raised when not all nodes used in the operator function are specified as inputs of the returned node.\n\n**Attributes**:\n- message: A string representing the error message.\n\n**Code Description**:\nThe TraceMissingInputsError class is a subclass of the built-in Exception class. It is used to handle the case where not all nodes used in the operator function are specified as inputs of the returned node. \n\nThe class has an `__init__` method that takes a `message` parameter and initializes the `message` attribute with the provided message. It also calls the `__init__` method of the parent Exception class with the message.\n\nThe class also overrides the `__str__` method to return the error message when the exception is converted to a string.\n\nThis exception is raised in the `forward` method of the `FunModule` class in the `opto.trace.bundle` module. The `forward` method is responsible for executing the operator function and handling any exceptions that occur during execution. If the `catch_execution_error` flag is set to `True`, the exception is caught and stored in the `outputs` variable. Otherwise, the exception is raised and propagated.\n\n**Note**: \n- This exception is raised when not all nodes used in the operator function are specified as inputs of the returned node.\n- The error message can be accessed through the `message` attribute of the exception object.\n\n**Output Example**:\n```\nTraceMissingInputsError: Not all nodes used in the operator <function fun at 0x00000123456789> are specified as inputs of the returned node. Missing ['node_x']\n```"
      ],
      "code_start_line": 16,
      "code_end_line": 22,
      "params": [],
      "have_return": true,
      "code_content": "class TraceMissingInputsError(Exception):\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(self.message)\n\n    def __str__(self):\n        return self.message  # f\"TraceMissingInputsError: {self.message}\"\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/forward",
        "tests\\unit_tests\\test_bundle.py",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the TraceMissingInputsError class with a specific error message.\n\n**parameters**: The parameters of this Function.\n· message: A string that contains the error message to be associated with the TraceMissingInputsError instance.\n\n**Code Description**: The __init__ method is a constructor for the TraceMissingInputsError class. It takes a single parameter, `message`, which is a string representing the error message. Inside the method, the `message` parameter is assigned to the instance variable `self.message`. The constructor then calls the `__init__` method of its superclass using `super().__init__(self.message)`, passing the error message to the base class's constructor. This ensures that the error message is properly initialized and can be accessed through the standard exception handling mechanisms.\n\n**Note**: \n- Ensure that the `message` parameter is a string to avoid type errors.\n- This method is essential for setting up the error message that will be displayed when the TraceMissingInputsError is raised."
      ],
      "code_start_line": 17,
      "code_end_line": 19,
      "params": [
        "self",
        "message"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, message: str):\n        self.message = message\n        super().__init__(self.message)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to return the error message associated with the TraceMissingInputsError instance.\n\n**parameters**: The parameters of this Function.\n· None: This method does not take any parameters.\n\n**Code Description**: The __str__ method in the TraceMissingInputsError class is designed to provide a human-readable representation of the error. When this method is called, it returns the value of the `message` attribute of the instance. This attribute typically contains a descriptive error message that explains the nature of the TraceMissingInputsError. The method ensures that when the error is printed or converted to a string, the message is displayed, making it easier for developers to understand the issue.\n\n**Note**: \n- This method overrides the default __str__ method provided by Python's base Exception class.\n- Ensure that the `message` attribute is properly set when initializing the TraceMissingInputsError instance to provide meaningful error information.\n\n**Output Example**: \nIf the `message` attribute of the TraceMissingInputsError instance is set to \"Input data is missing\", calling the __str__ method will return:\n```\n\"Input data is missing\"\n```"
      ],
      "code_start_line": 21,
      "code_end_line": 22,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self):\n        return self.message  # f\"TraceMissingInputsError: {self.message}\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\trace\\modules.py": [
    {
      "type": "ClassDef",
      "name": "NodeContainer",
      "md_content": [
        "**NodeContainer**: The function of NodeContainer is to serve as an identifier for a container of nodes.\n\n**attributes**: The attributes of this Class.\n· No specific attributes are defined within the provided code snippet.\n\n**Code Description**: The NodeContainer class is designed to act as a marker or identifier for objects that are containers of nodes. This class itself does not contain any specific attributes or methods, but it is used as a base class or type identifier in various parts of the project.\n\nIn the project, NodeContainer is utilized in several contexts:\n\n1. **apply_op function in broadcast.py**:\n   - The apply_op function performs broadcasting operations on containers of nodes. It checks if the output is an instance of NodeContainer and recursively applies the operation to each attribute of the NodeContainer instance. This indicates that NodeContainer is used to group nodes together, allowing operations to be applied uniformly across all contained nodes.\n\n2. **to_data function in bundle.py**:\n   - The to_data function extracts data from nodes or containers of nodes. When the input object is an instance of NodeContainer, the function recursively extracts data from each attribute of the NodeContainer. This shows that NodeContainer is used to encapsulate nodes, enabling data extraction from complex structures.\n\n3. **ParameterContainer class in modules.py**:\n   - ParameterContainer inherits from NodeContainer and represents a container of parameter nodes. It includes methods to retrieve a flattened list of parameters and a dictionary of all parameters in the model. This inheritance indicates that ParameterContainer leverages the NodeContainer's role as a node container to manage parameter nodes specifically.\n\n4. **SubContainer and Container classes in test_apply_op.py**:\n   - Both SubContainer and Container classes inherit from NodeContainer. These classes initialize with various node attributes, demonstrating how NodeContainer can be extended to create more complex containers of nodes for testing purposes.\n\n**Note**: Points to note about the use of the code\n- NodeContainer itself does not define any attributes or methods; it serves as a base class or type identifier.\n- When extending NodeContainer, ensure that the derived classes properly encapsulate nodes to leverage the functionality provided by functions like apply_op and to_data.\n- NodeContainer is integral to the project's handling of node containers, enabling consistent operations and data extraction across different types of node groupings."
      ],
      "code_start_line": 9,
      "code_end_line": 11,
      "params": [],
      "have_return": false,
      "code_content": "class NodeContainer:\n    \"\"\" An identifier for a container of nodes.\"\"\"\n    ...\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "opto\\trace\\broadcast.py",
        "opto\\trace\\broadcast.py/apply_op",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\modules.py/ParameterContainer",
        "tests\\unit_tests\\not_covered_usage_cases.py",
        "tests\\unit_tests\\test_apply_op.py",
        "tests\\unit_tests\\test_apply_op.py/SubContainer",
        "tests\\unit_tests\\test_apply_op.py/Container"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "trainable_method",
      "md_content": [
        "**trainable_method**: The function of trainable_method is to determine if a given method is callable and has an attribute named \"parameter\".\n\n**parameters**: The parameters of this Function.\n· method: The method to be checked for callability and the presence of the \"parameter\" attribute.\n\n**Code Description**: The trainable_method function is designed to check two specific conditions for a given method:\n1. It verifies if the method is callable using the callable() function.\n2. It checks if the method has an attribute named \"parameter\" using the hasattr() function.\n\nIf both conditions are met, the function returns True; otherwise, it returns False. This function is particularly useful in scenarios where methods need to be filtered based on their trainability, which is indicated by the presence of the \"parameter\" attribute.\n\nIn the context of its usage within the ParameterContainer class's parameters_dict method, trainable_method plays a crucial role. The parameters_dict method constructs a dictionary of all parameters in the model, including both trainable and non-trainable parameters. It iterates over the attributes of the ParameterContainer instance and uses trainable_method to identify methods that are both callable and have a \"parameter\" attribute. These methods are then included in the resulting dictionary with their \"parameter\" attribute values.\n\n**Note**: \n- Ensure that the methods being checked are intended to have a \"parameter\" attribute if they are to be considered trainable.\n- This function does not check the type or validity of the \"parameter\" attribute, only its presence.\n\n**Output Example**: \nFor a method that is callable and has a \"parameter\" attribute, trainable_method would return:\n```\nTrue\n```\nFor a method that is either not callable or lacks a \"parameter\" attribute, trainable_method would return:\n```\nFalse\n```"
      ],
      "code_start_line": 14,
      "code_end_line": 15,
      "params": [
        "method"
      ],
      "have_return": true,
      "code_content": "def trainable_method(method):\n    return callable(method) and hasattr(method, \"parameter\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\modules.py/ParameterContainer/parameters_dict"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "ParameterContainer",
      "md_content": [
        "**ParameterContainer**: The function of ParameterContainer is to serve as a container for parameter nodes.\n\n**attributes**:\n- No specific attributes are defined within the provided code snippet.\n\n**Code Description**:\nThe ParameterContainer class is a subclass of NodeContainer and represents a container of parameter nodes. It provides methods to retrieve a flattened list of parameters and a dictionary of all parameters in the model.\n\nThe `parameters` method returns a flattened list of all the parameters in the model's `parameters_dict`. It iterates over the items in the `parameters_dict` and checks if each value is an instance of `ParameterNode` or `ParameterContainer`. If it is a `ParameterNode`, it appends it to the `parameters` list. If it is a `ParameterContainer`, it recursively calls the `parameters` method on the container and extends the `parameters` list with the result. If the value is neither a `ParameterNode` nor a `ParameterContainer`, it raises a `ValueError`.\n\nThe `parameters_dict` method returns a dictionary of all the parameters in the model, including both trainable and non-trainable parameters. It uses the `inspect.getmembers` function to get all the attributes of the `self` object. It then iterates over these attributes and checks if each attribute is a `functools.partial` object or a method attribute. If it is a `functools.partial` object, it retrieves the method from the `func` attribute and checks if it is a trainable method using the `trainable_method` function. If it is a trainable method, it adds the method's `parameter` attribute to the `parameters` dictionary with the attribute name as the key. If it is a method attribute, it checks if it is a trainable method using the `trainable_method` function and adds the method's `parameter` attribute to the `parameters` dictionary with the attribute name as the key. If the attribute is a `ParameterNode`, it adds it to the `parameters` dictionary with the attribute name as the key. If the attribute is a `ParameterContainer`, it adds it to the `parameters` dictionary with the attribute name as the key. Finally, it asserts that all the values in the `parameters` dictionary are instances of `ParameterNode` or `ParameterContainer`.\n\nThe `parameters_dict` method is used to retrieve a dictionary of all the parameters in the model, including both trainable and non-trainable parameters. It is called internally by the `parameters` method to retrieve the parameters dictionary.\n\n**Note**: \n- The `ParameterContainer` class inherits from the `NodeContainer` class, which serves as an identifier for a container of nodes.\n- The `ParameterContainer` class is designed to manage parameter nodes specifically, leveraging the functionality provided by the `NodeContainer` class.\n- When using the `ParameterContainer` class, ensure that the derived classes properly encapsulate parameter nodes to ensure the correct functioning of the `parameters` and `parameters_dict` methods.\n\n**Output Example**:\n```python\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterNode object>,\n    'container1': <ParameterContainer object>,\n    'container2': <ParameterContainer object>\n}\n```"
      ],
      "code_start_line": 18,
      "code_end_line": 55,
      "params": [],
      "have_return": true,
      "code_content": "class ParameterContainer(NodeContainer):\n    \"\"\" A container of parameter nodes. \"\"\"\n\n    def parameters(self):\n        \"\"\" Return a flattned list of all the parameters in the model's\n        parameters_dict, useful for optimization.\"\"\"\n        parameters = []\n        for k, v in self.parameters_dict().items():\n            if isinstance(v, ParameterNode):\n                parameters.append(v)\n            elif isinstance(v, ParameterContainer):\n                parameters.extend(v.parameters())\n            else:\n                raise ValueError(\"The model contains an unknown parameter type.\")\n\n        return parameters\n\n    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for name, attr in inspect.getmembers(self):\n            if isinstance(attr, functools.partial):  # this is a class method\n                method = attr.func.__self__\n                if trainable_method(method):\n                    parameters[name] = method.parameter\n            elif trainable_method(attr):  # method attribute\n                parameters[name] = attr.parameter\n            elif isinstance(attr, ParameterNode):\n                parameters[name] = attr\n            elif isinstance(attr, ParameterContainer):\n                parameters[name] = attr\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n\n        return parameters  # include both trainable and non-trainable parameters\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\containers.py",
        "opto\\trace\\containers.py/Seq",
        "opto\\trace\\containers.py/Seq/parameters_dict",
        "opto\\trace\\containers.py/Map",
        "opto\\trace\\containers.py/Map/parameters_dict",
        "opto\\trace\\modules.py/Module",
        "opto\\trace\\modules.py/Module/_set"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/NodeContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "parameters",
      "md_content": [
        "**parameters**: The function of parameters is to return a flattened list of all the parameters in the model's parameters_dict, useful for optimization.\n\n**parameters**: The parameters of this function.\n· self: The instance of the ParameterContainer class.\n\n**Code Description**: The parameters function is designed to collect and return a flattened list of all parameters contained within a model's parameters_dict. This is particularly useful for optimization tasks where a single list of parameters is required.\n\n1. The function initializes an empty list named parameters.\n2. It then iterates over each key-value pair in the dictionary returned by the parameters_dict method of the ParameterContainer instance.\n3. For each key-value pair:\n   - If the value is an instance of ParameterNode, it appends the value to the parameters list.\n   - If the value is an instance of ParameterContainer, it extends the parameters list with the result of calling the parameters method on that value.\n   - If the value is neither a ParameterNode nor a ParameterContainer, it raises a ValueError indicating that the model contains an unknown parameter type.\n4. Finally, the function returns the populated parameters list.\n\nThis method ensures that all parameters, whether they are directly part of the ParameterContainer or nested within other ParameterContainers, are included in a single, flattened list.\n\n**Note**:\n- The function relies on the parameters_dict method to retrieve the dictionary of parameters.\n- It assumes that all values in the parameters_dict are either instances of ParameterNode or ParameterContainer. Any other type will result in a ValueError.\n- This function is essential for optimization processes that require a single list of all model parameters.\n\n**Output Example**:\nA possible return value of the parameters function could be:\n[\n    <ParameterNode object at 0x...>,\n    <ParameterNode object at 0x...>,\n    ...\n]"
      ],
      "code_start_line": 21,
      "code_end_line": 33,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parameters(self):\n        \"\"\" Return a flattned list of all the parameters in the model's\n        parameters_dict, useful for optimization.\"\"\"\n        parameters = []\n        for k, v in self.parameters_dict().items():\n            if isinstance(v, ParameterNode):\n                parameters.append(v)\n            elif isinstance(v, ParameterContainer):\n                parameters.extend(v.parameters())\n            else:\n                raise ValueError(\"The model contains an unknown parameter type.\")\n\n        return parameters\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_containers.py",
        "tests\\unit_tests\\test_modules.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer/parameters_dict",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "parameters_dict",
      "md_content": [
        "**parameters_dict**: The function of parameters_dict is to return a dictionary of all the parameters in the model, including both trainable and non-trainable parameters.\n\n**parameters**:\n- self: The instance of the ParameterContainer class.\n\n**Code Description**: The parameters_dict method constructs a dictionary of all parameters in the model, including both trainable and non-trainable parameters. It iterates over the attributes of the ParameterContainer instance and checks each attribute using the trainable_method function. If the attribute is a class method and is trainable, it adds the method's \"parameter\" attribute to the dictionary. If the attribute is a method and is trainable, it adds the method's \"parameter\" attribute to the dictionary. If the attribute is a ParameterNode, it adds the ParameterNode object to the dictionary. If the attribute is a ParameterContainer, it adds the ParameterContainer object to the dictionary.\n\nThe method then asserts that all values in the dictionary are either instances of ParameterNode or ParameterContainer.\n\nFinally, the method returns the constructed dictionary, which includes both trainable and non-trainable parameters.\n\n**Note**:\n- The trainable_method function is used to determine if a given method is callable and has an attribute named \"parameter\".\n- The method does not check the type or validity of the \"parameter\" attribute, only its presence.\n\n**Output Example**:\n{\n    'param1': <ParameterNode object>,\n    'param2': <ParameterContainer object>,\n    ...\n}"
      ],
      "code_start_line": 35,
      "code_end_line": 55,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parameters_dict(self):\n        \"\"\" Return a dictionary of all the parameters in the model, including\n        both trainable and non-trainable parameters. The dict contains\n        ParameterNodes or ParameterContainers.\n        \"\"\"\n        parameters = {}\n        for name, attr in inspect.getmembers(self):\n            if isinstance(attr, functools.partial):  # this is a class method\n                method = attr.func.__self__\n                if trainable_method(method):\n                    parameters[name] = method.parameter\n            elif trainable_method(attr):  # method attribute\n                parameters[name] = attr.parameter\n            elif isinstance(attr, ParameterNode):\n                parameters[name] = attr\n            elif isinstance(attr, ParameterContainer):\n                parameters[name] = attr\n\n        assert all(isinstance(v, (ParameterNode, ParameterContainer)) for v in parameters.values())\n\n        return parameters  # include both trainable and non-trainable parameters\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\modules.py/ParameterContainer/parameters",
        "opto\\trace\\modules.py/Module/save",
        "opto\\trace\\modules.py/Module/_set",
        "tests\\unit_tests\\test_modules.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/trainable_method",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "model",
      "md_content": [
        "**model**: The function of model is to wrap a class with a decorator to help collect parameters for the optimizer. This decorated class cannot be pickled.\n\n**parameters**: The parameters of this Function.\n· cls: The class to be wrapped by the decorator.\n\n**Code Description**: The `model` function is a decorator designed to wrap a given class, enhancing it to collect parameters for an optimizer. When a class is decorated with `model`, it is wrapped inside a new class called `ModelWrapper`, which inherits from both `Module` and the original class (`cls`). This allows the optimizer to access and manage the parameters of the class more effectively. However, it is important to note that classes decorated with `model` cannot be pickled, which may affect serialization and deserialization processes.\n\nThe function is utilized in the project to facilitate the optimization process by ensuring that the parameters of the decorated class are properly managed. Although the specific usage within the project is not detailed in the provided documents, it is clear that the `model` function plays a crucial role in parameter management for optimization tasks.\n\n**Note**: \n- Classes decorated with `model` cannot be pickled.\n- Ensure that the class to be wrapped is compatible with the `Module` class.\n\n**Output Example**: \nWhen a class `MyClass` is decorated with `model`, the resulting class `ModelWrapper` will inherit from both `Module` and `MyClass`, allowing the optimizer to collect and manage its parameters. The decorated class will look like this:\n\n```python\n@model\nclass MyClass:\n    # class definition\n```\n\nThis will result in a new class `ModelWrapper` that combines the functionalities of `Module` and `MyClass`."
      ],
      "code_start_line": 58,
      "code_end_line": 66,
      "params": [
        "cls"
      ],
      "have_return": true,
      "code_content": "def model(cls):\n    \"\"\"\n    Wrap a class with this decorator. This helps collect parameters for the optimizer. This decorated class cannot be pickled.\n    \"\"\"\n\n    class ModelWrapper(Module, cls):\n        pass\n\n    return ModelWrapper\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "tests\\unit_tests\\test_modules.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "ModelWrapper",
      "md_content": [
        "**ModelWrapper**: The function of ModelWrapper is to serve as a specialized module that inherits functionalities from both the `Module` class and another class specified by `cls`.\n\n**attributes**: The attributes of this Class.\n- No specific attributes are defined within the provided code snippet.\n\n**Code Description**: The `ModelWrapper` class is designed to extend the capabilities of the `Module` class by also inheriting from another class specified by `cls`. This dual inheritance allows `ModelWrapper` to combine the functionalities of both parent classes, making it a versatile component in the project.\n\nThe `Module` class, from which `ModelWrapper` inherits, serves as a container for parameter nodes and provides essential methods such as `forward`, `__call__`, `save`, `load`, and `_set`. These methods facilitate the forward pass of the model, allow the module to be called as a function, and enable saving and loading of model parameters.\n\nBy inheriting from `Module`, `ModelWrapper` gains access to these methods and functionalities. Additionally, the inheritance from `cls` allows `ModelWrapper` to incorporate any additional methods and attributes defined in `cls`, thereby enhancing its capabilities.\n\n**Note**:\n- The `ModelWrapper` class does not define any new attributes or methods within the provided code snippet. It relies on the inherited functionalities from `Module` and `cls`.\n- The `forward` method from the `Module` class must be implemented by any derived class to define the forward pass of the model.\n- The `save` and `load` methods from the `Module` class can be used to save and load the parameters of the model to/from a file.\n- The `_set` method from the `Module` class is a helper method used by the `load` method to set the parameters of the model.\n\nIn summary, `ModelWrapper` is a flexible and extendable class that combines the functionalities of the `Module` class and another specified class, making it a powerful tool for managing model parameters and performing forward passes in a neural network or similar computational model."
      ],
      "code_start_line": 63,
      "code_end_line": 64,
      "params": [],
      "have_return": false,
      "code_content": "    class ModelWrapper(Module, cls):\n        pass\n",
      "name_column": 10,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/Module"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Module",
      "md_content": [
        "**Module**: Module\n\n**attributes**:\n- No specific attributes are defined within the provided code snippet.\n\n**Code Description**:\nThe `Module` class is a subclass of `ParameterContainer` and serves as a container for parameter nodes. It provides a `forward` method that needs to be implemented by derived classes. The `forward` method is responsible for performing the forward pass of the model.\n\nThe `forward` method raises a `NotImplementedError` as it is meant to be overridden by derived classes. This method takes in `*args` and `**kwargs` as input parameters and should return the output of the forward pass.\n\nThe `__call__` method is a convenience method that allows the `Module` object to be called as a function. It simply calls the `forward` method with the provided arguments and returns the result.\n\nThe `save` method is used to save the parameters of the model to a file. It takes a `file_name` parameter as input and creates the necessary directory structure if it doesn't already exist. It then serializes the model's parameters using the `pickle` module and saves them to the specified file.\n\nThe `load` method is used to load the parameters of the model from a file. It takes a `file_name` parameter as input and deserializes the parameters using the `pickle` module. The loaded parameters are then set as the new parameters of the model using the `_set` method.\n\nThe `_set` method is a helper method used by the `load` method to set the parameters of the model from a dictionary. It takes a `new_parameters` parameter, which can be either a `ParameterContainer` or a parameter dictionary. It asserts that the `new_parameters` is of the correct type and then updates the model's parameters accordingly.\n\n**Note**:\n- The `Module` class inherits from the `ParameterContainer` class, which serves as a container for parameter nodes.\n- The `forward` method needs to be implemented by derived classes to define the forward pass of the model.\n- The `save` and `load` methods can be used to save and load the parameters of the model to/from a file.\n- The `_set` method is a helper method used by the `load` method to set the parameters of the model.\n\n**Output Example**:\n```python\nmodel = Module()\nmodel.save(\"model_params.pkl\")\nmodel.load(\"model_params.pkl\")\nmodel.forward(input_data)\n```"
      ],
      "code_start_line": 69,
      "code_end_line": 114,
      "params": [],
      "have_return": true,
      "code_content": "class Module(ParameterContainer):\n    \"\"\" Module is a ParameterContainer which has a forward method. \"\"\"\n\n    def forward(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def __call__(self, *args, **kwargs):\n        return self.forward(*args, **kwargs)\n\n    def save(self, file_name):\n        \"\"\" Save the parameters of the model to a file.\"\"\"\n        # detect if the directory exists\n        directory = os.path.dirname(file_name)\n        if directory != \"\":\n            os.makedirs(directory, exist_ok=True)\n        with open(file_name, \"wb\") as f:\n            pickle.dump(self.parameters_dict(), f)\n\n    def load(self, file_name):\n        \"\"\" Load the parameters of the model from a file.\"\"\"\n        with open(file_name, \"rb\") as f:\n            loaded_data = pickle.load(f)\n        self._set(loaded_data)\n\n    def _set(self, new_parameters):\n        \"\"\" Set the parameters of the model from a dictionary.\n        new_parameters is a ParamterContainer or a parameter dict.\n        \"\"\"\n        assert isinstance(new_parameters, (dict, ParameterContainer))\n        if isinstance(new_parameters, ParameterContainer):\n            new_parameters_dict = new_parameters.parameters_dict()\n        else:\n            new_parameters_dict = new_parameters  # dictionary\n\n        parameters_dict = self.parameters_dict()\n\n        assert all(k in new_parameters_dict for k in\n                   parameters_dict.keys()), \"\"\" Not all model parameters are in the new parameters dictionary. \"\"\"\n\n        for k, v in new_parameters_dict.items():\n            if k in parameters_dict:  # if the parameter exists\n                assert isinstance(v, (ParameterNode, ParameterContainer))\n                parameters_dict[k]._set(v)\n            else:  # if the parameter does not exist\n                assert k not in self.__dict__\n                setattr(self, k, v)",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule",
        "opto\\trace\\modules.py/model/ModelWrapper",
        "tests\\unit_tests\\test_modules.py",
        "tests\\unit_tests\\test_modules.py/BaseModule"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [
        "**forward**: The function of forward is to serve as an abstract method that must be implemented by subclasses of the Module class.\n\n**parameters**: The parameters of this Function.\n· args: Variable length argument list.\n· kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The forward function is defined as a method within a class, and it is designed to be overridden by subclasses. The method takes any number of positional and keyword arguments, denoted by *args and **kwargs, respectively. However, in its current form, it raises a NotImplementedError, indicating that it is an abstract method. This means that any subclass inheriting from this class must provide its own implementation of the forward method. \n\nThe forward method is called by the __call__ method of the same class. When an instance of the class is called like a function, the __call__ method is invoked, which in turn calls the forward method with the provided arguments. This design pattern is common in frameworks that require a standard interface for processing inputs, such as neural network layers in deep learning libraries.\n\n**Note**: \n- The forward method must be implemented in any subclass; otherwise, calling an instance of the subclass will result in a NotImplementedError.\n- Ensure that the implementation of the forward method in subclasses correctly handles the expected input arguments and performs the desired operations."
      ],
      "code_start_line": 72,
      "code_end_line": 73,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def forward(self, *args, **kwargs):\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\modules.py/Module/__call__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__call__",
      "md_content": [
        "**__call__**: The function of __call__ is to invoke the forward method of the Module class with the provided arguments.\n\n**parameters**: The parameters of this Function.\n· args: Variable length argument list.\n· kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The __call__ method is designed to make instances of the Module class callable like a regular function. When an instance of the Module class is called, the __call__ method is triggered, which in turn calls the forward method with the same arguments. This design pattern is commonly used in frameworks that require a standard interface for processing inputs, such as neural network layers in deep learning libraries.\n\nThe forward method, which must be implemented by any subclass of the Module class, is where the actual processing logic resides. The __call__ method acts as a wrapper that ensures the forward method is executed with the provided arguments.\n\nIn the context of the project, the __call__ method is referenced by the __get__ method in the FunModule class located in opto\\trace\\bundle.py. The __get__ method uses functools.partial to bind the __call__ method to an instance of the Module class, effectively supporting instance methods.\n\n**Note**: \n- The forward method must be implemented in any subclass of the Module class; otherwise, calling an instance of the subclass will result in a NotImplementedError.\n- Ensure that the implementation of the forward method in subclasses correctly handles the expected input arguments and performs the desired operations.\n\n**Output Example**: The return value of the __call__ method depends on the implementation of the forward method in the subclass. For instance, if the forward method is implemented to perform a specific computation, the __call__ method will return the result of that computation."
      ],
      "code_start_line": 75,
      "code_end_line": 76,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __call__(self, *args, **kwargs):\n        return self.forward(*args, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py/FunModule/__get__"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/Module/forward"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "save",
      "md_content": [
        "**save**: The function of save is to save the parameters of the model to a specified file.\n\n**parameters**: The parameters of this Function.\n· file_name: The name of the file where the model parameters will be saved.\n\n**Code Description**: The save function is designed to persist the parameters of a model to a file. It first checks if the directory specified in the file_name exists. If the directory does not exist, it creates the directory using os.makedirs with the exist_ok=True flag to avoid raising an error if the directory already exists. The function then opens the specified file in binary write mode (\"wb\") and uses the pickle module to serialize and save the model's parameters.\n\nThe parameters to be saved are obtained by calling the parameters_dict method on the instance (self). This method returns a dictionary containing all the parameters of the model, including both trainable and non-trainable parameters. The dictionary is then serialized and written to the file using pickle.dump.\n\n**Note**: \n- Ensure that the file_name provided includes the correct path where the file should be saved.\n- The directory will be created if it does not exist, so there is no need to manually create it beforehand.\n- The parameters_dict method must be correctly implemented in the model to return all necessary parameters for saving.\n- The file is opened in binary mode, so it will not be human-readable. Use pickle.load to deserialize the file when needed."
      ],
      "code_start_line": 78,
      "code_end_line": 85,
      "params": [
        "self",
        "file_name"
      ],
      "have_return": false,
      "code_content": "    def save(self, file_name):\n        \"\"\" Save the parameters of the model to a file.\"\"\"\n        # detect if the directory exists\n        directory = os.path.dirname(file_name)\n        if directory != \"\":\n            os.makedirs(directory, exist_ok=True)\n        with open(file_name, \"wb\") as f:\n            pickle.dump(self.parameters_dict(), f)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer/parameters_dict"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "load",
      "md_content": [
        "**load**: The function of load is to load the parameters of the model from a file.\n\n**parameters**: The parameters of this function.\n- file_name: The name of the file from which to load the model parameters.\n\n**Code Description**: The load function is responsible for loading the parameters of a model from a specified file. It takes a single parameter, file_name, which is the name of the file containing the model parameters.\n\nThe function opens the specified file in binary read mode (\"rb\") using a with statement to ensure the file is properly closed after reading. It then uses the pickle.load function to deserialize the contents of the file into a Python object, which is stored in the variable loaded_data.\n\nAfter successfully loading the data, the function calls the _set method on the current instance (self) with loaded_data as the argument. The _set method is responsible for setting the parameters of the model using the loaded data. It ensures that the new parameters are valid and consistent with the existing parameters of the model by performing various checks and updates.\n\n**Note**:\n- The file specified by file_name must exist and be accessible for reading.\n- The contents of the file must be a valid serialized representation of the model parameters.\n- The _set method is used to update the model's parameters with the loaded data, ensuring consistency and validity.\n- Proper error handling should be implemented to handle cases where the file cannot be read or the contents are not as expected."
      ],
      "code_start_line": 87,
      "code_end_line": 91,
      "params": [
        "self",
        "file_name"
      ],
      "have_return": false,
      "code_content": "    def load(self, file_name):\n        \"\"\" Load the parameters of the model from a file.\"\"\"\n        with open(file_name, \"rb\") as f:\n            loaded_data = pickle.load(f)\n        self._set(loaded_data)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/Module/_set"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_set",
      "md_content": [
        "**_set**: The function of _set is to set the parameters of the model from a dictionary.\n\n**parameters**:\n- self: The instance of the Module class.\n- new_parameters: A ParameterContainer or a parameter dictionary containing the new parameters.\n\n**Code Description**: The _set function is responsible for setting the parameters of the model from a dictionary. It takes in the self parameter, which represents the instance of the Module class, and the new_parameters parameter, which can be either a ParameterContainer or a parameter dictionary.\n\nThe function first asserts that the new_parameters parameter is an instance of either a dictionary or a ParameterContainer. If it is a ParameterContainer, it retrieves the parameters dictionary using the parameters_dict method. Otherwise, it assumes that new_parameters is already a dictionary.\n\nNext, it retrieves the current parameters dictionary using the parameters_dict method of the self object.\n\nThe function then asserts that all the keys in the new_parameters_dict are present in the parameters_dict. This ensures that all the model parameters are included in the new parameters dictionary.\n\nAfter that, the function iterates over the items in the new_parameters_dict. For each key-value pair, it checks if the key exists in the parameters_dict. If it does, it asserts that the value is an instance of either a ParameterNode or a ParameterContainer. If it is a ParameterNode, it calls the _set method of the corresponding parameter in the parameters_dict, passing the value as the argument. This allows the parameter to update its value. If the key does not exist in the parameters_dict, it asserts that the key is not present in the __dict__ attribute of the self object. If this assertion passes, it sets the attribute of the self object with the key as the attribute name and the value as the attribute value.\n\n**Note**: \n- The _set function is typically used to update the parameters of a model with new values. It ensures that the new parameters are valid and consistent with the existing parameters of the model.\n- The function assumes that the model's parameters are stored in the parameters_dict, which is a dictionary of ParameterNodes or ParameterContainers.\n- It is important to ensure that the new_parameters dictionary contains all the necessary parameters and that their values are of the correct type.\n- The function relies on the _set method of ParameterNode to update the value of a parameter.\n- The function uses the setattr function to dynamically set attributes on the self object."
      ],
      "code_start_line": 93,
      "code_end_line": 114,
      "params": [
        "self",
        "new_parameters"
      ],
      "have_return": false,
      "code_content": "    def _set(self, new_parameters):\n        \"\"\" Set the parameters of the model from a dictionary.\n        new_parameters is a ParamterContainer or a parameter dict.\n        \"\"\"\n        assert isinstance(new_parameters, (dict, ParameterContainer))\n        if isinstance(new_parameters, ParameterContainer):\n            new_parameters_dict = new_parameters.parameters_dict()\n        else:\n            new_parameters_dict = new_parameters  # dictionary\n\n        parameters_dict = self.parameters_dict()\n\n        assert all(k in new_parameters_dict for k in\n                   parameters_dict.keys()), \"\"\" Not all model parameters are in the new parameters dictionary. \"\"\"\n\n        for k, v in new_parameters_dict.items():\n            if k in parameters_dict:  # if the parameter exists\n                assert isinstance(v, (ParameterNode, ParameterContainer))\n                parameters_dict[k]._set(v)\n            else:  # if the parameter does not exist\n                assert k not in self.__dict__\n                setattr(self, k, v)",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\modules.py/Module/load"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/ParameterContainer",
        "opto\\trace\\modules.py/ParameterContainer/parameters_dict",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    }
  ],
  "opto\\trace\\nodes.py": [
    {
      "type": "FunctionDef",
      "name": "node",
      "md_content": [
        "**node**: The function of node is to create a Node object from a message. If the message is already a Node, it will be returned as is. This function is provided for the convenience of the user and should be used instead of directly invoking the Node class.\n\n**parameters**:\n- message: The message to create the Node from.\n- name: (optional) The name of the Node.\n- trainable: (optional) A boolean indicating whether the Node is trainable or not. Default is False.\n- constraint: (optional) A constraint on the Node.\n\n**Code Description**: The node function is a versatile function that allows users to create Node objects from messages. It takes in a message and optional parameters such as name, trainable, and constraint. \n\nThe function first checks if the trainable parameter is True. If it is, it checks if the message is already a Node. If it is, it extracts the underlying data and updates the name if a new name is provided. It then creates a ParameterNode object with the extracted data, name, trainable set to True, and the provided constraint. If the message is not already a Node, it creates a new ParameterNode object with the message as the data, the provided name, trainable set to True, and the provided constraint.\n\nIf the trainable parameter is False, the function checks if the message is already a Node. If it is, it checks if a name is provided. If a name is provided, it issues a warning that the name is ignored because the message is already a Node. It then returns the message as is. If the message is not already a Node, it creates a new Node object with the message as the data, the provided name, and the provided constraint.\n\n**Note**:\n- The node function is a convenient way to create Node objects from messages.\n- The trainable parameter determines whether the created Node is trainable or not.\n- The constraint parameter allows users to specify a constraint on the created Node.\n\n**Output Example**: A possible return value of the node function could be a ParameterNode object with the extracted data, name, trainable set to True, and the provided constraint."
      ],
      "code_start_line": 10,
      "code_end_line": 25,
      "params": [
        "message",
        "name",
        "trainable",
        "constraint"
      ],
      "have_return": true,
      "code_content": "def node(message, name=None, trainable=False, constraint=None):\n    \"\"\"Create a Node from a message. If message is already a Node, return it.\n    This method is for the convenience of the user, it should be used over\n    directly invoking Node.\"\"\"\n    if trainable:\n        if isinstance(message, Node):\n            message = message._data\n            name = name or message.name\n        return ParameterNode(message, name=name, trainable=True, constraint=constraint)\n    else:\n        if isinstance(message, Node):\n            if name is not None:\n                warnings.warn(f\"Name {name} is ignored because message is already a Node.\")\n            return message\n        else:\n            return Node(message, name=name, constraint=constraint)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/forward/create_node",
        "opto\\trace\\bundle.py/FunModule/forward",
        "opto\\trace\\containers.py",
        "opto\\trace\\containers.py/SeqIterable/__next__",
        "opto\\trace\\containers.py/iterate",
        "opto\\trace\\containers.py/DictIterable/__next__",
        "opto\\trace\\nodes.py/Node/getattr",
        "opto\\trace\\nodes.py/Node/call",
        "opto\\trace\\nodes.py/Node/__getitem__",
        "opto\\trace\\nodes.py/Node/__contains__",
        "opto\\trace\\nodes.py/Node/__round__",
        "opto\\trace\\nodes.py/Node/__add__",
        "opto\\trace\\nodes.py/Node/__sub__",
        "opto\\trace\\nodes.py/Node/__mul__",
        "opto\\trace\\nodes.py/Node/__floordiv__",
        "opto\\trace\\nodes.py/Node/__truediv__",
        "opto\\trace\\nodes.py/Node/__mod__",
        "opto\\trace\\nodes.py/Node/__divmod__",
        "opto\\trace\\nodes.py/Node/__pow__",
        "opto\\trace\\nodes.py/Node/__lshift__",
        "opto\\trace\\nodes.py/Node/__rshift__",
        "opto\\trace\\nodes.py/Node/__and__",
        "opto\\trace\\nodes.py/Node/__or__",
        "opto\\trace\\nodes.py/Node/__xor__",
        "opto\\trace\\nodes.py/Node/__lt__",
        "opto\\trace\\nodes.py/Node/__le__",
        "opto\\trace\\nodes.py/Node/__gt__",
        "opto\\trace\\nodes.py/Node/__ge__",
        "opto\\trace\\nodes.py/Node/replace",
        "opto\\trace\\nodes.py/Node/pop",
        "opto\\trace\\trace.py",
        "tests\\unit_tests\\not_covered_usage_cases.py",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_nested_function_visibility",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_succeed",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_with_class_success",
        "tests\\unit_tests\\test_apply_op.py",
        "tests\\unit_tests\\test_apply_op.py/SubContainer/__init__",
        "tests\\unit_tests\\test_apply_op.py/Container/__init__",
        "tests\\unit_tests\\test_backward.py",
        "tests\\unit_tests\\test_bundle.py",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_bundle.py/run/Foo/__init__",
        "tests\\unit_tests\\test_bundle.py/run/Foo/__init__",
        "tests\\unit_tests\\test_bundle.py/run/modify_global",
        "tests\\unit_tests\\test_containers.py",
        "tests\\unit_tests\\test_error_handling.py",
        "tests\\unit_tests\\test_modules.py",
        "tests\\unit_tests\\test_modules.py/BaseModule/__init__",
        "tests\\unit_tests\\test_modules.py/ChildModule/__init__",
        "tests\\unit_tests\\test_modules.py/BaseClass/__init__",
        "tests\\unit_tests\\test_modules.py/ChildClass/__init__",
        "tests\\unit_tests\\test_nodes.py",
        "tests\\unit_tests\\test_optimizer.py",
        "tests\\unit_tests\\test_python_funcs.py",
        "tests\\unit_tests\\test_python_funcs.py/test_get_env",
        "tests\\unit_tests\\test_python_funcs.py/test_apply_fn_dict_key",
        "tests\\unit_tests\\test_python_funcs.py/test_recurse",
        "tests\\unit_tests\\test_python_funcs.py/test_find",
        "tests\\unit_tests\\test_to_data.py",
        "tests\\unit_tests\\test_to_data.py/simple_test_unnested",
        "tests\\unit_tests\\test_to_data.py/simple_test_node_over_container",
        "tests\\unit_tests\\test_to_data.py/simple_test_container_over_node",
        "tests\\unit_tests\\test_to_data.py/test_container_over_container_over_node",
        "tests\\unit_tests\\test_to_data.py/test_node_over_container_over_container_over_node"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Graph",
      "md_content": [
        "**Graph**: The function of Graph is to serve as a registry of all the nodes, forming a Directed Acyclic Graph (DAG).\n\n**attributes**: The attributes of this Class.\n· TRACE: A class-level attribute that determines whether the graph is traced when creating MessageNode. It is set to True by default.\n· _nodes: An instance-level attribute, which is a defaultdict of lists, used as a lookup table to find nodes by name.\n\n**Code Description**: The Graph class is designed to manage and organize nodes in a Directed Acyclic Graph (DAG). It provides methods to register nodes, clear the graph, retrieve nodes by name, and identify root nodes.\n\n- The `__init__` method initializes the Graph object, setting up the `_nodes` attribute as a defaultdict of lists to store nodes by their names.\n\n- The `clear` method removes all nodes from the graph by deleting each node and reinitializing the `_nodes` attribute.\n\n- The `register` method adds a node to the graph. It ensures the node is an instance of the Node class and that its name follows the expected format (containing a colon). The method also handles name scoping and assigns a unique name to the node based on its position in the list.\n\n- The `get` method retrieves a node by its name, which includes an identifier. It splits the name to find the correct node in the `_nodes` dictionary.\n\n- The `roots` property returns a list of all root nodes in the graph. A root node is identified by its `is_root` attribute.\n\n- The `__str__` method provides a string representation of the `_nodes` attribute, useful for debugging and logging.\n\n- The `__len__` method returns the total number of nodes in the graph by summing the lengths of all lists in the `_nodes` dictionary.\n\n**Note**: \n- The `TRACE` attribute controls whether the graph is traced during the creation of MessageNode instances.\n- The `register` method assumes that elements in `_nodes` are never removed, which is important for maintaining the integrity of node names.\n\n**Output Example**: \n- When calling the `__str__` method, the output might look like:\n  ```\n  defaultdict(<class 'list'>, {'node1': [<Node object at 0x...>], 'node2': [<Node object at 0x...>]})\n  ```\n- When calling the `__len__` method, the output might be:\n  ```\n  5\n  ```"
      ],
      "code_start_line": 31,
      "code_end_line": 71,
      "params": [],
      "have_return": true,
      "code_content": "class Graph:\n    \"\"\"This a registry of all the nodes. All the nodes form a Directed Acyclic Graph.\"\"\"\n\n    TRACE = True  # When True, we trace the graph when creating MessageNode. When False, we don't trace the graph.\n\n    def __init__(self):\n        self._nodes = defaultdict(list)  # a lookup table to find nodes by name\n        # self._levels = defaultdict(list)  # a lookup table to find nodes at a certain level # TODO do we need this?\n\n    def clear(self):\n        for node in self._nodes.values():\n            del node\n        self._nodes = defaultdict(list)\n        # self._levels = defaultdict(list)\n\n    def register(self, node):\n        assert isinstance(node, Node)\n        assert len(node.name.split(\":\")) == 2\n        name, _ = node.name.split(\":\")\n        if len(NAME_SCOPES) > 0:\n            name = NAME_SCOPES[-1] + \"/\" + name\n        self._nodes[name].append(node)\n        node._name = (\n            name + \":\" + str(len(self._nodes[name]) - 1)\n        )  # NOTE assume elements in self._nodes never get removed.\n        # self._levels[node._level].append(node)\n\n    def get(self, name):\n        name, id = name.split(\":\")\n        return self._nodes[name][int(id)]\n\n    @property\n    def roots(self):\n        return [v for vv in self._nodes.values() for v in vv if v.is_root]\n\n    def __str__(self):\n        return str(self._nodes)\n\n    def __len__(self):\n        # This is the number of nodes in the graph\n        return sum([len(v) for v in self._nodes.values()])\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the Graph class by setting up an internal data structure to store nodes.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The __init__ function initializes an instance of the Graph class. It sets up an internal attribute `_nodes`, which is a defaultdict with lists as the default factory. This defaultdict will be used as a lookup table to store and retrieve nodes by their names. Each key in the `_nodes` dictionary represents a node name, and the corresponding value is a list of nodes associated with that name. This structure allows for efficient organization and retrieval of nodes within the graph.\n\n**Note**: \n- The defaultdict from the collections module is used to automatically handle missing keys by initializing them with an empty list.\n- This function does not require any arguments and is called automatically when a new instance of the Graph class is created."
      ],
      "code_start_line": 36,
      "code_end_line": 37,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        self._nodes = defaultdict(list)  # a lookup table to find nodes by name\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "clear",
      "md_content": [
        "**clear**: The function of clear is to remove all nodes from the graph and reset the internal node storage.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters other than the implicit self parameter.\n\n**Code Description**: The clear function is designed to empty the graph of all its nodes. It iterates over the current nodes stored in the _nodes attribute, which is a dictionary, and deletes each node. After all nodes have been deleted, it reinitializes the _nodes attribute to an empty defaultdict of lists. This ensures that the graph is completely cleared and ready to be repopulated with new nodes if necessary.\n\nThe function is called in unit tests located in tests\\unit_tests\\test_backward.py and tests\\unit_tests\\test_optimizer.py. These tests likely use the clear function to reset the state of the graph between test cases, ensuring that each test runs with a clean slate and is not affected by the state left by previous tests.\n\n**Note**: \n- This function should be used with caution as it irreversibly deletes all nodes in the graph.\n- After calling clear, any references to the previously stored nodes will become invalid.\n- Ensure that any necessary data is saved or processed before calling this function, as it will reset the graph's state completely."
      ],
      "code_start_line": 40,
      "code_end_line": 43,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def clear(self):\n        for node in self._nodes.values():\n            del node\n        self._nodes = defaultdict(list)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_backward.py",
        "tests\\unit_tests\\test_optimizer.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "register",
      "md_content": [
        "**register**: The function of register is to add a node to the graph.\n\n**parameters**:\n- self: The instance of the class.\n- node: The node object to be registered in the graph.\n\n**Code Description**:\nThe `register` function is a method of the `Graph` class in the `nodes.py` file of the `trace` module. It is used to add a node to the graph. The function takes in the `self` parameter, which represents the instance of the class, and the `node` parameter, which is the node object to be registered.\n\nThe function first checks if the `node` parameter is an instance of the `Node` class using the `isinstance` function. If it is not, an `AssertionError` is raised.\n\nNext, the function checks if the name of the node contains exactly one \":\" character by splitting the name using the \":\" delimiter and checking the length of the resulting list. If the length is not equal to 2, an `AssertionError` is raised. This check ensures that the name of the node follows the required format.\n\nAfter that, the function splits the name of the node using the \":\" delimiter and assigns the first part of the split to the `name` variable. This is done to separate the name from the version number.\n\nThe function then checks if there are any name scopes defined in the `NAME_SCOPES` list. If the length of the list is greater than 0, the name is prefixed with the last scope in the list followed by a \"/\". This allows for scoping of node names.\n\nFinally, the function adds the node to the `_nodes` dictionary using the modified name as the key. The `_name` attribute of the node is set to the modified name followed by the index of the node in the list of nodes with the same name. This index is obtained by subtracting 1 from the length of the list of nodes with the same name.\n\n**Note**:\n- The `register` function should only be called after the node has been properly initialized and its name has been set.\n- The function assumes that elements in the `_nodes` dictionary never get removed.\n\n**Output Example**:\nIf the name of the node is \"node:0\", the `register` function will add the node to the `_nodes` dictionary with the key \"node\" and set the `_name` attribute of the node to \"node:0\"."
      ],
      "code_start_line": 46,
      "code_end_line": 55,
      "params": [
        "self",
        "node"
      ],
      "have_return": false,
      "code_content": "    def register(self, node):\n        assert isinstance(node, Node)\n        assert len(node.name.split(\":\")) == 2\n        name, _ = node.name.split(\":\")\n        if len(NAME_SCOPES) > 0:\n            name = NAME_SCOPES[-1] + \"/\" + name\n        self._nodes[name].append(node)\n        node._name = (\n            name + \":\" + str(len(self._nodes[name]) - 1)\n        )  # NOTE assume elements in self._nodes never get removed.\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/AbstractNode/__init__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get",
      "md_content": [
        "**get**: The function of get is to retrieve a specific node from the graph based on a given name and identifier.\n\n**parameters**: The parameters of this Function.\n· name: A string in the format \"name:id\", where \"name\" is the name of the node and \"id\" is the identifier of the node.\n\n**Code Description**: The get function is designed to extract and return a specific node from a graph structure. The input parameter 'name' is expected to be a string formatted as \"name:id\". The function first splits this string into two parts: 'name' and 'id', using the colon (\":\") as the delimiter. The 'name' part represents the name of the node, and the 'id' part represents the identifier of the node, which is then converted to an integer. The function then accesses the '_nodes' dictionary attribute of the graph object, using the 'name' as the key to retrieve the list of nodes associated with that name. Finally, it returns the node at the position specified by the integer 'id' within that list.\n\n**Note**: \n- Ensure that the 'name' parameter is correctly formatted as \"name:id\" before calling this function.\n- The function assumes that the '_nodes' attribute is a dictionary where each key is a node name and the corresponding value is a list of nodes.\n- The 'id' should be a valid index within the list of nodes for the given 'name'.\n\n**Output Example**: \nIf the '_nodes' dictionary is structured as follows:\n```python\n_nodes = {\n    \"nodeA\": [\"nodeA_0\", \"nodeA_1\"],\n    \"nodeB\": [\"nodeB_0\"]\n}\n```\nCalling `get(\"nodeA:1\")` would return `\"nodeA_1\"`."
      ],
      "code_start_line": 58,
      "code_end_line": 60,
      "params": [
        "self",
        "name"
      ],
      "have_return": true,
      "code_content": "    def get(self, name):\n        name, id = name.split(\":\")\n        return self._nodes[name][int(id)]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "roots",
      "md_content": [
        "**roots**: The function of roots is to return a list of root nodes from the graph.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The `roots` function iterates over the values in the `_nodes` dictionary of the `Graph` object. The `_nodes` dictionary contains lists of nodes. For each node in these lists, the function checks if the node is a root node by evaluating the `is_root` attribute of the node. If the `is_root` attribute is `True`, the node is included in the resulting list. The function ultimately returns a list of all nodes that are identified as root nodes.\n\n**Note**: \n- Ensure that the nodes in the `_nodes` dictionary have the `is_root` attribute properly set to `True` for root nodes and `False` for non-root nodes.\n- The function assumes that `_nodes` is a dictionary where the values are lists of node objects.\n\n**Output Example**: \nIf the `_nodes` dictionary contains the following structure:\n```python\n_nodes = {\n    'group1': [Node1, Node2],\n    'group2': [Node3, Node4]\n}\n```\nand `Node1` and `Node3` have their `is_root` attribute set to `True`, while `Node2` and `Node4` have it set to `False`, the `roots` function will return:\n```python\n[Node1, Node3]\n```"
      ],
      "code_start_line": 63,
      "code_end_line": 64,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def roots(self):\n        return [v for vv in self._nodes.values() for v in vv if v.is_root]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to return a string representation of the Graph object.\n\n**parameters**: The parameters of this Function.\n· None: This method does not take any parameters.\n\n**Code Description**: The __str__ method is a special method in Python that is used to define the string representation of an object. In this implementation, the __str__ method returns the string representation of the `_nodes` attribute of the Graph object. The `_nodes` attribute is expected to be a collection (such as a list or dictionary) that holds the nodes of the graph. By converting `_nodes` to a string, the method provides a human-readable format of the graph's nodes, which can be useful for debugging and logging purposes.\n\n**Note**: \n- Ensure that the `_nodes` attribute is properly initialized and contains the nodes of the graph before calling the __str__ method.\n- The readability and usefulness of the output depend on the structure and content of the `_nodes` attribute.\n\n**Output Example**: \nIf the `_nodes` attribute is a list of node names, such as `['A', 'B', 'C']`, the __str__ method will return the string \"['A', 'B', 'C']\". If `_nodes` is a dictionary representing nodes and their connections, such as `{'A': ['B', 'C'], 'B': ['A'], 'C': ['A']}`, the method will return the string \"{'A': ['B', 'C'], 'B': ['A'], 'C': ['A']}\"."
      ],
      "code_start_line": 66,
      "code_end_line": 67,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self):\n        return str(self._nodes)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__len__",
      "md_content": [
        "**__len__**: The function of __len__ is to return the number of nodes in the graph.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Graph class.\n\n**Code Description**: The __len__ method calculates the total number of nodes in the graph. It does this by iterating over the values in the self._nodes dictionary, where each value is a list representing the connections or edges of a particular node. The method uses a list comprehension to get the length of each list (i.e., the number of connections for each node) and then sums these lengths to get the total number of nodes. Finally, it returns this sum as the result.\n\n**Note**: This method assumes that the self._nodes attribute is a dictionary where each key is a node and each value is a list of connections for that node. The method will not work correctly if self._nodes is not structured in this way.\n\n**Output Example**: If the graph has 3 nodes with the following connections:\n- Node A connected to Node B and Node C\n- Node B connected to Node A\n- Node C connected to Node A\n\nThe return value of __len__ would be 3."
      ],
      "code_start_line": 69,
      "code_end_line": 71,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __len__(self):\n        # This is the number of nodes in the graph\n        return sum([len(v) for v in self._nodes.values()])\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "AbstractNode",
      "md_content": [
        "**AbstractNode**: The function of AbstractNode is to represent an abstract data node in a directed graph.\n\n**attributes**:\n- `data`: The data stored in the node.\n- `parents`: The list of parent nodes.\n- `children`: The list of child nodes.\n- `name`: The name of the node.\n- `py_name`: The name of the node without the \":\" character.\n- `id`: The ID of the node.\n- `level`: The level of the node in the graph.\n- `is_root`: A boolean indicating whether the node is a root node.\n- `is_leaf`: A boolean indicating whether the node is a leaf node.\n\n**Code Description**: The `AbstractNode` class represents an abstract data node in a directed graph. It is a generic class that can store any type of data. The node can have multiple parents and children, forming a directed graph structure. The node has a name, which is used to identify it within the graph. The `py_name` attribute is the same as the name attribute, but with the \":\" character removed. The `id` attribute is extracted from the name and represents a version number.\n\nThe node can be initialized with a value, an optional name, and an optional trainable flag. If the value is an instance of the `Node` class, the node will be initialized as a reference to that node, otherwise, the value will be stored directly in the node. The default name is generated based on the type of the value and a version number.\n\nThe `AbstractNode` class provides several properties to access its attributes. The `data` property allows access to the stored data. If the node is being traced within a context, the `data` property adds the node to the list of used nodes. The `parents` property returns a list of parent nodes, and the `children` property returns a list of child nodes. The `name` property returns the name of the node, and the `py_name` property returns the name without the \":\" character. The `id` property returns the version number extracted from the name. The `level` property returns the level of the node in the graph. The `is_root` property returns True if the node has no parents, and the `is_leaf` property returns True if the node has no children.\n\nThe `AbstractNode` class also provides internal methods to add parents and children to the node. The `_add_child` method adds a child node to the node's list of children. The `_add_parent` method adds a parent node to the node's list of parents and updates the level of the node based on the parent's level.\n\nThe `AbstractNode` class overrides the `__str__` method to provide a string representation of the node. The representation includes the name, the type of the data, and the data itself.\n\nThe `AbstractNode` class implements the `__deepcopy__` method to create a deep copy of the node. This allows the node to be detached from the original graph.\n\nThe `AbstractNode` class provides comparison methods `lt` and `gt` to compare the levels of two nodes.\n\n**Note**: The `AbstractNode` class is meant to be subclassed and extended to create specific types of nodes.\n\n**Output Example**:\n```\nNode: (node_name, dtype=<class 'int'>, data=10)\n```"
      ],
      "code_start_line": 81,
      "code_end_line": 173,
      "params": [],
      "have_return": true,
      "code_content": "class AbstractNode(Generic[T]):\n    \"\"\"An abstract data node in a directed graph (parents <-- children).\"\"\"\n\n    def __init__(self, value, *, name=None, trainable=False) -> None:\n        self._parents = []\n        self._children = []\n        self._level = 0  # roots are at level 0\n        default_name = str(type(value).__name__) + \":0\" if name is None else name + \":0\"  # name:version\n        if isinstance(value, Node):  # just a reference\n            self._data = value._data\n            self._name = value._name if name is None else default_name\n        else:\n            self._data = value\n            self._name = default_name\n        GRAPH.register(self)  # When created, register the node to the graph.\n\n    @property\n    def data(self):\n        if len(USED_NODES) > 0 and GRAPH.TRACE:  # We're within trace_nodes context.\n            USED_NODES[-1].add(self)\n        return self.__getattribute__(\"_data\")\n\n    @property\n    def parents(self):\n        return self._parents\n\n    @property\n    def children(self):\n        return self._children\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def py_name(self):\n        return self.name.replace(\":\", \"\")\n\n    @property\n    def id(self):\n        return self.name.split(\":\")[1]\n\n    @property\n    def level(self):\n        return self._level\n\n    @property\n    def is_root(self):\n        return len(self.parents) == 0\n\n    @property\n    def is_leaf(self):\n        return len(self.children) == 0\n\n    def _add_child(self, child):\n        assert child is not self, \"Cannot add self as a child.\"\n        assert isinstance(child, Node), f\"{child} is not a Node.\"\n        child._add_parent(self)\n\n    def _add_parent(self, parent):\n        assert parent is not self, \"Cannot add self as a parent.\"\n        assert isinstance(parent, Node), f\"{parent} is {type(parent)}, which is not a Node.\"\n        parent._children.append(self)\n        self._parents.append(parent)\n        self._update_level(max(self._level, parent._level + 1))  # Update the level, because the parent is added\n\n    def _update_level(self, new_level):\n        # GRAPH._levels[self._level].remove(self)  # this uses the == operator which compares values. We need to compare references.\n        self._level = new_level\n        # GRAPH._levels[new_level].append(self)\n        # assert all([len(GRAPH._levels[i]) > 0 for i in range(len(GRAPH._levels))]), \"Some levels are empty.\"\n\n    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"Node: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n\n    def __deepcopy__(self, memo):\n        \"\"\"This creates a deep copy of the node, which is detached from the original graph.\"\"\"\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k == \"_parents\" or k == \"_children\":\n                setattr(result, k, [])\n            else:\n                setattr(result, k, copy.deepcopy(v, memo))\n        return result\n\n    def lt(self, other):\n        return -self._level < -other._level\n\n    def gt(self, other):\n        return -self._level > -other._level\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the AbstractNode class.\n\n**parameters**:\n- self: The instance of the class.\n- value: The value to be assigned to the node.\n- name: The name of the node (optional).\n- trainable: A boolean indicating whether the node is trainable or not (optional).\n\n**Code Description**:\nThe `__init__` function is the constructor of the AbstractNode class. It takes in the `self` parameter, which represents the instance of the class, and the `value`, `name`, and `trainable` parameters, which are used to initialize the attributes of the node.\n\nThe function starts by initializing the `_parents`, `_children`, and `_level` attributes to empty lists and 0 respectively. These attributes are used to keep track of the parent and child nodes of the current node, as well as the level of the node in the graph.\n\nNext, the function generates a default name for the node based on the type of the `value` parameter. If the `name` parameter is provided, it is appended to the default name. The format of the name is \"type:version\", where the version is set to 0 if no name is provided.\n\nAfter that, the function checks if the `value` parameter is an instance of the Node class. If it is, the `_data` attribute of the current node is set to the `_data` attribute of the `value` parameter, and the `_name` attribute is set to the `_name` attribute of the `value` parameter if no name is provided. Otherwise, the `_data` attribute is set to the `value` parameter itself, and the `_name` attribute is set to the default name.\n\nFinally, the function calls the `register` function of the GRAPH object to register the current node in the graph.\n\n**Note**:\n- The `__init__` function should be called to create a new instance of the AbstractNode class.\n- The `value` parameter can be any type of value.\n- The `name` parameter is optional and can be used to provide a custom name for the node.\n- The `trainable` parameter is optional and can be used to indicate whether the node is trainable or not.\n- The `register` function should only be called after the node has been properly initialized and its name has been set."
      ],
      "code_start_line": 84,
      "code_end_line": 95,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, value, *, name=None, trainable=False) -> None:\n        self._parents = []\n        self._children = []\n        self._level = 0  # roots are at level 0\n        default_name = str(type(value).__name__) + \":0\" if name is None else name + \":0\"  # name:version\n        if isinstance(value, Node):  # just a reference\n            self._data = value._data\n            self._name = value._name if name is None else default_name\n        else:\n            self._data = value\n            self._name = default_name\n        GRAPH.register(self)  # When created, register the node to the graph.\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Graph/register",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "data",
      "md_content": [
        "**data**: The function of data is to retrieve the internal data of a node, potentially adding the node to a list of used nodes if certain conditions are met.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class that contains this method.\n\n**Code Description**: The data function is designed to return the internal data of a node object. It first checks if there are any nodes in the USED_NODES list and if the GRAPH.TRACE flag is set to True. If both conditions are met, it adds the current node (self) to the USED_NODES list. This indicates that the node is being used within a tracing context. Finally, the function returns the value of the node's internal data by accessing the \"_data\" attribute.\n\nThis function is utilized in various parts of the project to access the data stored within nodes. For instance:\n- In the node_to_function_feedback function in opto\\optimizers\\function_optimizer.py, it retrieves node data to convert a TraceGraph to a FunctionFeedback.\n- In the construct_update_dict method of the FunctionOptimizer class, it converts suggestions into the appropriate data types by accessing node data.\n- In the __next__ method of the SeqIterable class in opto\\trace\\containers.py, it iterates over a wrapped list of nodes and accesses their data.\n- In the ExecutionError class's __init__ and __str__ methods in opto\\trace\\errors.py, it retrieves the data of an exception node to initialize and represent the error.\n- In the get_label method of the NodeVizStyleGuide class in opto\\trace\\nodes.py, it generates labels for nodes by accessing their data.\n- In the _set method of the Node class in opto\\trace\\nodes.py, it sets the value of a node, unwrapping it if necessary.\n- In the trace_fun method of the Foo class in tests\\unit_tests\\test_bundle.py, it prints the data of a node during a trace function.\n\n**Note**: This function assumes that the \"_data\" attribute exists within the node object. If this attribute is not present, an AttributeError will be raised.\n\n**Output Example**: A possible return value of the code could be any data type stored in the \"_data\" attribute of the node, such as an integer, string, list, or custom object. For example, if the \"_data\" attribute contains the integer 42, the function will return 42."
      ],
      "code_start_line": 98,
      "code_end_line": 101,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def data(self):\n        if len(USED_NODES) > 0 and GRAPH.TRACE:  # We're within trace_nodes context.\n            USED_NODES[-1].add(self)\n        return self.__getattribute__(\"_data\")\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_update_dict",
        "opto\\trace\\containers.py/SeqIterable/__next__",
        "opto\\trace\\errors.py/ExecutionError/__init__",
        "opto\\trace\\errors.py/ExecutionError/__str__",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_label",
        "opto\\trace\\nodes.py/Node/_set",
        "tests\\unit_tests\\test_bundle.py/run/Foo/trace_fun",
        "tests\\unit_tests\\test_error_handling.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parents",
      "md_content": [
        "**parents**: The function of parents is to return the parents of the current node.\n**parameters**:\n- self: The current node object.\n**Code Description**:\nThe `parents` function is a method of the `AbstractNode` class in the `nodes.py` module. It returns the parents of the current node. The parents are stored in the `_parents` attribute of the node object.\n\nThe function takes only one parameter, `self`, which refers to the current node object. It is used to access the `_parents` attribute and return its value.\n\nThe `_parents` attribute is a list that contains the parent nodes of the current node. These parent nodes are the nodes that have an edge pointing to the current node in the graph.\n\nThe `parents` function is called by several objects in the project. For example, it is called by the `is_root` function in the `AbstractNode` class, which checks if the current node is a root node by checking if it has any parents. It is also called by the `backward` function in the `Node` class, which performs a backward pass in the graph by propagating feedback from the current node to its parents.\n\n**Note**: The `parents` function is a basic method that provides access to the parents of a node. It is an essential part of the graph structure and is used in various operations such as graph traversal and feedback propagation.\n\n**Output Example**: \nIf the current node has two parents, the `parents` function will return a list containing the two parent nodes."
      ],
      "code_start_line": 104,
      "code_end_line": 105,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parents(self):\n        return self._parents\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\nodes.py/AbstractNode/is_root",
        "opto\\trace\\nodes.py/Node/backward",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/__call__",
        "opto\\trace\\propagators\\propagators.py/SumPropagator/_propagate",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_error_handling.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "children",
      "md_content": [
        "**children**: The function of children is to return the list of child nodes associated with the current node.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The `children` function is a method of the `AbstractNode` class. It returns the `_children` attribute of the instance, which is a list containing the child nodes of the current node. This method is essential for accessing the hierarchical structure of nodes, allowing traversal and manipulation of the node tree.\n\nThe `children` method is called by the `is_leaf` method within the same `AbstractNode` class. The `is_leaf` method uses `children` to determine if the current node is a leaf node (i.e., it has no children). Specifically, `is_leaf` checks if the length of the list returned by `children` is zero, indicating that the node has no children and is therefore a leaf.\n\nAdditionally, the `children` method is referenced in the `opto\\trace\\bundle.py` file and the `tests\\unit_tests\\test_nodes.py` file, although specific details of its usage in these files are not provided.\n\n**Note**: Ensure that the `_children` attribute is properly initialized and maintained within the `AbstractNode` class to avoid unexpected behavior when calling the `children` method.\n\n**Output Example**: A possible return value of the `children` method could be:\n```python\n[<AbstractNode object at 0x...>, <AbstractNode object at 0x...>]\n```\nThis indicates that the current node has two child nodes, each represented by an instance of `AbstractNode`."
      ],
      "code_start_line": 108,
      "code_end_line": 109,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def children(self):\n        return self._children\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\nodes.py/AbstractNode/is_leaf",
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "name",
      "md_content": [
        "**name**: The function of name is name.\n**parameters**:\n- self: The instance of the class.\n**Code Description**:\nThe `name` function is a method of the `AbstractNode` class. It returns the value of the private attribute `_name`. This function is used to retrieve the name of the node.\n\nThe `_name` attribute is set when the node is registered in the graph. It is a combination of the node's name and its index in the list of nodes with the same name. The index is incremented each time a new node with the same name is registered.\n\nThis function is called by various objects in the project. For example, it is called by the `get_fun_name` function in the `function_optimizer.py` file of the `optimizers` module. It is also called by the `register` function in the `nodes.py` file of the `trace` module.\n\nIn the `get_fun_name` function, the `name` function is used to retrieve the name of a `MessageNode` object. If the `info` attribute of the node is a dictionary and it contains the key \"fun_name\", the value associated with that key is returned. Otherwise, the name of the node is split using the \":\" delimiter, and the first part of the split is returned.\n\nIn the `register` function, the `name` function is used to set the `_name` attribute of a node. The name is split using the \":\" delimiter, and the first part of the split is assigned to the `name` variable. If there are any name scopes defined in the `NAME_SCOPES` list, the name is prefixed with the last scope in the list followed by a \"/\". The node is then added to the `_nodes` dictionary using the modified name as the key. The `_name` attribute of the node is set to the modified name followed by the index of the node in the list of nodes with the same name.\n\n**Note**: \n- The `name` function should only be called after the node has been registered in the graph.\n- The `name` function assumes that elements in the `_nodes` dictionary never get removed.\n\n**Output Example**: \nIf the `_name` attribute of a node is \"node:0\", the `name` function will return \"node:0\"."
      ],
      "code_start_line": 112,
      "code_end_line": 113,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def name(self):\n        return self._name\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/get_fun_name",
        "opto\\trace\\nodes.py/Graph/register",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/AbstractNode/id",
        "opto\\trace\\nodes.py/AbstractNode/__str__",
        "opto\\trace\\nodes.py/ParameterNode/__str__",
        "opto\\trace\\nodes.py/MessageNode/__init__",
        "opto\\trace\\nodes.py/MessageNode/__str__",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "py_name",
      "md_content": [
        "**py_name**: The function of py_name is py_name.\n\n**parameters**:\n- self: The instance of the class.\n\n**Code Description**:\nThe `py_name` function is a method of the current class. It returns the value of the `name` attribute after removing the \":\" character. This function is used to modify the name attribute by replacing the \":\" character with an empty string.\n\nThis function is called by various objects in the project. For example, it is called by the `repr_function_call` function in the `function_optimizer.py` file of the `optimizers` module. It is also called by the `node_to_function_feedback` function in the same file.\n\nIn the `repr_function_call` function, the `py_name` function is used to retrieve the name of a `MessageNode` object. The name is then used to construct a function call string.\n\nIn the `node_to_function_feedback` function, the `py_name` function is used to retrieve the name of a node. The name is then used as a key in the `documentation` dictionary.\n\nIn the `summarize` method of the `FunctionOptimizer` class, the `py_name` function is used to retrieve the name of a parameter node. The name is then used to classify the node into variables and others.\n\nIn the `construct_update_dict` method of the `FunctionOptimizer` class, the `py_name` function is used to retrieve the name of a parameter node. The name is then used to construct an update dictionary.\n\nIn the `fun` method of the `FunModule` class, the `py_name` function is used to retrieve the name of a parameter node. The name is then used to define a function.\n\nIn the `get_label` method of the `NodeVizStyleGuide` class, the `py_name` function is used to retrieve the name of a node. The name is then used to construct a label for the node.\n\nIn the `backward` method of the `Node` class, the `py_name` function is used to retrieve the name of a node. The name is then used for visualization purposes.\n\n**Note**:\n- The `py_name` function should only be called after the name attribute has been set.\n- The `py_name` function assumes that the name attribute does not contain any other special characters that need to be replaced.\n\n**Output Example**:\nIf the name attribute of a node is \"node:0\", the `py_name` function will return \"node0\"."
      ],
      "code_start_line": 116,
      "code_end_line": 117,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def py_name(self):\n        return self.name.replace(\":\", \"\")\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/repr_function_call",
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_update_dict",
        "opto\\trace\\bundle.py/FunModule/fun",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_label",
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "id",
      "md_content": [
        "**id**: The function of id is to extract and return the identifier part of the node's name.\n\n**parameters**: The parameters of this Function.\n- self: The instance of the class.\n\n**Code Description**: The `id` function is a method of the `AbstractNode` class. It operates on the `name` attribute of the instance, which is a string formatted as \"name:identifier\". The function splits this string using the colon (\":\") delimiter and returns the second part, which corresponds to the identifier. This identifier is typically a unique part of the node's name, distinguishing it from other nodes with the same base name.\n\nThe `name` attribute is accessed through the `name` method of the `AbstractNode` class, which retrieves the value of the private attribute `_name`. The `id` function relies on the assumption that the `name` attribute follows the \"name:identifier\" format.\n\n**Note**: \n- The `id` function should only be called after the node's `name` attribute has been properly set and follows the expected format.\n- Ensure that the `name` attribute contains a colon (\":\") to avoid index errors during the split operation.\n\n**Output Example**: \nIf the `name` attribute of a node is \"node:0\", the `id` function will return \"0\"."
      ],
      "code_start_line": 120,
      "code_end_line": 121,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def id(self):\n        return self.name.split(\":\")[1]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "level",
      "md_content": [
        "**level**: The function of level is to return the internal level attribute of the object.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The level function is a method that returns the value of the private attribute _level of the object. This method is used to access the internal state of the object, specifically the _level attribute, which is presumably set elsewhere in the class. The function does not modify any state or take any arguments; it simply provides a way to retrieve the current value of _level.\n\nIn the context of its usage within the project, the level function is called by the init_feedback method in the GraphPropagator class, located in the opto\\trace\\propagators\\graph_propagator.py file. The init_feedback method uses the level function to obtain the level of a node and includes this information in the TraceGraph it constructs. This indicates that the level of a node is an important piece of information for initializing feedback in the graph propagation process.\n\n**Note**: This function is a simple accessor and does not perform any validation or modification of the _level attribute. It is important to ensure that the _level attribute is properly initialized before calling this function to avoid potential issues.\n\n**Output Example**: If the _level attribute of the object is set to 3, calling the level function will return 3."
      ],
      "code_start_line": 124,
      "code_end_line": 125,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def level(self):\n        return self._level\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/init_feedback"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "is_root",
      "md_content": [
        "**is_root**: The function of is_root is to determine if the current node is a root node.\n\n**parameters**: The parameters of this function.\n· self: The current node object.\n\n**Code Description**: The `is_root` function is a method of the `AbstractNode` class in the `nodes.py` module. It checks whether the current node is a root node by evaluating the length of its parents list. Specifically, it returns `True` if the length of the parents list is zero, indicating that the node has no parents and is therefore a root node. Conversely, it returns `False` if the node has one or more parents.\n\nThe function relies on the `parents` method of the `AbstractNode` class to retrieve the list of parent nodes. The `parents` method accesses the `_parents` attribute of the node object, which is a list containing the parent nodes. By checking the length of this list, the `is_root` function determines the root status of the node.\n\n**Note**: This function is essential for identifying root nodes in a graph structure, which can be useful for various graph operations such as traversal, initialization, and feedback propagation.\n\n**Output Example**: \n- If the current node has no parents, the `is_root` function will return `True`.\n- If the current node has one or more parents, the `is_root` function will return `False`."
      ],
      "code_start_line": 128,
      "code_end_line": 129,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def is_root(self):\n        return len(self.parents) == 0\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/parents"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "is_leaf",
      "md_content": [
        "**is_leaf**: The function of is_leaf is to determine if the current node is a leaf node, meaning it has no children.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The `is_leaf` method is a part of the `AbstractNode` class. It checks whether the current node has any child nodes by utilizing the `children` method of the same class. Specifically, it returns `True` if the length of the list returned by the `children` method is zero, indicating that the node has no children and is therefore a leaf node. Otherwise, it returns `False`.\n\nThe `children` method, which is called within `is_leaf`, returns the `_children` attribute of the instance. This attribute is a list containing the child nodes of the current node. By checking the length of this list, `is_leaf` can accurately determine the leaf status of the node.\n\n**Note**: Ensure that the `_children` attribute is properly initialized and maintained within the `AbstractNode` class to avoid unexpected behavior when calling the `is_leaf` method.\n\n**Output Example**: A possible return value of the `is_leaf` method could be:\n```python\nTrue\n```\nThis indicates that the current node has no children and is therefore a leaf node."
      ],
      "code_start_line": 132,
      "code_end_line": 133,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def is_leaf(self):\n        return len(self.children) == 0\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/children"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_add_child",
      "md_content": [
        "**_add_child**: The function of _add_child is to add a child node to the current node.\n**parameters**:\n- child: The child node to be added.\n\n**Code Description**:\nThe `_add_child` function is used to add a child node to the current node. It performs the following steps:\n1. It first checks if the child node is not the same as the current node itself. If it is, it raises an assertion error with the message \"Cannot add self as a child.\"\n2. It then checks if the child node is an instance of the `Node` class. If it is not, it raises an assertion error with a message indicating that the child is not a Node.\n3. Finally, it calls the `_add_parent` function of the child node, passing the current node as the parent.\n\n**Note**:\n- The `_add_child` function ensures that the child node is not the same as the current node and that it is an instance of the `Node` class before adding it as a child.\n- This function assumes that the child node has an `_add_parent` function to add the current node as its parent."
      ],
      "code_start_line": 135,
      "code_end_line": 138,
      "params": [
        "self",
        "child"
      ],
      "have_return": false,
      "code_content": "    def _add_child(self, child):\n        assert child is not self, \"Cannot add self as a child.\"\n        assert isinstance(child, Node), f\"{child} is not a Node.\"\n        child._add_parent(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_add_parent",
      "md_content": [
        "**_add_parent**: The function of _add_parent is to add a parent node to the current node in the hierarchical structure of the graph.\n\n**parameters**:\n- parent: The parent node to be added.\n\n**Code Description**:\nThe _add_parent function is a method designed to add a parent node to the current node in the hierarchical structure of the graph. It performs several checks and operations to ensure the validity of the parent node and the consistency of the graph structure.\n\nFirst, the function asserts that the parent node is not the same as the current node, as it is not allowed to add itself as a parent. This check prevents circular dependencies and ensures the integrity of the graph.\n\nNext, the function asserts that the parent node is an instance of the Node class. This check ensures that only valid nodes can be added as parents.\n\nIf both checks pass, the function proceeds to add the current node as a child to the parent node by appending it to the parent's _children attribute. Similarly, it adds the parent node to the current node's _parents attribute.\n\nFinally, the function calls the _update_level method to update the level attribute of the current node. It passes the maximum value between the current node's _level attribute and the parent node's _level attribute plus one as the new level value. This ensures that the hierarchical structure of the nodes is maintained correctly, with child nodes always having a level greater than or equal to their parent nodes.\n\nIt is worth noting that the _add_parent function assumes that the parent parameter is a valid instance of the Node class. If the parent parameter is not a Node instance, an assertion error will be raised.\n\n**Note**:\n- The function does not return any value.\n- The function assumes that the parent parameter is a valid instance of the Node class.\n- The function raises an assertion error if the parent parameter is the same as the current node or if it is not an instance of the Node class."
      ],
      "code_start_line": 140,
      "code_end_line": 145,
      "params": [
        "self",
        "parent"
      ],
      "have_return": false,
      "code_content": "    def _add_parent(self, parent):\n        assert parent is not self, \"Cannot add self as a parent.\"\n        assert isinstance(parent, Node), f\"{parent} is {type(parent)}, which is not a Node.\"\n        parent._children.append(self)\n        self._parents.append(parent)\n        self._update_level(max(self._level, parent._level + 1))  # Update the level, because the parent is added\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\containers.py/SeqIterable/__next__",
        "opto\\trace\\nodes.py/MessageNode/__init__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/_update_level",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_update_level",
      "md_content": [
        "**_update_level**: The function of _update_level is to update the level attribute of the current node to a new specified level.\n\n**parameters**: The parameters of this Function.\n· new_level: The new level to which the node's level attribute should be updated.\n\n**Code Description**: The _update_level function is a method designed to update the internal _level attribute of an instance of the AbstractNode class. This method takes a single parameter, new_level, which represents the new level value that the node should be assigned. The function directly assigns this new value to the node's _level attribute.\n\nIn the context of its usage within the project, the _update_level function is called by the _add_parent method of the AbstractNode class. When a new parent node is added to the current node, the _add_parent method ensures that the current node's level is updated appropriately. Specifically, it sets the current node's level to the maximum of its current level and the new parent's level plus one. This ensures that the hierarchical structure of the nodes is maintained correctly, with child nodes always having a level greater than or equal to their parent nodes.\n\n**Note**: \n- The function assumes that the new_level parameter is a valid integer representing the level.\n- The function does not perform any validation or checks on the new_level parameter; it directly assigns it to the _level attribute.\n- The commented-out line in the function suggests that there was an intention to update a global or shared structure (GRAPH._levels) that tracks nodes by their levels, but this functionality is not implemented in the current version of the function."
      ],
      "code_start_line": 147,
      "code_end_line": 149,
      "params": [
        "self",
        "new_level"
      ],
      "have_return": false,
      "code_content": "    def _update_level(self, new_level):\n        # GRAPH._levels[self._level].remove(self)  # this uses the == operator which compares values. We need to compare references.\n        self._level = new_level\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/AbstractNode/_add_parent"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to provide a string representation of the AbstractNode object.\n\n**parameters**: The parameters of this function.\n· self: The instance of the AbstractNode class.\n\n**Code Description**: The __str__ method in the AbstractNode class returns a string that represents the node in a human-readable format. This method is particularly useful for debugging and logging purposes, as it provides a quick way to inspect the node's key attributes. The string includes the node's name, the data type of the node's data, and the actual data stored in the node.\n\nThe method constructs the string by accessing the `name` property of the node, which retrieves the node's name. It also accesses the `_data` attribute to include the data type and the data itself in the string. The `name` property is a method that returns the value of the private attribute `_name`, which is set when the node is registered in the graph.\n\n**Note**: \n- The __str__ method should be used when a readable string representation of the node is needed, such as in logging or debugging scenarios.\n- Ensure that the node has been properly initialized and registered before calling this method to avoid any unexpected behavior.\n\n**Output Example**: \nIf a node has the name \"node:0\", its data type is `<class 'int'>`, and its data is `42`, the __str__ method will return:\n```\nNode: (node:0, dtype=<class 'int'>, data=42)\n```"
      ],
      "code_start_line": 153,
      "code_end_line": 155,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"Node: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__deepcopy__",
      "md_content": [
        "**__deepcopy__**: The function of __deepcopy__ is to create a deep copy of the node, which is detached from the original graph.\n\n**parameters**: The parameters of this Function.\n· memo: A dictionary used to keep track of objects that have already been copied to avoid infinite recursion during the deep copy process.\n\n**Code Description**: The __deepcopy__ function is designed to create a deep copy of an instance of the AbstractNode class. This means that the new instance will be a completely independent copy of the original, with no shared references to mutable objects.\n\n1. The function starts by obtaining the class of the current instance (`cls = self.__class__`).\n2. It then creates a new, uninitialized instance of this class (`result = cls.__new__(cls)`).\n3. The `memo` dictionary is updated to associate the original instance's ID with the new instance (`memo[id(self)] = result`). This helps in tracking already copied objects to prevent infinite loops.\n4. The function iterates over all the attributes of the original instance (`for k, v in self.__dict__.items():`).\n5. For attributes named `_parents` or `_children`, it sets these attributes in the new instance to empty lists (`setattr(result, k, [])`). This ensures that the new instance starts with no parent or child nodes.\n6. For all other attributes, it performs a deep copy of the attribute's value and assigns it to the new instance (`setattr(result, k, copy.deepcopy(v, memo))`).\n7. Finally, the new instance is returned (`return result`).\n\n**Note**: \n- This function ensures that the new node is completely independent of the original node, with no shared references to mutable objects.\n- Special handling is provided for `_parents` and `_children` attributes to ensure they are initialized as empty lists in the new instance.\n\n**Output Example**: \nIf the original node has attributes like `name`, `_parents`, and `_children`, the deep copy will result in a new node with the same `name` but with `_parents` and `_children` set to empty lists. For example:\n\nOriginal Node:\n```python\noriginal_node = AbstractNode()\noriginal_node.name = \"Node1\"\noriginal_node._parents = [parent_node]\noriginal_node._children = [child_node]\n```\n\nDeep Copied Node:\n```python\ncopied_node = copy.deepcopy(original_node)\nprint(copied_node.name)  # Output: Node1\nprint(copied_node._parents)  # Output: []\nprint(copied_node._children)  # Output: []\n```"
      ],
      "code_start_line": 157,
      "code_end_line": 167,
      "params": [
        "self",
        "memo"
      ],
      "have_return": true,
      "code_content": "    def __deepcopy__(self, memo):\n        \"\"\"This creates a deep copy of the node, which is detached from the original graph.\"\"\"\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k == \"_parents\" or k == \"_children\":\n                setattr(result, k, [])\n            else:\n                setattr(result, k, copy.deepcopy(v, memo))\n        return result\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "lt",
      "md_content": [
        "**lt**: The function of lt is to compare the levels of two nodes and determine if the level of the current node is less than the level of another node.\n\n**parameters**: The parameters of this Function.\n· self: The current instance of the node.\n· other: Another instance of a node to compare with the current node.\n\n**Code Description**: The lt function is a method used to compare the levels of two nodes. It takes two parameters: `self`, which refers to the current node instance, and `other`, which refers to another node instance. The function compares the `_level` attribute of both nodes. Specifically, it checks if the negated level of the current node (`-self._level`) is less than the negated level of the other node (`-other._level`). This effectively means that the function is comparing the levels in reverse order, where a higher numerical level is considered \"less than\" a lower numerical level.\n\n**Note**: \n- Ensure that both `self` and `other` have the `_level` attribute defined before using this function.\n- This function is intended to be used where node levels are compared in a reversed manner.\n\n**Output Example**: \nIf `self._level` is 3 and `other._level` is 5, the function will return `True` because `-3` is less than `-5`."
      ],
      "code_start_line": 169,
      "code_end_line": 170,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def lt(self, other):\n        return -self._level < -other._level\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "gt",
      "md_content": [
        "**gt**: The function of gt is to compare the levels of two AbstractNode objects and determine if the level of the current object is greater than the level of another object.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the current AbstractNode object.\n· other: Another instance of an AbstractNode object to compare against.\n\n**Code Description**: The gt function is a method used to compare the levels of two AbstractNode objects. It takes two parameters: `self` and `other`, which are both instances of AbstractNode. The function compares the `_level` attribute of the two objects. Specifically, it negates the `_level` attributes of both objects and then checks if the negated level of the current object (`self`) is greater than the negated level of the other object (`other`). This effectively determines if the level of the current object is greater than the level of the other object.\n\n**Note**: \n- The `_level` attribute must be defined for both AbstractNode objects being compared.\n- This function relies on the assumption that `_level` is a numeric value that can be meaningfully compared.\n\n**Output Example**: \nIf `self._level` is 3 and `other._level` is 2, the function will return `True` because -3 is greater than -2."
      ],
      "code_start_line": 172,
      "code_end_line": 173,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def gt(self, other):\n        return -self._level > -other._level\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "get_op_name",
      "md_content": [
        "**get_op_name**: The function of get_op_name is to extract the operator type from the given description.\n\n**Parameters**:\n- description: A string representing the description from which the operator type needs to be extracted.\n\n**Code Description**:\nThe `get_op_name` function takes a description as input and uses regular expression to search for the operator type enclosed in square brackets at the beginning of the description. If a match is found, the operator type is extracted and returned. Otherwise, a `ValueError` is raised with a specific error message.\n\nThis function is called by multiple objects in the project. In the `FunModule` class of the `bundle.py` file, the `get_op_name` function is used to generate the description for the function module. The extracted operator type is combined with the function name and docstring to create a meaningful description. The `name` method of the `FunModule` class also calls the `get_op_name` function to retrieve the operator type from the description.\n\nThe `get_op_name` function is also used in the `backward` method of the `Node` class in the `nodes.py` file. This method performs a backward pass in a graph and propagates feedback from child nodes to parent nodes. The `get_op_name` function is used to extract the operator type from the description of each node.\n\n**Note**:\n- The description parameter must contain the operator type enclosed in square brackets at the beginning.\n- If the description does not contain the operator type, a `ValueError` will be raised.\n\n**Output Example**:\nIf the description is \"[Add] Add two numbers\", the function will return \"Add\"."
      ],
      "code_start_line": 181,
      "code_end_line": 188,
      "params": [
        "description"
      ],
      "have_return": true,
      "code_content": "def get_op_name(description):\n    \"\"\"Extract the operator type from the description.\"\"\"\n    match = re.search(r\"^\\[([^\\[\\]]+)\\]\", description)\n    if match:\n        operator_type = match.group(1)\n        return operator_type\n    else:\n        raise ValueError(f\"The description '{description}' must contain the operator type in square brackets.\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/__init__",
        "opto\\trace\\bundle.py/FunModule/name",
        "opto\\trace\\nodes.py/Node/backward",
        "opto\\trace\\propagators\\propagators.py",
        "opto\\trace\\propagators\\propagators.py/Propagator/propagate"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "NodeVizStyleGuide",
      "md_content": [
        "**NodeVizStyleGuide**: The function of NodeVizStyleGuide is to provide a standardized way to visualize nodes in a graph, particularly for use with graph visualization tools like Graphviz.\n\n**attributes**: The attributes of this Class.\n· style: A string that defines the style of the visualization. Default is 'default'.\n· print_limit: An integer that sets the maximum number of characters to print for node descriptions and content. Default is 100.\n\n**Code Description**: The NodeVizStyleGuide class is designed to facilitate the visualization of nodes in a graph by providing a consistent style guide. It includes methods to generate attributes for nodes, such as labels, shapes, colors, and styles, which are essential for rendering nodes in a visually coherent manner.\n\n- The `__init__` method initializes the class with a specified style and a print limit for node descriptions and content.\n- The `get_attrs` method returns a dictionary of attributes for a given node, including label, shape, fill color, and style.\n- The `get_label` method constructs a label for a node by combining its name, description, and data. It truncates the description and data if they exceed the print limit.\n- The `get_node_shape` method determines the shape of a node based on its type. For instance, ParameterNode types are represented as 'box', while other types are represented as 'ellipse'.\n- The `get_color` method assigns a color to a node based on its type. ExceptionNode types are colored 'firebrick1', and ParameterNode types are colored 'lightgray'.\n- The `get_style` method sets the style of a node to 'filled,solid' if the node is trainable; otherwise, it returns an empty string.\n\nIn the context of its usage within the project, the NodeVizStyleGuide class is utilized in the `backward` method of the Node class. When the `visualize` parameter is set to True, an instance of NodeVizStyleGuide is created to generate the necessary attributes for each node in the graph. These attributes are then used to render the nodes and edges in the graph using Graphviz. The `get_attrs` method is called to obtain the visualization attributes for each node, ensuring that the graph is displayed with a consistent and informative style.\n\n**Note**: \n- Ensure that the `print_limit` is set appropriately to avoid truncating important information in node descriptions and content.\n- The class assumes the existence of specific node types like ParameterNode and ExceptionNode, so it should be used in environments where these types are defined.\n\n**Output Example**: \nA possible appearance of the code's return value from the `get_attrs` method might look like this:\n```\n{\n    'label': 'node_name\\nnode_description...\\nnode_content...',\n    'shape': 'ellipse',\n    'fillcolor': '',\n    'style': 'filled,solid'\n}\n```"
      ],
      "code_start_line": 190,
      "code_end_line": 235,
      "params": [],
      "have_return": true,
      "code_content": "class NodeVizStyleGuide:\n    def __init__(self, style='default', print_limit=100):\n        self.style = style\n        self.print_limit = print_limit\n\n    def get_attrs(self, x):\n        attrs= {\n            'label': self.get_label(x),\n            'shape': self.get_node_shape(x),\n            'fillcolor': self.get_color(x),\n            'style': self.get_style(x)\n        }\n        return attrs\n\n    def get_label(self, x):\n        # using colon in the name causes problems in graphviz\n        description = x.description\n        if len(x.description) > self.print_limit:\n            description = x.description[:self.print_limit] + \"...\"\n\n        text = x.py_name + \"\\n\" + description + \"\\n\"\n        content = str(x.data)\n        if isinstance(x.data, dict):\n            if \"content\" in x.data:\n                content = str(x.data[\"content\"])\n\n        if len(content) > self.print_limit:\n            content = content[:self.print_limit] + \"...\"\n        return text + content\n\n    def get_node_shape(self, x):\n        if type(x) == ParameterNode:\n            return 'box'\n        else:\n            return \"ellipse\"\n\n    def get_color(self, x):\n        if type(x) == ExceptionNode:\n            return 'firebrick1'\n        elif type(x) == ParameterNode:\n            return 'lightgray'\n\n        return \"\"\n\n    def get_style(self, x):\n        return 'filled,solid' if x.trainable else \"\"\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the NodeVizStyleGuide class with specific visualization style settings and a print limit.\n\n**parameters**: The parameters of this Function.\n· style: A string parameter that sets the visualization style. The default value is 'default'.\n· print_limit: An integer parameter that sets the limit for print operations. The default value is 100.\n\n**Code Description**: The __init__ function is a constructor method for the NodeVizStyleGuide class. It initializes the instance with two attributes: `style` and `print_limit`. The `style` attribute is set to the value provided by the `style` parameter, which defaults to 'default' if not specified. The `print_limit` attribute is set to the value provided by the `print_limit` parameter, which defaults to 100 if not specified. These attributes are used to configure the visualization style and the print limit for the node visualization guide.\n\n**Note**: Ensure that the `style` parameter is a valid string representing a visualization style and that the `print_limit` parameter is a positive integer to avoid potential issues during the usage of the NodeVizStyleGuide class."
      ],
      "code_start_line": 191,
      "code_end_line": 193,
      "params": [
        "self",
        "style",
        "print_limit"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, style='default', print_limit=100):\n        self.style = style\n        self.print_limit = print_limit\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "get_attrs",
      "md_content": [
        "**get_attrs**: The function of get_attrs is to generate a dictionary of attributes for a node object.\n\n**parameters**:\n- self: Refers to the instance of the class that contains this method.\n- x: The node object for which the attributes are generated.\n\n**Code Description**:\nThe `get_attrs` function is a method of the `NodeVizStyleGuide` class. It takes a node object `x` as input and generates a dictionary of attributes for the node. The attributes include the label, shape, fill color, and style of the node.\n\nThe function first calls the `get_label` method of the `NodeVizStyleGuide` class to generate the label attribute. It then calls the `get_node_shape` method to determine the shape attribute based on the type of the node. The `get_color` method is called to determine the fill color attribute based on the type of the node. Finally, the `get_style` method is called to determine the style attribute based on the trainable status of the node.\n\nThe function constructs a dictionary `attrs` with the label, shape, fill color, and style attributes, and returns it.\n\nThis function is called by the `backward` method of the `Node` class in the same module. The `backward` method performs a backward pass in a computational graph and utilizes the `get_attrs` function to generate the attributes for each node in the graph.\n\n**Note**:\n- The `get_attrs` function assumes that the `get_label`, `get_node_shape`, `get_color`, and `get_style` methods are implemented correctly and return valid values.\n- The function does not handle cases where the node object does not have the required attributes or methods.\n\n**Output Example**:\nIf the label of the node is \"Node1\", the shape is \"ellipse\", the fill color is \"lightgray\", and the style is an empty string, the function will return the following dictionary:\n```\n{\n    'label': 'Node1',\n    'shape': 'ellipse',\n    'fillcolor': 'lightgray',\n    'style': ''\n}\n```"
      ],
      "code_start_line": 195,
      "code_end_line": 202,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def get_attrs(self, x):\n        attrs= {\n            'label': self.get_label(x),\n            'shape': self.get_node_shape(x),\n            'fillcolor': self.get_color(x),\n            'style': self.get_style(x)\n        }\n        return attrs\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_label",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_node_shape",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_color",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_style"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_label",
      "md_content": [
        "**get_label**: The function of get_label is to generate a label for a node object.\n\n**parameters**:\n- self: Refers to the instance of the class that contains this method.\n- x: The node object for which the label is generated.\n\n**Code Description**:\nThe `get_label` function is a method of the `NodeVizStyleGuide` class. It takes a node object `x` as input and generates a label for the node. The label consists of the node's name and description, as well as additional content if available.\n\nThe function first retrieves the description of the node by calling the `description` method of the node object. It then checks if the length of the description exceeds the `print_limit` attribute of the `NodeVizStyleGuide` instance. If it does, the description is truncated and an ellipsis is appended.\n\nNext, the function constructs the text part of the label by concatenating the node's name and the truncated description. The content of the node is retrieved by accessing the `data` attribute of the node object. If the content is a dictionary and it contains a key named \"content\", the value associated with that key is used as the content. Otherwise, the content is converted to a string representation.\n\nSimilar to the description, the content is checked against the `print_limit` attribute and truncated if necessary.\n\nFinally, the function returns the concatenated text and content as the label for the node.\n\nThis function is called by the `get_attrs` method of the `NodeVizStyleGuide` class. The `get_attrs` method generates a dictionary of attributes for a node, including the label, shape, fill color, and style. The `get_label` function is responsible for generating the label attribute of the dictionary.\n\n**Note**:\n- The `get_label` function assumes that the `description` and `data` attributes of the node object are already set and contain valid values.\n- The `print_limit` attribute of the `NodeVizStyleGuide` instance determines the maximum length of the description and content before truncation.\n- The function does not handle cases where the `data` attribute is not present or is of an unsupported type.\n\n**Output Example**:\nIf the name of the node is \"Node1\" and the description is \"This is a sample node description.\", the content is a dictionary with the key \"content\" and value \"Sample content\", and the `print_limit` is set to 20, the function will return the following label:\n```\nNode1\nThis is a sample no...\nSample content\n```"
      ],
      "code_start_line": 204,
      "code_end_line": 218,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def get_label(self, x):\n        # using colon in the name causes problems in graphviz\n        description = x.description\n        if len(x.description) > self.print_limit:\n            description = x.description[:self.print_limit] + \"...\"\n\n        text = x.py_name + \"\\n\" + description + \"\\n\"\n        content = str(x.data)\n        if isinstance(x.data, dict):\n            if \"content\" in x.data:\n                content = str(x.data[\"content\"])\n\n        if len(content) > self.print_limit:\n            content = content[:self.print_limit] + \"...\"\n        return text + content\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_attrs"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/Node/description"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_node_shape",
      "md_content": [
        "**get_node_shape**: The function of get_node_shape is to determine the shape of a node based on its type.\n\n**parameters**: The parameters of this Function.\n· x: The node whose shape is to be determined.\n\n**Code Description**: The get_node_shape function is a method designed to return the shape of a node in a computational graph visualization. It takes a single parameter, x, which represents the node whose shape needs to be determined. The function checks the type of the node x. If x is an instance of the ParameterNode class, the function returns the string 'box', indicating that the node should be visualized as a box. For all other types of nodes, the function returns the string 'ellipse', indicating that the node should be visualized as an ellipse.\n\nThis function is utilized within the get_attrs method of the NodeVizStyleGuide class. The get_attrs method calls get_node_shape to include the shape attribute in the dictionary of attributes for a node. This dictionary is used to define various visual properties of the node, such as its label, shape, fill color, and style.\n\n**Note**: \n- The function relies on the type of the node to determine its shape. It specifically checks if the node is an instance of ParameterNode.\n- The ParameterNode class represents a trainable node in a computational graph and has various attributes such as value, name, trainable, description, constraint, and info.\n\n**Output Example**: \n- If x is an instance of ParameterNode, the function returns 'box'.\n- If x is not an instance of ParameterNode, the function returns 'ellipse'."
      ],
      "code_start_line": 220,
      "code_end_line": 224,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def get_node_shape(self, x):\n        if type(x) == ParameterNode:\n            return 'box'\n        else:\n            return \"ellipse\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_attrs"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/ParameterNode"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_color",
      "md_content": [
        "**get_color**: The function of get_color is to determine the color representation of a node based on its type.\n\n**parameters**: The parameters of this Function.\n· x: The node whose color representation is to be determined.\n\n**Code Description**: The get_color function is a method designed to return a specific color string based on the type of the node passed as an argument. It takes a single parameter, x, which represents the node. The function checks the type of the node and returns a corresponding color string:\n\n- If the node is of type ExceptionNode, the function returns the color 'firebrick1'.\n- If the node is of type ParameterNode, the function returns the color 'lightgray'.\n- For any other type of node, the function returns an empty string.\n\nThis function is utilized within the get_attrs method of the NodeVizStyleGuide class. The get_attrs method calls get_color to determine the fill color attribute of a node, which is part of a set of attributes used for visualizing the node. The get_attrs method constructs a dictionary of attributes including label, shape, fill color, and style, where the fill color is obtained by invoking get_color.\n\n**Note**: \n- The function relies on the specific types of nodes (ExceptionNode and ParameterNode) to determine the color. If additional node types need to be supported, the function should be extended accordingly.\n- The function returns an empty string for node types that are not explicitly handled, which may need to be addressed depending on the visualization requirements.\n\n**Output Example**: \n- For an ExceptionNode, the function would return 'firebrick1'.\n- For a ParameterNode, the function would return 'lightgray'.\n- For any other node type, the function would return an empty string."
      ],
      "code_start_line": 226,
      "code_end_line": 232,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def get_color(self, x):\n        if type(x) == ExceptionNode:\n            return 'firebrick1'\n        elif type(x) == ParameterNode:\n            return 'lightgray'\n\n        return \"\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_attrs"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\nodes.py/ExceptionNode"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_style",
      "md_content": [
        "**get_style**: The function of get_style is to determine the style attributes of a node based on its trainable status.\n\n**parameters**: The parameters of this Function.\n· x: An object that contains the attribute 'trainable'.\n\n**Code Description**: The get_style function evaluates the 'trainable' attribute of the input object 'x'. If 'x.trainable' is True, the function returns the string 'filled,solid', indicating that the node should be styled with a filled and solid appearance. If 'x.trainable' is False, the function returns an empty string, indicating that no specific style should be applied.\n\nThis function is called by the get_attrs function within the same module. The get_attrs function constructs a dictionary of attributes for a node, including its label, shape, fill color, and style. The get_style function specifically provides the 'style' attribute for this dictionary, ensuring that nodes which are trainable are visually distinguished by a filled and solid style.\n\n**Note**: Ensure that the input object 'x' has a 'trainable' attribute; otherwise, the function may raise an AttributeError.\n\n**Output Example**: \n- If x.trainable is True, the return value will be 'filled,solid'.\n- If x.trainable is False, the return value will be an empty string \"\"."
      ],
      "code_start_line": 234,
      "code_end_line": 235,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def get_style(self, x):\n        return 'filled,solid' if x.trainable else \"\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_attrs"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Node",
      "md_content": [
        "An unknown error occurred while generating this documentation after many tries."
      ],
      "code_start_line": 238,
      "code_end_line": 698,
      "params": [],
      "have_return": true,
      "code_content": "class Node(AbstractNode[T]):\n    \"\"\"A data node in a directed graph (parents <-- children).\"\"\"  # TODO update this\n    def __init__(\n        self,\n        value: Any,\n        *,\n        name: str = None,\n        trainable: bool = False,\n        description: str = \"[Node] This is a node in a computational graph.\",\n        constraint: Union[None, str] = None,\n        info: Union[None, Dict] = None,\n    ) -> None:\n        super().__init__(value, name=name)\n        self.trainable = trainable\n        self._feedback = defaultdict(\n            list\n        )  # (analogous to gradient) this is the feedback from the user. Each key is a child and the value is a list of feedbacks from the child.\n        # We keep the propagated feedback as dict and let the propagator performs\n        # the aggreation, rather than doing the aggregation incrementally. This is\n        # to support implementing aggregation that is not commutable.\n        self._description = description  # Information to describe of the node\n        self._constraint = constraint  # A constraint on the node\n        self._backwarded = False  # True if backward has been called\n        self._info = info  # Additional information about the node\n        self._dependencies = {'parameter': set(), 'expandable': set()}  # A dictionary of dependencies on parameters and expandable nodes; expandable nodes who depened on parameters not visible in the current graph level\n\n    def zero_feedback(self):  # set feedback to zero\n        self._feedback = defaultdict(list)\n\n    @property\n    def feedback(self):\n        return self._feedback\n\n    @property\n    def description(self):\n        return self._description  # TODO return a textual description of the node\n\n    @property\n    def info(self):\n        return self._info\n\n    @property\n    def parameter_dependencies(self):\n        return self._dependencies['parameter']\n\n    @property\n    def expandable_dependencies(self):\n        return self._dependencies['expandable']\n\n    def _add_feedback(self, child, feedback):\n        \"\"\"Add feedback from a child.\"\"\"\n        self._feedback[child].append(feedback)\n\n    # This is not traced\n    def _set(self, value: Any):\n        \"\"\"Set the value of the node. If value is Node, it will be unwrapped.\"\"\"\n        if isinstance(value, Node):\n            value = value.data\n        self._data = value\n\n    def backward(\n        self,\n        feedback: Any = \"\",\n        propagator=None,\n        retain_graph=False,\n        visualize=False,\n        simple_visualization=True,\n        reverse_plot=False,\n        print_limit=100,\n    ):\n        \"\"\"Backward pass.\n\n        feedback: feedback given to the current node\n        propagate: a function that takes in a node and a feedback, and returns a dict of {parent: parent_feedback}.\n\n            def propagate(node, feedback):\n                return {parent: propagated feedback for parent in node.parents}\n\n        visualize: if True, plot the graph using graphviz\n        reverse_plot: if True, plot the graph in reverse order (from child to parent).\n        print_limit: the maximum number of characters to print in the graph.\n\n\n        \"\"\"\n        if propagator is None:\n            from opto.trace.propagators.graph_propagator import GraphPropagator  # this avoids circular import\n\n            propagator = GraphPropagator()\n\n        # Setup for visualization\n        digraph = None\n        nvsg = NodeVizStyleGuide()\n\n        if visualize:\n            from graphviz import Digraph\n\n            digraph = Digraph()\n            visited = set()\n\n        # Check for root node with no parents\n        if self._backwarded:\n            raise AttributeError(f\"{self} has been backwarded.\")\n        self._add_feedback(Node(\"FEEDBACK_ORACLE\"), propagator.init_feedback(self, feedback))\n\n        if len(self.parents) == 0:  # This is a root. Nothing to propagate\n            if visualize:\n                digraph.node(self.py_name, **nvsg.get_attrs(self))\n            # self._backwarded = not retain_graph  # only need to be set for MessageNode\n            return digraph\n\n        # TODO optimize for efficiency; use heapq\n        # TODO check memory leak\n        # queue = [self]  # priority queue\n        queue = MinHeap([self])\n        while True:\n            try:\n                # node = heapq.heappop(queue)\n                node = queue.pop()  # All the children of this node have been visited\n                # Each node is a MessageNode, which has at least one parent.\n                assert len(node.parents) > 0 and isinstance(node, MessageNode)\n                if node._backwarded:\n                    raise AttributeError(f\"{node} has been backwarded.\")\n\n                # Propagate information from node to its parents\n                propagated_feedback = propagator(node)\n\n                # Zero-out the feedback once it's propagated.\n                # This is to ensure the feedback is not double counted when retain_graph is True.\n                node.zero_feedback()\n\n                for parent in node.parents:\n                    if parent in propagated_feedback:\n                        parent._add_feedback(node, propagated_feedback[parent])\n\n                    # Put parent in the queue if it has not been visited and it's not a root\n                    if len(parent.parents) > 0 and parent not in queue:  # and parent not in queue:\n                        # heapq.heappush(queue, parent)  # put parent in the priority queue\n                        queue.push(parent)  # put parent in the priority queue\n\n                    if visualize:\n                        # Plot the edge from parent to node\n                        # Bypass chain of identity operators (for better visualization)\n                        while (get_op_name(parent.description) in IDENTITY_OPERATORS) and simple_visualization:\n                            assert len(parent.parents) == 1  # identity operators should have only one parent\n                            visited.add(parent.py_name)  # skip this node in visualization\n                            parent = parent.parents[0]\n\n                        edge = (node.py_name, parent.py_name) if reverse_plot else (parent.py_name, node.py_name)\n                        # Just plot the edge once, since the same node can be\n                        # visited multiple times (e.g., when that node has\n                        # multiple children).\n                        if edge not in visited and node.py_name not in visited:\n                            digraph.edge(*edge)\n                            visited.add(edge)\n                            digraph.node(node.py_name, **nvsg.get_attrs(node))\n                            digraph.node(parent.py_name, **nvsg.get_attrs(parent))\n\n                node._backwarded = not retain_graph  # set backwarded to True\n\n            except IndexError:  # queue is empty\n                break\n\n        return digraph\n\n    def clone(self):\n        import opto.trace.operators as ops\n\n        return ops.clone(self)\n\n    def detach(self):\n        return copy.deepcopy(self)\n\n    # Get attribute and call operators\n    def getattr(self, key):\n        import opto.trace.operators as ops\n\n        return ops.node_getattr(self, node(key))\n\n    def call(self, fun: str, *args, **kwargs):\n        args = (node(arg) for arg in args)  # convert args to nodes\n        kwargs = {k: node(v) for k, v in kwargs.items()}\n        return self.getattr(fun)(*args, **kwargs)\n\n    def __call__(self, *args, **kwargs):\n        import opto.trace.operators as ops\n\n        output = ops.call(self, *args, **kwargs)\n        return output\n\n    # We overload magic methods that return a value. These methods return a MessageNode.\n    # container magic methods\n    def len(self):\n        import opto.trace.operators as ops\n\n        return ops.len_(self)\n\n    def __getitem__(self, key):\n        import opto.trace.operators as ops\n\n        return ops.getitem(self, node(key))\n\n    def __contains__(self, item):\n        import opto.trace.operators as ops\n\n        return ops.in_(node(item), self)\n\n    # Unary operators and functions\n    def __pos__(self):\n        import opto.trace.operators as ops\n\n        return ops.pos(self)\n\n    def __neg__(self):\n        import opto.trace.operators as ops\n\n        return ops.neg(self)\n\n    def __abs__(self):\n        import opto.trace.operators as ops\n\n        return ops.abs(self)\n\n    def __invert__(self):\n        import opto.trace.operators as ops\n\n        return ops.invert(self)\n\n    def __round__(self, n=None):\n        import opto.trace.operators as ops\n\n        return ops.round(self, node(n) if n is not None else None)\n\n    def __floor__(self):\n        import opto.trace.operators as ops\n\n        return ops.floor(self)\n\n    def __ceil__(self):\n        import opto.trace.operators as ops\n\n        return ops.ceil(self)\n\n    def __trunc__(self):\n        import opto.trace.operators as ops\n\n        return ops.trunc(self)\n\n    ## Normal arithmetic operators\n    def __add__(self, other):\n        import opto.trace.operators as ops\n\n        if type(self._data) is str:\n            return ops.concat(self, node(other))\n        else:\n            return ops.add(self, node(other))\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.subtract(self, node(other))\n\n    def __mul__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.multiply(self, node(other))\n\n    def __floordiv__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.floor_divide(self, node(other))\n\n    def __truediv__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.divide(self, node(other))\n\n    def __mod__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.mod(self, node(other))\n\n    def __divmod__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.divmod(self, node(other))\n\n    def __pow__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.power(self, node(other))\n\n    def __lshift__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.lshift(self, node(other))\n\n    def __rshift__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.rshift(self, node(other))\n\n    def __and__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.and_(self, node(other))\n\n    def __or__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.or_(self, node(other))\n\n    def __xor__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.xor(self, node(other))\n\n    def __iter__(self):\n        import opto.trace.containers as ct\n\n        return ct.iterate(self)\n\n    def __len__(self):\n        # __len__ restricts return type to be integer\n        # therefore, we only return integer here\n        # if users want a Node, they need to call node.len() instead\n        return len(self._data)\n\n    # for logic operators\n    # case 1: used in if-statement, then we should return a bool\n    # case 2: used else-where, then we should return Node(bool)\n    # we can't quite distinguish myopically, so...in here, we prioritize case 1\n    def __lt__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.lt(self, node(other))\n        # if isinstance(other, Node):\n        #     other = other.data\n        # return self._data < other\n\n    def __le__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.le(self, node(other))\n        # if isinstance(other, Node):\n        #     other = other.data\n        # return self._data <= other\n\n    def __gt__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.gt(self, node(other))\n        # if isinstance(other, Node):\n        #     other = other.data\n        # return self._data > other\n\n    def __ge__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.ge(self, node(other))\n        # if isinstance(other, Node):\n        #     other = other.data\n        # return self._data >= other\n\n    # this creates a lot of issues if we return Node\n    # instead of bool (for example \"in\" operator will not work)\n    def __eq__(self, other):\n        # import opto.trace.operators as ops\n        # return ops.eq(self, node(other))\n        if isinstance(other, Node):\n            other = other.data\n        return self._data == other\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __bool__(self):\n        # not tracing this conversion\n        return bool(self._data)\n\n    # string operators\n    def format(self, *args, **kwargs):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'format'.\")\n\n        import opto.trace.operators as ops\n\n        return ops.format(self, *args, **kwargs)\n\n    def capitalize(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'capitalize'.\")\n        import opto.trace.operators as ops\n\n        return ops.capitalize(self)\n\n    def lower(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'lower'.\")\n        import opto.trace.operators as ops\n\n        return ops.lower(self)\n\n    def upper(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'upper'.\")\n        import opto.trace.operators as ops\n\n        return ops.upper(self)\n\n    def swapcase(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'swapcase'.\")\n        import opto.trace.operators as ops\n\n        return ops.swapcase(self)\n\n    def title(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'title'.\")\n        import opto.trace.operators as ops\n\n        return ops.title(self)\n\n    def split(self, sep=None, maxsplit=-1):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'split'.\")\n        import opto.trace.operators as ops\n\n        return ops.split(self, sep, maxsplit)\n\n    def strip(self, chars=None):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'strip'.\")\n        import opto.trace.operators as ops\n\n        return ops.strip(self, chars)\n\n    def replace(self, old, new, count=-1):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'replace'.\")\n        import opto.trace.operators as ops\n\n        return ops.replace(self, node(old), node(new), count)\n\n    # container specific methods\n    def items(self):\n        import opto.trace.containers as ct\n\n        return ct.items(self)\n\n    def pop(self, __index=-1):\n        # python does hidden type checks\n        import opto.trace.operators as ops\n\n        return ops.pop(self, node(__index))\n\n    def append(self, *args, **kwargs):\n        return self.call(\"append\", *args, **kwargs)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\opro.py",
        "opto\\optimizers\\optimizers.py",
        "opto\\optimizers\\optimizers.py/Optimizer/backward",
        "opto\\trace\\__init__.py",
        "opto\\trace\\broadcast.py",
        "opto\\trace\\broadcast.py/apply_op",
        "opto\\trace\\broadcast.py/apply_op/admissible_type",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/wrap",
        "opto\\trace\\bundle.py/FunModule/is_valid_output",
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\containers.py",
        "opto\\trace\\containers.py/iterate",
        "opto\\trace\\modules.py",
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/Graph/register",
        "opto\\trace\\nodes.py/AbstractNode/__init__",
        "opto\\trace\\nodes.py/AbstractNode/_add_child",
        "opto\\trace\\nodes.py/AbstractNode/_add_parent",
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\nodes.py/MessageNode/__init__",
        "opto\\trace\\nodes.py/MessageNode/external_dependencies",
        "opto\\trace\\nodes.py/MessageNode/_add_dependencies",
        "opto\\trace\\nodes.py/ExceptionNode/__init__",
        "opto\\trace\\operators.py",
        "opto\\trace\\operators.py/node_getattr",
        "opto\\trace\\operators.py/call",
        "opto\\trace\\propagators\\graph_propagator.py",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/aggregate",
        "opto\\trace\\propagators\\propagators.py",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/propagate",
        "opto\\trace\\propagators\\propagators.py/Propagator/propagate",
        "opto\\trace\\propagators\\propagators.py/Propagator/_propagate",
        "opto\\trace\\trace.py",
        "tests\\unit_tests\\test_backward.py",
        "tests\\unit_tests\\test_bundle.py",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_bundle.py/run/auto_cond",
        "tests\\unit_tests\\test_bundle.py/run/cond",
        "tests\\unit_tests\\test_bundle.py/run/fancy_cond",
        "tests\\unit_tests\\test_bundle.py/run/test",
        "tests\\unit_tests\\test_bundle.py/run/test_0(name_duplicate_version)",
        "tests\\unit_tests\\test_bundle.py/run/test_1(name_duplicate_version)",
        "tests\\unit_tests\\test_bundle.py/run/test_2(name_duplicate_version)",
        "tests\\unit_tests\\test_bundle.py/run/Foo/trace_fun",
        "tests\\unit_tests\\test_error_handling.py",
        "tests\\unit_tests\\test_error_handling.py/bug_program",
        "tests\\unit_tests\\test_python_funcs.py",
        "tests\\unit_tests\\test_python_funcs.py/test_get_env",
        "tests\\unit_tests\\test_python_funcs.py/test_empty_inputs",
        "tests\\unit_tests\\test_python_funcs.py/test_standard_env"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize a Node object in a computational graph.\n\n**parameters**: The parameters of this Function.\n· value: The initial value of the node.\n· name: An optional string representing the name of the node.\n· trainable: A boolean indicating whether the node is trainable.\n· description: A string providing a description of the node.\n· constraint: An optional string representing any constraints on the node.\n· info: An optional dictionary containing additional information about the node.\n\n**Code Description**: The __init__ function initializes a Node object with several attributes. It first calls the superclass initializer with the value and name parameters. The trainable attribute is set based on the provided argument, indicating whether the node can be trained. The _feedback attribute is initialized as a defaultdict of lists, which will store feedback from child nodes. This feedback mechanism is analogous to gradients in machine learning and is used to propagate information back through the graph. The _description attribute stores a textual description of the node, while the _constraint attribute holds any constraints that apply to the node. The _backwarded attribute is a boolean flag indicating whether the backward pass has been called on this node. The _info attribute is a dictionary for storing additional information about the node. Finally, the _dependencies attribute is a dictionary that tracks dependencies on parameters and expandable nodes, which are nodes that depend on parameters not visible at the current graph level.\n\n**Note**: Points to note about the use of the code\n- Ensure that the value parameter is provided when initializing the Node.\n- The name parameter is optional but can be useful for identifying nodes in the graph.\n- The trainable parameter should be set to True if the node is intended to be updated during training.\n- The description, constraint, and info parameters provide additional context and constraints for the node, which can be useful for debugging and documentation purposes.\n- The feedback mechanism is designed to support non-commutative aggregation, so feedback should be handled carefully to maintain the correct order of operations."
      ],
      "code_start_line": 240,
      "code_end_line": 262,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def __init__(\n        self,\n        value: Any,\n        *,\n        name: str = None,\n        trainable: bool = False,\n        description: str = \"[Node] This is a node in a computational graph.\",\n        constraint: Union[None, str] = None,\n        info: Union[None, Dict] = None,\n    ) -> None:\n        super().__init__(value, name=name)\n        self.trainable = trainable\n        self._feedback = defaultdict(\n            list\n        )  # (analogous to gradient) this is the feedback from the user. Each key is a child and the value is a list of feedbacks from the child.\n        # We keep the propagated feedback as dict and let the propagator performs\n        # the aggreation, rather than doing the aggregation incrementally. This is\n        # to support implementing aggregation that is not commutable.\n        self._description = description  # Information to describe of the node\n        self._constraint = constraint  # A constraint on the node\n        self._backwarded = False  # True if backward has been called\n        self._info = info  # Additional information about the node\n        self._dependencies = {'parameter': set(), 'expandable': set()}  # A dictionary of dependencies on parameters and expandable nodes; expandable nodes who depened on parameters not visible in the current graph level\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "zero_feedback",
      "md_content": [
        "**zero_feedback**: The function of zero_feedback is to reset the feedback attribute of the Node object to an empty state.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The zero_feedback function is designed to reset the feedback mechanism of a Node object. It achieves this by setting the _feedback attribute to a new defaultdict with lists as the default factory. This ensures that any previous feedback data stored in the _feedback attribute is cleared, effectively resetting it to an empty state.\n\nIn the context of its usage within the project, the zero_feedback function is called by the backward method of the Node class. During the backward pass, feedback is propagated from the current node to its parent nodes. After this propagation, zero_feedback is invoked to clear the feedback of the current node. This is crucial to prevent the feedback from being double-counted if the retain_graph parameter is set to True. By resetting the feedback, the function ensures that each node's feedback is only considered once during the backward pass, maintaining the integrity of the feedback propagation process.\n\n**Note**: It is important to note that zero_feedback should be used judiciously within the feedback propagation process to avoid unintended loss of feedback data. It is specifically designed to be used after feedback has been successfully propagated to parent nodes."
      ],
      "code_start_line": 264,
      "code_end_line": 265,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def zero_feedback(self):  # set feedback to zero\n        self._feedback = defaultdict(list)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "feedback",
      "md_content": [
        "**feedback**: The function of feedback is to return the internal feedback attribute of the Node object.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The feedback function is a method of the Node class that simply returns the value of the private attribute _feedback. This method does not take any parameters and provides a way to access the internal feedback data stored within the Node object.\n\nThe feedback method is utilized in various parts of the project to retrieve feedback information from Node objects. For instance, in the summarize method of the FunctionOptimizer class, the feedback method is called on each trainable node to aggregate feedback from all parameters. This aggregated feedback is then used to construct a summary of the feedback for further processing.\n\nSimilarly, in the _propagate method of the GraphPropagator class, the feedback method is called on a child node to obtain its feedback, which is then aggregated and propagated to its parent nodes. This ensures that feedback information flows correctly through the graph structure.\n\nIn the AbstractPropagator class, the __call__ method also makes use of the feedback method to propagate feedback from a child node to its parents. This method ensures that the feedback is in the correct format and that all parent nodes receive the appropriate feedback.\n\nThe SumPropagator class's _propagate method uses the feedback method to retrieve user feedback or sum the feedback from various sources, ensuring that the feedback is correctly propagated to parent nodes.\n\n**Note**: The feedback method is a straightforward accessor method and does not perform any modifications to the internal state of the Node object. It is essential to ensure that the _feedback attribute is correctly initialized and maintained within the Node class to provide accurate feedback information.\n\n**Output Example**: A possible appearance of the code's return value could be:\n```\n{\n    \"loss\": 0.25,\n    \"accuracy\": 0.95\n}\n```\nThis example assumes that the _feedback attribute contains a dictionary with keys representing different metrics and their corresponding values. The actual structure and content of the feedback will depend on the specific implementation and use case within the project."
      ],
      "code_start_line": 268,
      "code_end_line": 269,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def feedback(self):\n        return self._feedback\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/__call__",
        "opto\\trace\\propagators\\propagators.py/SumPropagator/_propagate",
        "tests\\unit_tests\\test_backward.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "description",
      "md_content": [
        "**description**: The function of description is to return a textual description of the node.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The description function is a method that returns the value of the private attribute `_description` of the Node object. This function is straightforward and does not take any parameters. It simply accesses and returns the `_description` attribute, which is expected to hold a textual description of the node.\n\nThis function is utilized in various parts of the project to retrieve the description of a node. For instance, in the `get_label` method of the `NodeVizStyleGuide` class, the `description` function is called to obtain the node's description, which is then used to generate a label for visualization purposes. The method ensures that the description does not exceed a certain length by truncating it if necessary.\n\nSimilarly, in the `propagate` method of the `Propagator` class, the `description` function is used to get the node's description, which is then processed to determine the appropriate propagation behavior based on the operator name derived from the description.\n\n**Note**: This function assumes that the `_description` attribute is already set and contains a valid string. It does not perform any validation or modification of the description.\n\n**Output Example**: \nIf the `_description` attribute of a Node object is set to \"This is a sample node description.\", calling the `description` function will return:\n\"This is a sample node description.\""
      ],
      "code_start_line": 272,
      "code_end_line": 273,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def description(self):\n        return self._description  # TODO return a textual description of the node\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_label",
        "opto\\trace\\propagators\\propagators.py/Propagator/propagate"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "info",
      "md_content": [
        "**info**: The function of info is to return the value of the `_info` attribute of the object.\n\n**parameters**:\n- self: The object itself.\n\n**Code Description**:\nThe `info` function is a method of the `Node` class. It returns the value of the `_info` attribute of the object. The `_info` attribute is a private attribute that stores additional information about the node.\n\nThe purpose of the `info` function is to provide access to the `_info` attribute, allowing users to retrieve any additional information associated with the node.\n\nThis function does not take any arguments other than `self`, which refers to the object itself. By calling `info()` on a `Node` object, the function will return the value of the `_info` attribute.\n\nThe `_info` attribute can be set by the user or by other functions within the code. It is typically used to store metadata or any other relevant information about the node.\n\n**Note**: \n- The `info` function is a simple getter method that provides access to the `_info` attribute of the object.\n- The `_info` attribute can be accessed directly, but it is recommended to use the `info` function for consistency and encapsulation.\n\n**Output Example**: \nIf the `_info` attribute of the object is set to `\"This is a node\"`, calling `info()` will return `\"This is a node\"`."
      ],
      "code_start_line": 276,
      "code_end_line": 277,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def info(self):\n        return self._info\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/get_fun_name",
        "opto\\trace\\nodes.py/MessageNode/external_dependencies",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parameter_dependencies",
      "md_content": [
        "**parameter_dependencies**: The function of parameter_dependencies is to return the dependencies related to parameters within the Node object.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The parameter_dependencies function is a method within the Node class that retrieves and returns the parameter dependencies stored in the Node object. Specifically, it accesses the '_dependencies' attribute of the Node instance, which is a dictionary, and returns the value associated with the 'parameter' key. This value represents the set of dependencies that are related to the parameters of the Node.\n\nThe function is utilized by the external_dependencies method in the MessageNode class. In this context, the external_dependencies method checks if the 'info' attribute of the MessageNode instance is a dictionary and if it contains an 'output' key that is an instance of Node. It then compares the length of the parameter dependencies of the 'output' Node with the parameter dependencies of the current MessageNode. If the 'output' Node has more parameter dependencies, it returns the difference between the two sets of dependencies. This indicates that the external_dependencies method relies on the parameter_dependencies function to determine the parameter dependencies of the Node instances it interacts with.\n\n**Note**: Ensure that the '_dependencies' attribute is properly initialized and contains a 'parameter' key with a corresponding value before calling the parameter_dependencies function to avoid potential KeyError exceptions.\n\n**Output Example**: A possible return value of the parameter_dependencies function could be a set of dependencies, such as:\n```\n{'dependency1', 'dependency2', 'dependency3'}\n```"
      ],
      "code_start_line": 280,
      "code_end_line": 281,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def parameter_dependencies(self):\n        return self._dependencies['parameter']\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/MessageNode/external_dependencies"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "expandable_dependencies",
      "md_content": [
        "**expandable_dependencies**: The function of expandable_dependencies is to retrieve the 'expandable' dependencies from the Node object's internal dependencies dictionary.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The expandable_dependencies function is a method of the Node class. It accesses the Node object's internal dictionary, `_dependencies`, and returns the value associated with the key 'expandable'. This dictionary is assumed to store various types of dependencies, and the 'expandable' key specifically holds the dependencies that can be expanded. The function provides a straightforward way to access these expandable dependencies without directly interacting with the internal dictionary.\n\n**Note**: \n- Ensure that the '_dependencies' dictionary is properly initialized and contains the 'expandable' key before calling this function to avoid potential KeyError exceptions.\n- This function assumes that the 'expandable' key in the '_dependencies' dictionary holds a valid value that can be returned.\n\n**Output Example**: \nIf the '_dependencies' dictionary is structured as follows:\n```python\nself._dependencies = {\n    'expandable': ['dependency1', 'dependency2'],\n    'non_expandable': ['dependency3']\n}\n```\nCalling `expandable_dependencies()` would return:\n```python\n['dependency1', 'dependency2']\n```"
      ],
      "code_start_line": 284,
      "code_end_line": 285,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def expandable_dependencies(self):\n        return self._dependencies['expandable']\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_add_feedback",
      "md_content": [
        "**_add_feedback**: The function of _add_feedback is to add feedback from a child node to the current node.\n\n**parameters**: The parameters of this Function.\n· child: The child node from which the feedback is received.\n· feedback: The feedback data to be added.\n\n**Code Description**: The _add_feedback function is designed to manage feedback propagation in a node-based structure. It takes two parameters: 'child', which represents the child node providing the feedback, and 'feedback', which is the actual feedback data to be appended. The function appends the feedback to a list associated with the child node in the _feedback dictionary of the current node.\n\nIn the context of its usage within the backward function, _add_feedback plays a crucial role in the feedback propagation mechanism. During the backward pass, feedback is propagated from child nodes to parent nodes. The backward function initializes the feedback for the current node and then propagates it to its parents. The _add_feedback function is called to append the propagated feedback from a child node to the current node's feedback list. This ensures that each node accumulates feedback from its children, which can then be used for further processing or analysis.\n\n**Note**: Points to note about the use of the code\n- Ensure that the _feedback dictionary is properly initialized and that each child node has an associated list to append feedback to.\n- The function assumes that the child node is already present in the _feedback dictionary.\n- Proper handling of feedback data is essential to avoid issues during the feedback propagation process."
      ],
      "code_start_line": 287,
      "code_end_line": 289,
      "params": [
        "self",
        "child",
        "feedback"
      ],
      "have_return": false,
      "code_content": "    def _add_feedback(self, child, feedback):\n        \"\"\"Add feedback from a child.\"\"\"\n        self._feedback[child].append(feedback)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_set",
      "md_content": [
        "**_set**: The function of _set is to set the value of the node. If the value is a Node, it will be unwrapped.\n\n**parameters**: The parameters of this Function.\n· value: The value to be set for the node. It can be of any type, including another Node.\n\n**Code Description**: The _set function is designed to assign a value to the node's internal data attribute. It first checks if the provided value is an instance of the Node class. If it is, the function retrieves the internal data of the Node by accessing its data attribute, effectively unwrapping the Node. This ensures that the node's internal data is set to the actual data contained within the provided Node, rather than the Node object itself. If the value is not a Node, it is directly assigned to the node's internal data attribute. This function is crucial for maintaining the integrity of the node's data, especially when dealing with nested Node objects.\n\n**Note**: This function assumes that the \"_data\" attribute exists within the node object. If this attribute is not present, an AttributeError will be raised."
      ],
      "code_start_line": 292,
      "code_end_line": 296,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def _set(self, value: Any):\n        \"\"\"Set the value of the node. If value is Node, it will be unwrapped.\"\"\"\n        if isinstance(value, Node):\n            value = value.data\n        self._data = value\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "backward",
      "md_content": [
        "**backward**: The `backward` function is responsible for performing a backward pass in a computational graph. It propagates feedback from the current node to its parents, updates the graph visualization if required, and returns the resulting graph.\n\n**parameters**:\n- `feedback`: An optional parameter that represents the feedback given to the current node. It can be of any type.\n- `propagator`: An optional parameter that represents a function used to propagate feedback from a node to its parents. If not provided, a default `GraphPropagator` object is used.\n- `retain_graph`: A boolean parameter that determines whether to retain the graph after the backward pass. If set to `True`, the graph will be retained; otherwise, it will be cleared. The default value is `False`.\n- `visualize`: A boolean parameter that determines whether to plot the graph using graphviz. If set to `True`, the graph will be visualized; otherwise, it will not be plotted. The default value is `False`.\n- `simple_visualization`: A boolean parameter that determines whether to simplify the visualization by bypassing chains of identity operators. If set to `True`, identity operators will be skipped in the visualization; otherwise, they will be included. The default value is `True`.\n- `reverse_plot`: A boolean parameter that determines the order of the graph visualization. If set to `True`, the graph will be plotted in reverse order (from child to parent); otherwise, it will be plotted in the default order (from parent to child). The default value is `False`.\n- `print_limit`: An integer parameter that sets the maximum number of characters to print in the graph visualization. If the description or content of a node exceeds this limit, it will be truncated. The default value is `100`.\n\n**Code Description**:\nThe `backward` function is a method of the current object. It performs a backward pass in a computational graph by propagating feedback from the current node to its parents. The function takes several parameters to control the behavior of the backward pass.\n\nThe `feedback` parameter represents the feedback given to the current node. It can be of any type and is used to initialize the feedback mechanism of the node. The `propagator` parameter is an optional function that is used to propagate feedback from a node to its parents. If not provided, a default `GraphPropagator` object is used, which implements specific methods for feedback propagation. The `retain_graph` parameter determines whether to retain the graph after the backward pass. If set to `True`, the graph will be retained; otherwise, it will be cleared. The `visualize` parameter determines whether to plot the graph using graphviz. If set to `True`, the graph will be visualized; otherwise, it will not be plotted. The `simple_visualization` parameter determines whether to simplify the visualization by bypassing chains of identity operators. If set to `True`, identity operators will be skipped in the visualization; otherwise, they will be included. The `reverse_plot` parameter determines the order of the graph visualization. If set to `True`, the graph will be plotted in reverse order (from child to parent); otherwise, it will be plotted in the default order (from parent to child). The `print_limit` parameter sets the maximum number of characters to print in the graph visualization. If the description or content of a node exceeds this limit, it will be truncated.\n\nThe function first checks if a `propagator` object is provided. If not, it imports the `GraphPropagator` class from the `opto.trace.propagators.graph_propagator` module. It then initializes the `propagator` object if it is not provided.\n\nNext, the function sets up the visualization by creating a `digraph` object and a `NodeVizStyleGuide` object. These objects are used to plot the graph using graphviz and define the style of the nodes in the graph.\n\nThe function checks if the current node has already been backwarded. If it has, an `AttributeError` is raised. Otherwise, the function adds the feedback to the current node by calling the `_add_feedback` method of the node object. The feedback is initialized with a special \"FEEDBACK_ORACLE\" node and the propagated feedback from the `propagator` object.\n\nIf the current node has no parents, indicating that it is a root node, the function checks if visualization is enabled. If it is, the current node is added to the `digraph` object with the appropriate style attributes. Finally, the function returns the `digraph` object.\n\nIf the current node has parents, indicating that it is not a root node, the function initializes a priority queue called `queue` using the `MinHeap` class. The priority queue is used to process the nodes in the correct order during the backward pass.\n\nThe function enters a loop that continues until the `queue` is empty. In each iteration, a node is popped from the `queue` and processed. The node is checked to ensure it has parents and is an instance of the `MessageNode` class. If not, an `AttributeError` is raised.\n\nThe function propagates information from the current node to its parents by calling the `propagator` object with the current node as the argument. The `propagator` object computes the propagated feedback based on the child node's description, data, and feedback. The propagated feedback is then added to the parents of the current node by calling the `_add_feedback` method of each parent node.\n\nThe function checks if visualization is enabled. If it is, the function plots the edge from each parent to the current node in the `digraph` object. It also handles the visualization of identity operators by bypassing chains of identity operators if the `simple_visualization` parameter is set to `True`.\n\nAfter processing the parents of the current node, the `_backwarded` attribute of the current node is updated to indicate that it has been backwarded. This attribute is set to `True` unless the `retain_graph` parameter is set to `True`.\n\nThe loop continues until the `queue` is empty, indicating that all the nodes have been processed. Finally, the function returns the `digraph` object.\n\n**Note**:\n- The `backward` function is a crucial part of the backward pass in a computational graph. It propagates feedback from child nodes to parent nodes, updates the graph visualization if required, and returns the resulting graph.\n- The `feedback` parameter is used to initialize the feedback mechanism of the current node. It can be of any type and is specific to the application.\n- The `propagator` parameter allows for customization of the feedback propagation process. If not provided, a default `GraphPropagator` object is used.\n- The `retain_graph` parameter determines whether to retain the graph after the backward pass. This can be useful for further analysis or visualization.\n- The `visualize` parameter allows for visualization of the graph using graphviz. This can be helpful for understanding the structure of the graph.\n- The `simple_visualization` parameter simplifies the visualization by bypassing chains of identity operators. This can improve the clarity of the graph.\n- The `reverse_plot` parameter determines the order of the graph visualization. This can be useful for visualizing the graph from child to parent, which may be more intuitive in some cases.\n- The `print_limit` parameter sets a limit on the number of characters to print in the graph visualization. This can prevent the visualization from becoming too cluttered or overwhelming.\n\n**Output Example**: \nIf the current node has two parents and visualization is enabled, the `backward` function will return a `digraph` object representing the graph with the appropriate edges and node styles."
      ],
      "code_start_line": 298,
      "code_end_line": 400,
      "params": [
        "self",
        "feedback",
        "propagator",
        "retain_graph",
        "visualize",
        "simple_visualization",
        "reverse_plot",
        "print_limit"
      ],
      "have_return": true,
      "code_content": "    def backward(\n        self,\n        feedback: Any = \"\",\n        propagator=None,\n        retain_graph=False,\n        visualize=False,\n        simple_visualization=True,\n        reverse_plot=False,\n        print_limit=100,\n    ):\n        \"\"\"Backward pass.\n\n        feedback: feedback given to the current node\n        propagate: a function that takes in a node and a feedback, and returns a dict of {parent: parent_feedback}.\n\n            def propagate(node, feedback):\n                return {parent: propagated feedback for parent in node.parents}\n\n        visualize: if True, plot the graph using graphviz\n        reverse_plot: if True, plot the graph in reverse order (from child to parent).\n        print_limit: the maximum number of characters to print in the graph.\n\n\n        \"\"\"\n        if propagator is None:\n            from opto.trace.propagators.graph_propagator import GraphPropagator  # this avoids circular import\n\n            propagator = GraphPropagator()\n\n        # Setup for visualization\n        digraph = None\n        nvsg = NodeVizStyleGuide()\n\n        if visualize:\n            from graphviz import Digraph\n\n            digraph = Digraph()\n            visited = set()\n\n        # Check for root node with no parents\n        if self._backwarded:\n            raise AttributeError(f\"{self} has been backwarded.\")\n        self._add_feedback(Node(\"FEEDBACK_ORACLE\"), propagator.init_feedback(self, feedback))\n\n        if len(self.parents) == 0:  # This is a root. Nothing to propagate\n            if visualize:\n                digraph.node(self.py_name, **nvsg.get_attrs(self))\n            # self._backwarded = not retain_graph  # only need to be set for MessageNode\n            return digraph\n\n        # TODO optimize for efficiency; use heapq\n        # TODO check memory leak\n        # queue = [self]  # priority queue\n        queue = MinHeap([self])\n        while True:\n            try:\n                # node = heapq.heappop(queue)\n                node = queue.pop()  # All the children of this node have been visited\n                # Each node is a MessageNode, which has at least one parent.\n                assert len(node.parents) > 0 and isinstance(node, MessageNode)\n                if node._backwarded:\n                    raise AttributeError(f\"{node} has been backwarded.\")\n\n                # Propagate information from node to its parents\n                propagated_feedback = propagator(node)\n\n                # Zero-out the feedback once it's propagated.\n                # This is to ensure the feedback is not double counted when retain_graph is True.\n                node.zero_feedback()\n\n                for parent in node.parents:\n                    if parent in propagated_feedback:\n                        parent._add_feedback(node, propagated_feedback[parent])\n\n                    # Put parent in the queue if it has not been visited and it's not a root\n                    if len(parent.parents) > 0 and parent not in queue:  # and parent not in queue:\n                        # heapq.heappush(queue, parent)  # put parent in the priority queue\n                        queue.push(parent)  # put parent in the priority queue\n\n                    if visualize:\n                        # Plot the edge from parent to node\n                        # Bypass chain of identity operators (for better visualization)\n                        while (get_op_name(parent.description) in IDENTITY_OPERATORS) and simple_visualization:\n                            assert len(parent.parents) == 1  # identity operators should have only one parent\n                            visited.add(parent.py_name)  # skip this node in visualization\n                            parent = parent.parents[0]\n\n                        edge = (node.py_name, parent.py_name) if reverse_plot else (parent.py_name, node.py_name)\n                        # Just plot the edge once, since the same node can be\n                        # visited multiple times (e.g., when that node has\n                        # multiple children).\n                        if edge not in visited and node.py_name not in visited:\n                            digraph.edge(*edge)\n                            visited.add(edge)\n                            digraph.node(node.py_name, **nvsg.get_attrs(node))\n                            digraph.node(parent.py_name, **nvsg.get_attrs(parent))\n\n                node._backwarded = not retain_graph  # set backwarded to True\n\n            except IndexError:  # queue is empty\n                break\n\n        return digraph\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/parents",
        "opto\\trace\\nodes.py/AbstractNode/py_name",
        "opto\\trace\\nodes.py/get_op_name",
        "opto\\trace\\nodes.py/NodeVizStyleGuide",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_attrs",
        "opto\\trace\\nodes.py/Node/zero_feedback",
        "opto\\trace\\nodes.py/Node/_add_feedback",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\utils.py/MinHeap",
        "opto\\trace\\utils.py/MinHeap/push",
        "opto\\trace\\utils.py/MinHeap/pop",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/init_feedback",
        "opto\\trace\\propagators\\propagators.py/Propagator/init_feedback"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "clone",
      "md_content": [
        "**clone**: The function of clone is to create and return a duplicate of the current Node object.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters other than the implicit self parameter, which refers to the instance of the Node class.\n\n**Code Description**: The clone function is a method of the Node class that imports the clone function from the opto.trace.operators module and applies it to the current instance (self) of the Node class. The imported clone function from the operators module is responsible for creating a duplicate of the Node instance. This method ensures that the Node object can be cloned using a standardized operation defined in the operators module.\n\nThe clone function is also indirectly referenced by the identity function in the opto.trace.operators module. The identity function calls the clone method on its input parameter, effectively creating a duplicate of the input object. This demonstrates that the clone method is integral to operations that require object duplication within the project.\n\n**Note**: \n- Ensure that the opto.trace.operators module is correctly imported and accessible when using the clone method.\n- The clone method does not modify the original Node object; it only creates and returns a duplicate.\n\n**Output Example**: The return value of the clone function will be a new instance of the Node class that is a duplicate of the original instance. For example, if the original Node instance has specific attributes and states, the cloned instance will have the same attributes and states."
      ],
      "code_start_line": 402,
      "code_end_line": 405,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def clone(self):\n        import opto.trace.operators as ops\n\n        return ops.clone(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\operators.py/identity",
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "detach",
      "md_content": [
        "**detach**: The function of detach is to create and return a deep copy of the current instance of the Node class.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The detach function is designed to create a deep copy of the current instance of the Node class. When this function is called, it utilizes the deepcopy method from the copy module to generate a new instance of the Node class that is a complete copy of the original, including all nested objects. This ensures that any changes made to the new instance do not affect the original instance, and vice versa. The function then returns this new deep-copied instance.\n\n**Note**: \n- Ensure that the copy module is imported before using this function.\n- This function does not modify the original instance; it only creates and returns a new deep-copied instance.\n\n**Output Example**: \nIf the original instance of the Node class has certain attributes and nested objects, calling the detach function will return a new instance with identical attributes and nested objects, but completely independent of the original instance. For example:\n\n```python\noriginal_node = Node()\ndetached_node = original_node.detach()\n# detached_node is a deep copy of original_node\n```"
      ],
      "code_start_line": 407,
      "code_end_line": 408,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def detach(self):\n        return copy.deepcopy(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "getattr",
      "md_content": [
        "**getattr**: The function of getattr is to get the value of the specified attribute from the given object.\n\n**parameters**:\n- self: The object from which the attribute value is to be retrieved.\n- key: A string representing the name of the attribute to be retrieved.\n\n**Code Description**:\nThe `getattr` function is a method of the `Node` class in the `opto.trace.nodes.py` module. It takes in the `self` object, which is an instance of the `Node` class, and a string `key` as parameters. \n\nThe function first imports the `node_getattr` function from the `opto.trace.operators` module. It then calls the `node_getattr` function passing itself (`self`) and the specified attribute (`key`) as arguments. The `node_getattr` function is responsible for retrieving the value of the specified attribute from the `Node` object.\n\nThe `getattr` method is used to access the attributes of the `Node` object. It is called when the `getattr` function is invoked on a `Node` object. The `getattr` method retrieves the value of the specified attribute from the `Node` object by calling the `node_getattr` function.\n\n**Note**:\n- The `getattr` method assumes that the `self` parameter is a valid `Node` object.\n- If the `self` object does not have the specified attribute, a `AttributeError` will be raised.\n\n**Output Example**:\nA possible return value of the `getattr` method could be the value of the specified attribute from the `Node` object."
      ],
      "code_start_line": 411,
      "code_end_line": 414,
      "params": [
        "self",
        "key"
      ],
      "have_return": true,
      "code_content": "    def getattr(self, key):\n        import opto.trace.operators as ops\n\n        return ops.node_getattr(self, node(key))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/call",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/node_getattr"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "call",
      "md_content": [
        "**call**: The function of call is to invoke a specified function with the given arguments and keyword arguments.\n\n**parameters**:\n- self: The object on which the function is called.\n- fun: A string representing the name of the function to be invoked.\n- *args: Variable-length positional arguments to be passed to the function.\n- **kwargs: Variable-length keyword arguments to be passed to the function.\n\n**Code Description**:\nThe `call` function is a method of the `Node` class in the `opto.trace.nodes.py` module. It takes in the `self` object, which is an instance of the `Node` class, a string `fun`, and variable-length positional and keyword arguments (`args` and `kwargs`) as parameters.\n\nThe function first iterates over the `args` and converts each argument to a `Node` object using the `node` function. This is done to ensure that all arguments passed to the function are `Node` objects. The converted arguments are then stored in a generator expression.\n\nNext, the function iterates over the `kwargs` and converts each value to a `Node` object using the `node` function. The converted values are then stored in a dictionary comprehension, with the keys being the original keys from `kwargs`.\n\nFinally, the function calls the `getattr` method of the `self` object, passing the `fun` string as the attribute name. The `getattr` method retrieves the value of the specified attribute from the `self` object. The retrieved attribute is then invoked as a function, passing the converted `args` and `kwargs` as arguments.\n\nThe `call` method is used to dynamically invoke functions on the `Node` object. It allows for flexible and dynamic function calls based on the provided arguments and keyword arguments.\n\n**Note**:\n- The `fun` parameter should be a string representing the name of a valid function that can be invoked on the `self` object.\n- The `args` and `kwargs` parameters can be any valid arguments that can be passed to the specified function.\n- The `call` method assumes that the `self` parameter is a valid `Node` object with the specified function as an attribute.\n\n**Output Example**: A possible return value of the `call` method could be the result of invoking the specified function with the provided arguments and keyword arguments."
      ],
      "code_start_line": 416,
      "code_end_line": 419,
      "params": [
        "self",
        "fun"
      ],
      "have_return": true,
      "code_content": "    def call(self, fun: str, *args, **kwargs):\n        args = (node(arg) for arg in args)  # convert args to nodes\n        kwargs = {k: node(v) for k, v in kwargs.items()}\n        return self.getattr(fun)(*args, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/append",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/Node/getattr"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__call__",
      "md_content": [
        "**__call__**: The function of __call__ is to invoke the `call` function from the `opto.trace.operators` module with the provided arguments and keyword arguments.\n\n**parameters**: The parameters of this function.\n· `*args`: Variable-length argument list.\n· `**kwargs`: Keyword arguments.\n\n**Code Description**: The `__call__` method is designed to facilitate the invocation of a function encapsulated within a Node object. When this method is called, it imports the `call` function from the `opto.trace.operators` module. The `call` function is then executed with the current instance (`self`) and any additional arguments (`*args`) and keyword arguments (`**kwargs`) provided to the `__call__` method.\n\nThe `call` function, as defined in the `opto.trace.operators` module, takes a Node object representing the function to be called, along with any positional and keyword arguments. It ensures that the function encapsulated within the Node object is callable and then invokes it with the provided arguments. The result of this invocation is returned as the output.\n\nBy using the `__call__` method, the Node object can be used as if it were a regular callable function, providing a seamless interface for function invocation.\n\n**Note**:\n- The Node object must encapsulate a callable function.\n- The `*args` parameter can accept any number of positional arguments.\n- The `**kwargs` parameter can accept any number of keyword arguments.\n\n**Output Example**:\nIf the Node object encapsulates a function defined as follows:\n```python\ndef add(a, b):\n    return a + b\n```\nand the `__call__` method is invoked with `args=(2, 3)`, the output will be `5`."
      ],
      "code_start_line": 421,
      "code_end_line": 425,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __call__(self, *args, **kwargs):\n        import opto.trace.operators as ops\n\n        output = ops.call(self, *args, **kwargs)\n        return output\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/call"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "len",
      "md_content": [
        "**len**: The function of len is to return the length of the Node instance.\n\n**parameters**: The parameters of this Function.\n· self: The Node instance whose length is to be calculated.\n\n**Code Description**: The len method is a member of the Node class in the opto.trace.nodes module. This method is designed to compute and return the length of the Node instance. When invoked, the len method imports the len_ function from the opto.trace.operators module and applies it to the Node instance (self). The len_ function is a utility that leverages Python's built-in len() function to determine the length of the input object. By using the len_ function, the len method ensures a consistent and modular approach to length calculation within the project. This design promotes reusability and maintainability, as the len_ function can be utilized across different parts of the project.\n\n**Note**: Ensure that the Node instance supports the len() operation. Passing an unsupported type will result in a TypeError.\n\n**Output Example**: \n- If the Node instance represents a list [1, 2, 3], len(self) will return 3.\n- If the Node instance represents a string \"hello\", len(self) will return 5."
      ],
      "code_start_line": 429,
      "code_end_line": 432,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def len(self):\n        import opto.trace.operators as ops\n\n        return ops.len_(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/len_"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__getitem__",
      "md_content": [
        "**__getitem__**: The function of __getitem__ is to retrieve an element from a Node instance using a specified key.\n\n**parameters**: The parameters of this function.\n· key: The key used to access the element within the Node instance.\n\n**Code Description**: The __getitem__ method is designed to facilitate element retrieval from a Node instance using a specified key. When this method is called, it first imports the getitem function from the opto.trace.operators module. It then uses the node function to create a Node object from the provided key. Finally, it calls the getitem function with the current Node instance (self) and the newly created Node object (from the key) as arguments. This modular approach allows for flexible and reusable element retrieval within the Node class.\n\nThe node function is responsible for creating a Node object from a given message. If the message is already a Node, it returns the message as is. This function simplifies the creation of Node objects and ensures consistency in how Nodes are instantiated.\n\nThe getitem function is a straightforward implementation of the indexing operation. It takes an object and an index as parameters and returns the element located at the specified index within the object. In this context, the getitem function is used to retrieve an element from the Node instance using the key provided to the __getitem__ method.\n\n**Note**:\n- Ensure that the key provided is compatible with the indexing mechanism of the Node instance.\n- The node function should be used to create Node objects instead of directly invoking the Node class.\n\n**Output Example**: If a Node instance contains a list [10, 20, 30] and the key provided is 1, the return value of the __getitem__ method will be 20."
      ],
      "code_start_line": 434,
      "code_end_line": 437,
      "params": [
        "self",
        "key"
      ],
      "have_return": true,
      "code_content": "    def __getitem__(self, key):\n        import opto.trace.operators as ops\n\n        return ops.getitem(self, node(key))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/getitem"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__contains__",
      "md_content": [
        "**__contains__**: The function of __contains__ is to determine if a given item is part of the Node instance.\n\n**parameters**: The parameters of this Function.\n· item: The element to be checked for presence within the Node instance.\n\n**Code Description**: The __contains__ method is a special method in Python that allows the use of the `in` operator to check for membership within an object. In this context, the __contains__ method is part of the Node class in the opto\\trace\\nodes.py module. \n\nWhen the __contains__ method is called, it first imports the `in_` function from the opto.trace.operators module. The `in_` function is designed to determine whether an element `x` is present within a collection `y`. \n\nNext, the __contains__ method converts the `item` into a Node object using the `node` function. The `node` function is responsible for creating a Node object from a given message. If the message is already a Node, it returns the message as is. This ensures that the `item` is always in the form of a Node object before performing the membership test.\n\nFinally, the __contains__ method calls the `in_` function with the Node-converted `item` and the Node instance (`self`) as arguments. The `in_` function then checks if the `item` is present within the Node instance and returns a boolean value indicating the result.\n\n**Note**:\n- The `item` parameter must be convertible to a Node object using the `node` function.\n- The Node instance (`self`) must support the membership test operation.\n\n**Output Example**: \n- If `item` is a Node object that is part of the Node instance, the method will return True.\n- If `item` is not part of the Node instance, the method will return False."
      ],
      "code_start_line": 439,
      "code_end_line": 442,
      "params": [
        "self",
        "item"
      ],
      "have_return": true,
      "code_content": "    def __contains__(self, item):\n        import opto.trace.operators as ops\n\n        return ops.in_(node(item), self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/in_"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__pos__",
      "md_content": [
        "**__pos__**: The function of __pos__ is to return the unary positive of the Node instance.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Node class on which the unary positive operator is applied.\n\n**Code Description**: The __pos__ method is a special method in Python that is invoked when the unary positive operator (+) is used on an instance of the Node class. When this operator is applied, the __pos__ method is called, which in turn imports the pos function from the opto.trace.operators module. The pos function is then called with the Node instance (self) as its argument. The pos function applies the unary positive operator to the input value and returns it. In this context, the unary positive operator does not alter the value of the Node instance; it simply returns the instance itself. This ensures that the unary positive operation is consistently applied to instances of the Node class.\n\n**Note**: \n- The __pos__ method does not modify the Node instance; it simply returns it.\n- Ensure that the Node class instances are of a type that supports the unary positive operator.\n\n**Output Example**: \nIf the Node instance is node_instance, the return value will be node_instance when +node_instance is used."
      ],
      "code_start_line": 445,
      "code_end_line": 448,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __pos__(self):\n        import opto.trace.operators as ops\n\n        return ops.pos(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/pos"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__neg__",
      "md_content": [
        "**__neg__**: The function of __neg__ is to return the negation of the Node instance.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class to be negated.\n\n**Code Description**: The __neg__ method is a special method in Python that is invoked when the unary negation operator (-) is applied to an instance of the Node class. This method imports the neg function from the opto.trace.operators module and applies it to the Node instance (self). The neg function, in turn, returns the negation of its input value using the unary negation operator (-). Therefore, when the __neg__ method is called, it effectively negates the Node object by leveraging the neg function.\n\n**Note**: Ensure that the Node instance supports the unary negation operator to avoid runtime errors.\n\n**Output Example**: If the Node instance represents a value of 5, applying the unary negation operator will result in -5. If the Node instance represents a value of -3.2, applying the unary negation operator will result in 3.2."
      ],
      "code_start_line": 450,
      "code_end_line": 453,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __neg__(self):\n        import opto.trace.operators as ops\n\n        return ops.neg(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/neg"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__abs__",
      "md_content": [
        "**__abs__**: The function of __abs__ is to return the absolute value of the Node instance.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class on which the __abs__ method is called.\n\n**Code Description**: The __abs__ method is a special method in Python that is called when the built-in abs() function is used on an instance of the Node class. When invoked, this method imports the abs function from the opto.trace.operators module and applies it to the Node instance (self). The imported abs function is designed to compute the absolute value of its input, leveraging Python's built-in abs() function. This allows the Node class to utilize the abs function to compute and return the absolute value of its instances.\n\n**Note**: \n- Ensure that the Node instance supports the absolute value operation, either directly or through a custom implementation of the __abs__ method.\n- The behavior and limitations of this method are consistent with Python's built-in abs() function.\n\n**Output Example**: \n- If the Node instance represents a value of -5, the __abs__ method will return 5.\n- If the Node instance represents a value of 3.14, the __abs__ method will return 3.14.\n- If the Node instance is a custom object that implements the __abs__ method, the __abs__ method will return the result of that custom implementation."
      ],
      "code_start_line": 455,
      "code_end_line": 458,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __abs__(self):\n        import opto.trace.operators as ops\n\n        return ops.abs(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/abs"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__invert__",
      "md_content": [
        "**__invert__**: The function of __invert__ is to perform a bitwise NOT operation on the instance of the Node class.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class on which the bitwise NOT operation will be performed.\n\n**Code Description**: The __invert__ method is a special method in Python that allows the use of the bitwise NOT operator (~) on an instance of the Node class. When the ~ operator is applied to a Node instance, the __invert__ method is invoked. This method imports the invert function from the opto.trace.operators module and applies it to the instance (self).\n\nThe invert function, defined in the opto.trace.operators module, takes a single parameter x and returns the result of applying the bitwise NOT operation to x. The bitwise NOT operation inverts each bit of the input value. For example, if x is an integer, each bit in its binary representation will be flipped (0s become 1s and 1s become 0s).\n\nIn this context, the __invert__ method enables the Node class to support the bitwise NOT operation by leveraging the invert function. This allows developers to use the ~ operator directly on Node instances, making the code more intuitive and concise.\n\n**Note**: Ensure that the Node instance supports the bitwise NOT operation. Using types that do not support this operation will result in a TypeError.\n\n**Output Example**: \n- If the Node instance represents an integer with a value of 5, the return value will be -6.\n- If the Node instance represents an integer with a value of 0, the return value will be -1."
      ],
      "code_start_line": 460,
      "code_end_line": 463,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __invert__(self):\n        import opto.trace.operators as ops\n\n        return ops.invert(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/invert"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__round__",
      "md_content": [
        "**__round__**: The function of __round__ is to round the value of the Node object to a specified number of decimal places.\n\n**parameters**: The parameters of this function.\n· n: The number of decimal places to round to. This parameter is optional and can be None.\n\n**Code Description**: The __round__ method is a special method in the Node class that allows rounding the value of the Node object to a specified number of decimal places. It imports the round function from the opto.trace.operators module and applies it to the Node instance (self). If the parameter n is provided, it is converted into a Node object using the node function from the same module. If n is not provided (i.e., it is None), the round function is called with None as the second argument.\n\nThe method works as follows:\n1. It imports the round function from the opto.trace.operators module.\n2. It checks if the parameter n is provided.\n3. If n is provided, it converts n into a Node object using the node function.\n4. It calls the round function with the Node instance (self) and the converted n (or None if n is not provided).\n5. It returns the result of the round function.\n\nThe relationship with its callees is as follows:\n- The node function is used to convert the parameter n into a Node object if n is provided.\n- The round function is used to perform the actual rounding operation on the Node instance.\n\n**Note**: \n- Ensure that the parameter n, if provided, can be interpreted as an integer to avoid runtime errors.\n- The method relies on the round function from the opto.trace.operators module, which is a wrapper around Python's built-in round function.\n\n**Output Example**: \nIf the Node instance represents the value 3.14159 and n is 2, the method will return a Node object representing the value 3.14.\nIf the Node instance represents the value 3.14159 and n is 0, the method will return a Node object representing the value 3."
      ],
      "code_start_line": 465,
      "code_end_line": 468,
      "params": [
        "self",
        "n"
      ],
      "have_return": true,
      "code_content": "    def __round__(self, n=None):\n        import opto.trace.operators as ops\n\n        return ops.round(self, node(n) if n is not None else None)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/round"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__floor__",
      "md_content": [
        "**__floor__**: The function of __floor__ is to compute the largest integer less than or equal to the value of the current Node instance.\n\n**parameters**: The parameters of this Function.\n· self: An instance of the Node class.\n\n**Code Description**: The __floor__ method is a special method in the Node class that allows instances of Node to be floored directly. When this method is called, it imports the floor function from the opto.trace.operators module and applies it to the current instance (self). The floor function, in turn, computes the largest integer less than or equal to the given number using Python's math.floor method. This operation is useful for rounding down the value of the Node instance to the nearest whole number.\n\n**Note**: Ensure that the Node instance holds a numeric value that can be floored. If the value is not numeric, the floor function will raise a TypeError. Additionally, the math module must be available in the environment for the floor function to work correctly.\n\n**Output Example**: \n- If the Node instance has a value of 3.7, calling __floor__() will return 3.\n- If the Node instance has a value of -2.3, calling __floor__() will return -3."
      ],
      "code_start_line": 470,
      "code_end_line": 473,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __floor__(self):\n        import opto.trace.operators as ops\n\n        return ops.floor(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/floor"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__ceil__",
      "md_content": [
        "**__ceil__**: The function of __ceil__ is to return the smallest integer greater than or equal to the value represented by the Node instance.\n\n**parameters**: The parameters of this Function.\n· self: An instance of the Node class.\n\n**Code Description**: The __ceil__ method is a special method in the Node class that provides a ceiling operation on the Node instance. When invoked, it imports the ceil function from the opto.trace.operators module and applies it to the Node instance (self). The ceil function, in turn, rounds up the numeric value represented by the Node instance to the nearest integer. This method leverages the functionality of the ceil function to ensure that the Node instance's value is rounded up correctly.\n\nThe ceil function, which is called within __ceil__, is designed to handle any numeric type and uses the math.ceil() method from the math module to perform the rounding operation. By importing and utilizing this function, the __ceil__ method ensures that the Node instance's value is processed accurately and efficiently.\n\n**Note**: Ensure that the Node instance represents a numeric value; otherwise, the ceil function will raise a TypeError. The math module must be available in the environment where the code is executed.\n\n**Output Example**: \n- If the Node instance represents the value 4.2, __ceil__() will return 5.\n- If the Node instance represents the value -3.7, __ceil__() will return -3.\n- If the Node instance represents the value 7, __ceil__() will return 7."
      ],
      "code_start_line": 475,
      "code_end_line": 478,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __ceil__(self):\n        import opto.trace.operators as ops\n\n        return ops.ceil(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/ceil"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__trunc__",
      "md_content": [
        "**__trunc__**: The function of __trunc__ is to truncate the decimal part of a Node object, returning its integer part.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class that is to be truncated.\n\n**Code Description**: The __trunc__ method is a special method in the Node class that allows instances of Node to be truncated to their integer representation. When __trunc__ is called on a Node instance, it imports the trunc function from the opto.trace.operators module and applies it to the instance (self). The trunc function, in turn, utilizes Python's math.trunc function to truncate the decimal part of the number, returning only the integer part. This ensures that any Node object can be converted to its integer form when necessary.\n\n**Note**: \n- The Node instance should be compatible with the math.trunc function, typically meaning it should represent a numerical value.\n- If the Node instance does not represent a number, the trunc function will raise a TypeError.\n\n**Output Example**: \nIf a Node instance represents the value 3.14, calling __trunc__ on this instance will return 3.\nIf a Node instance represents the value -2.99, calling __trunc__ on this instance will return -2."
      ],
      "code_start_line": 480,
      "code_end_line": 483,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __trunc__(self):\n        import opto.trace.operators as ops\n\n        return ops.trunc(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\operators.py/trunc"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__add__",
      "md_content": [
        "**__add__**: The function of __add__ is to define the addition operation for Node objects, allowing them to be combined with other values.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node class.\n· other: The value to be added to the current Node instance. This can be of any type.\n\n**Code Description**: The __add__ method in the Node class is designed to handle the addition of a Node object with another value. It first imports the necessary operators from the opto.trace.operators module. The method then checks the type of the _data attribute of the Node instance. If _data is a string, it uses the concat function from the operators module to concatenate the current Node instance with another Node instance created from the other parameter. If _data is not a string, it uses the add function from the operators module to add the current Node instance to another Node instance created from the other parameter.\n\nThe node function is used to ensure that the other parameter is converted into a Node object if it is not already one. This function provides a convenient way to create Node objects from various types of messages, ensuring consistency and ease of use.\n\nThe __add__ method is also called by the __radd__ method in the Node class, which allows for the reverse addition operation. This means that if the other parameter is on the left side of the addition operation, the __radd__ method will be invoked, which in turn calls the __add__ method to perform the addition.\n\n**Note**: \n- Ensure that the types of the _data attribute and the other parameter are compatible with the + operator to avoid runtime errors.\n- The behavior of the + operator varies depending on the types of the operands. For example, it concatenates strings and lists but adds numbers.\n\n**Output Example**: \n- If self._data is \"Hello\" and other is \"World\", the return value will be a Node object with _data \"HelloWorld\".\n- If self._data is 3 and other is 5, the return value will be a Node object with _data 8."
      ],
      "code_start_line": 486,
      "code_end_line": 492,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __add__(self, other):\n        import opto.trace.operators as ops\n\n        if type(self._data) is str:\n            return ops.concat(self, node(other))\n        else:\n            return ops.add(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__radd__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/add",
        "opto\\trace\\operators.py/concat"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__radd__",
      "md_content": [
        "**__radd__**: The function of __radd__ is to handle the reverse addition operation for Node objects, allowing them to be combined with other values when the Node instance is on the right side of the addition.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node class.\n· other: The value to be added to the current Node instance. This can be of any type.\n\n**Code Description**: The __radd__ method in the Node class is designed to facilitate the addition operation when the Node instance appears on the right side of the addition operator. This method is invoked when the left operand does not support the addition operation with the right operand, which is an instance of the Node class. The __radd__ method simply calls the __add__ method of the Node class, passing the other parameter to it. This ensures that the addition logic defined in the __add__ method is reused, maintaining consistency in how Node objects are combined with other values.\n\nThe __add__ method, which is called by __radd__, handles the addition by checking the type of the _data attribute of the Node instance. If _data is a string, it concatenates the current Node instance with another Node instance created from the other parameter using the concat function from the opto.trace.operators module. If _data is not a string, it adds the current Node instance to another Node instance created from the other parameter using the add function from the same module. The node function ensures that the other parameter is converted into a Node object if it is not already one.\n\n**Note**: \n- Ensure that the types of the _data attribute and the other parameter are compatible with the + operator to avoid runtime errors.\n- The behavior of the + operator varies depending on the types of the operands. For example, it concatenates strings and lists but adds numbers.\n\n**Output Example**: \n- If self._data is \"Hello\" and other is \"World\", the return value will be a Node object with _data \"HelloWorld\".\n- If self._data is 3 and other is 5, the return value will be a Node object with _data 8."
      ],
      "code_start_line": 494,
      "code_end_line": 495,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __radd__(self, other):\n        return self.__add__(other)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node/__add__"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__sub__",
      "md_content": [
        "**__sub__**: The function of __sub__ is to perform a subtraction operation between the current Node object and another operand.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node object.\n· other: The operand to be subtracted from the current Node object. This operand can be any type that can be converted into a Node object.\n\n**Code Description**: The __sub__ method is designed to enable the use of the subtraction operator (-) between Node objects or between a Node object and another operand. When the subtraction operator is used, this method is invoked. The method first imports the subtract function from the opto.trace.operators module. It then calls the node function from the opto.trace.nodes module to ensure that the operand 'other' is converted into a Node object if it is not already one. Finally, it calls the subtract function with the current Node object (self) and the newly created Node object from the operand 'other'. The subtract function performs the actual subtraction operation and returns the result.\n\n**Note**: \n- Ensure that the operand 'other' is of a type that can be converted into a Node object to avoid runtime errors.\n- The node function is used to handle the conversion of the operand into a Node object, providing flexibility in the types of operands that can be used with the subtraction operator.\n\n**Output Example**: \n- If self is a Node object representing the value 10 and other is a Node object representing the value 5, the __sub__ method will return a Node object representing the value 5.\n- If self is a Node object representing a list [1, 2, 3] and other is a Node object representing a list [1, 1, 1], the __sub__ method will return a Node object representing the list [0, 1, 2] (assuming the subtraction operation is defined for lists in this context)."
      ],
      "code_start_line": 497,
      "code_end_line": 500,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __sub__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.subtract(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/subtract"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__mul__",
      "md_content": [
        "**__mul__**: The function of __mul__ is to enable the multiplication operation for Node objects using the * operator.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node object.\n· other: The operand to be multiplied with the current Node instance. This can be any type that is compatible with the multiplication operation.\n\n**Code Description**: The __mul__ method allows for the multiplication of a Node object with another operand. When the * operator is used with a Node instance, this method is invoked. It imports the multiply function from the opto.trace.operators module and the node function from the opto.trace.nodes module.\n\nThe method first converts the other operand into a Node object using the node function. This ensures that the operand is in a compatible format for the multiplication operation. The node function checks if the operand is already a Node and returns it as is if true. Otherwise, it creates a new Node object from the operand.\n\nAfter converting the operand, the method calls the multiply function with the current Node instance (self) and the newly created Node object as arguments. The multiply function performs the multiplication operation and returns the result.\n\nThis design allows for seamless multiplication of Node objects or Node-compatible objects using the * operator, enhancing the flexibility and usability of the Node class.\n\n**Note**: Ensure that the operand passed to the * operator is compatible with the multiplication operation to avoid runtime errors. If the operand does not support multiplication, a TypeError will be raised.\n\n**Output Example**: If self is a Node object representing the value 3 and other is 4, the result of self * other will be a Node object representing the value 12."
      ],
      "code_start_line": 502,
      "code_end_line": 505,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __mul__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.multiply(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/multiply"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__floordiv__",
      "md_content": [
        "**__floordiv__**: The function of __floordiv__ is to perform floor division between a Node object and another operand.\n\n**parameters**: The parameters of this function.\n· self: The Node object on which the floor division operation is invoked.\n· other: The operand with which the floor division is to be performed. This can be any type that supports the floor division operation.\n\n**Code Description**: The __floordiv__ method is a special method in the Node class that enables the use of the floor division operator (//) between a Node object and another operand. When this method is called, it imports the floor_divide function from the opto.trace.operators module and the node function from the opto.trace.nodes module.\n\nThe method first converts the other operand into a Node object using the node function. This ensures that the operand is compatible with the Node class's operations. It then applies the floor_divide function to the Node object (self) and the newly created Node object (other). The floor_divide function performs the floor division operation, which divides the two operands and rounds down the result to the nearest integer.\n\nThis method ensures that the floor division operation is performed correctly and consistently within the project's framework by leveraging the floor_divide function. The use of the node function guarantees that the other operand is appropriately handled as a Node object, maintaining the integrity of the Node class's operations.\n\n**Note**: Ensure that the other operand is of a type that supports the floor division operation to avoid runtime errors. The method relies on the floor_divide function, which does not perform type checking or validation, so improper types may lead to unexpected behavior or exceptions.\n\n**Output Example**: If self is a Node object representing the value 7 and other is an operand representing the value 3, the method call self // other will return a Node object representing the value 2, as 7 // 3 equals 2."
      ],
      "code_start_line": 507,
      "code_end_line": 510,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __floordiv__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.floor_divide(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/floor_divide"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__truediv__",
      "md_content": [
        "**__truediv__**: The function of __truediv__ is to perform division between the current Node instance and another operand.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node class.\n· other: The operand to divide the current Node instance by. This can be any type that supports division.\n\n**Code Description**: The __truediv__ method is designed to handle the division operation for Node objects. When the division operator (/) is used between a Node instance and another operand, this method is invoked. The method first imports the divide function from the opto.trace.operators module. It then converts the other operand into a Node object using the node function from the opto.trace.nodes module. This ensures that both operands are Node objects, maintaining consistency within the framework. Finally, the method returns the result of the divide function, which performs the actual division operation between the two Node objects.\n\n**Note**: \n- Ensure that the divisor (other) is not zero to avoid a ZeroDivisionError.\n- The other operand should be of a type that supports the division operation.\n- The node function is used to convert the other operand into a Node object if it is not already one, ensuring compatibility within the Node framework.\n\n**Output Example**: If the current Node instance represents the value 10 and the other operand represents the value 2, the method will return a Node object representing the value 5.0."
      ],
      "code_start_line": 512,
      "code_end_line": 515,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __truediv__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.divide(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/divide"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__mod__",
      "md_content": [
        "**__mod__**: The function of __mod__ is to perform the modulo operation between the current Node object and another value.\n\n**parameters**: The parameters of this function.\n· other: The value to be used as the divisor in the modulo operation. It can be of any type that supports the modulo operation.\n\n**Code Description**: The __mod__ method is designed to enable the modulo operation between a Node object and another value. When this method is called, it first imports the mod function from the opto.trace.operators module. It then calls the node function to ensure that the other value is converted into a Node object if it is not already one. Finally, it applies the mod function to the current Node object (self) and the converted Node object (node(other)), and returns the result.\n\nThe node function is responsible for creating a Node object from a given message. If the message is already a Node, it returns it as is. This ensures that the other value is always in the form of a Node object before the modulo operation is performed.\n\nThe mod function takes two parameters, x and y, and returns the result of the modulo operation (x % y). This operation finds the remainder when x is divided by y. By integrating the mod function with the __mod__ method, Node objects can seamlessly perform the modulo operation with other values, enhancing their arithmetic capabilities.\n\n**Note**: Ensure that the other value provided is of a type that supports the modulo operation to avoid runtime errors.\n\n**Output Example**: If the current Node object represents the value 10 and the other value is 3, the return value will be a Node object representing the value 1. If the current Node object represents the value 20 and the other value is 7, the return value will be a Node object representing the value 6."
      ],
      "code_start_line": 517,
      "code_end_line": 520,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __mod__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.mod(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/mod"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__divmod__",
      "md_content": [
        "**__divmod__**: The function of __divmod__ is to perform the divmod operation on a Node object and another operand, returning the result.\n\n**parameters**: The parameters of this function.\n· self: The Node instance on which the __divmod__ method is called.\n· other: The operand to be used in the divmod operation with the Node instance.\n\n**Code Description**: The __divmod__ method is designed to enable the use of the divmod operation on Node objects within the project. When this method is called, it first imports the divmod function from the opto.trace.operators module and the node function from the opto.trace.nodes module. The method then converts the other operand into a Node object using the node function. This ensures that the divmod operation is performed between two Node objects, maintaining consistency within the project's framework.\n\nThe core functionality of the __divmod__ method is to delegate the actual divmod operation to the divmod function imported from opto.trace.operators. This function takes two parameters, x and y, and applies Python's built-in divmod function to them, returning a tuple containing the quotient and the remainder. By using this approach, the __divmod__ method ensures that the divmod operation can be seamlessly integrated with Node objects, providing a consistent interface for performing division and modulus operations within the project's tracing framework.\n\n**Note**: Ensure that the other operand is of a type that can be converted into a Node object to avoid runtime errors. The method relies on the node function to handle this conversion, so any constraints or behaviors of the node function will apply here as well.\n\n**Output Example**: If the Node instance represents the value 10 and the other operand is 3, the return value will be a tuple (3, 1), where 3 is the quotient and 1 is the remainder."
      ],
      "code_start_line": 522,
      "code_end_line": 525,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __divmod__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.divmod(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/divmod"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__pow__",
      "md_content": [
        "**__pow__**: The function of __pow__ is to enable the power operation (exponentiation) on Node objects.\n\n**parameters**: The parameters of this function.\n· self: The Node object on which the power operation is being performed.\n· other: The exponent value, which can be of any type that supports the power operation.\n\n**Code Description**: The __pow__ method allows for the use of the power operator (**) directly on Node objects. When this method is called, it imports the power function from the opto.trace.operators module and applies it to the Node object (self) and the other value (other). \n\nThe method first imports the necessary operators from the opto.trace.operators module. It then calls the power function, passing in the current Node object (self) and the result of the node function applied to the other value. The node function ensures that the other value is converted into a Node object if it is not already one, providing a consistent interface for the power operation.\n\nThis integration allows for intuitive mathematical operations within the project's framework, enabling users to perform exponentiation on Node objects seamlessly.\n\n**Note**: \n- Ensure that the types of self and other are compatible with the power operation to avoid runtime errors.\n- The node function is used to convert the other value into a Node object if it is not already one, ensuring consistency in the operation.\n\n**Output Example**: \nIf self is a Node object representing the value 2 and other is 3, the function will return a Node object representing the value 8, as 2**3 equals 8."
      ],
      "code_start_line": 527,
      "code_end_line": 530,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __pow__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.power(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/power"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__lshift__",
      "md_content": [
        "**__lshift__**: The function of __lshift__ is to perform a left bitwise shift operation on a Node object using another operand.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node class.\n· other: The operand to be used for the left bitwise shift operation.\n\n**Code Description**: The __lshift__ method in the Node class is designed to facilitate the left bitwise shift operation using the << operator. When this method is invoked, it imports the lshift function from the opto.trace.operators module and the node function from the same module where the Node class is defined. The method then calls the lshift function, passing the current Node instance (self) and the result of the node function applied to the other operand.\n\nThe node function ensures that the other operand is converted into a Node object if it is not already one. This conversion is crucial for maintaining consistency within the Node class operations. The lshift function then performs the left bitwise shift operation on the two Node objects, self and the converted other operand, and returns the result.\n\nThis method allows instances of the Node class to use the << operator for left bitwise shift operations, leveraging the underlying lshift function to handle the actual bitwise manipulation.\n\n**Note**: \n- Ensure that the other operand is of a type that can be converted into a Node object using the node function.\n- The left bitwise shift operation is typically used with integer values, so the operands should support this operation to avoid runtime errors.\n\n**Output Example**: \nIf the current Node instance represents the value 4 (binary 100) and the other operand is 2, the method will return a Node object representing the value 16 (binary 10000), as the bits of 4 are shifted left by 2 positions."
      ],
      "code_start_line": 532,
      "code_end_line": 535,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __lshift__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.lshift(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/lshift"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__rshift__",
      "md_content": [
        "**__rshift__**: The function of __rshift__ is to perform a bitwise right shift operation on the current Node instance and another operand.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node class.\n· other: The operand to be right-shifted with the current Node instance.\n\n**Code Description**: The __rshift__ method is a special method in the Node class that facilitates the bitwise right shift operation between the current Node instance (self) and another operand (other). This method first imports the rshift function from the opto.trace.operators module. It then calls this rshift function, passing the current Node instance (self) and the result of the node function applied to the other operand.\n\nThe node function is used to ensure that the other operand is converted into a Node object if it is not already one. This conversion is necessary to maintain consistency and compatibility within the Node class operations. The rshift function, once called, performs the bitwise right shift operation (x >> y) on the two operands.\n\n**Note**:\n- Ensure that the other operand is of a type that supports the right shift operation to avoid runtime errors.\n- The node function is used to convert the other operand into a Node object if it is not already one, ensuring compatibility within the Node class operations.\n\n**Output Example**: If the current Node instance represents the value 8 (binary 1000) and the other operand is 2, the __rshift__ method will return a Node object representing the value 2 (binary 10)."
      ],
      "code_start_line": 537,
      "code_end_line": 540,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __rshift__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.rshift(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/rshift"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__and__",
      "md_content": [
        "**__and__**: The function of __and__ is to perform a bitwise AND operation between the current Node object and another operand.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node object.\n· other: The operand to perform the bitwise AND operation with. This can be any type that supports the bitwise AND operation.\n\n**Code Description**: The __and__ method is designed to facilitate the bitwise AND operation between a Node object and another operand. When this method is called, it first imports the necessary operators from the `opto.trace.operators` module. Specifically, it imports the `and_` function, which is responsible for executing the bitwise AND operation.\n\nThe method then calls the `node` function from the `opto.trace.nodes` module to ensure that the `other` operand is converted into a Node object if it is not already one. The `node` function is a utility that either returns the operand as a Node object or creates a new Node object from the operand.\n\nFinally, the `__and__` method applies the `and_` function to the current Node object (`self`) and the converted Node object (`node(other)`). The `and_` function performs the bitwise AND operation and returns the result.\n\n**Note**: \n- Ensure that the `other` operand is of a type that supports the bitwise AND operation to avoid runtime errors.\n- The `node` function is used to standardize the operand into a Node object, which simplifies the operation and ensures consistency.\n\n**Output Example**: If the current Node object represents the value 6 (binary 110) and the `other` operand represents the value 3 (binary 011), the method call `self.__and__(other)` will return a Node object representing the value 2 (binary 010)."
      ],
      "code_start_line": 542,
      "code_end_line": 545,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __and__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.and_(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/and_"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__or__",
      "md_content": [
        "**__or__**: The function of __or__ is to perform a bitwise OR operation between the current Node instance and another Node instance.\n\n**parameters**: The parameters of this function.\n· self: The current Node instance.\n· other: Another Node instance or a message that can be converted into a Node.\n\n**Code Description**: The __or__ method is designed to enable the use of the \"|\" operator to combine two Node instances using a bitwise OR operation. When the \"|\" operator is used between two Node instances, this method is invoked.\n\n1. The method first imports the `or_` function from the `opto.trace.operators` module.\n2. It then calls the `node` function to ensure that the `other` parameter is converted into a Node instance if it is not already one.\n3. Finally, it applies the `or_` function to the current Node instance (`self`) and the converted Node instance (`other`), returning the result.\n\nThe `node` function is responsible for creating a Node object from a message, ensuring that the `other` parameter is in the correct format for the bitwise OR operation. The `or_` function performs the actual bitwise OR operation between the two Node instances.\n\n**Note**: Ensure that the `other` parameter can be converted into a Node instance to avoid errors. The `or_` function expects both operands to support the bitwise OR operation.\n\n**Output Example**: If `self` is a Node instance representing the binary value 0101 and `other` is a Node instance representing the binary value 0011, the return value of `self | other` would be a Node instance representing the binary value 0111."
      ],
      "code_start_line": 547,
      "code_end_line": 550,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __or__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.or_(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/or_"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__xor__",
      "md_content": [
        "**__xor__**: The function of __xor__ is to perform a bitwise XOR operation between the current Node instance and another Node instance or value.\n\n**parameters**: The parameters of this function.\n· self: The current Node instance.\n· other: Another Node instance or value to perform the XOR operation with.\n\n**Code Description**: The __xor__ method is designed to enable the use of the ^ operator to perform a bitwise XOR operation between Node objects. This method imports the xor function from the opto.trace.operators module and applies it to the current Node instance (self) and another Node instance or value (other). \n\nThe method first imports the necessary operators from the opto.trace.operators module. It then calls the xor function, passing in the current Node instance (self) and the result of the node function applied to the other parameter. The node function ensures that the other parameter is converted into a Node object if it is not already one. This allows for seamless integration and operation between Node objects and other values.\n\nThe xor function itself performs the bitwise XOR operation, which compares each bit of its operands and returns 1 if the bits are different, and 0 if they are the same. This operation is useful in various scenarios, such as cryptography, error detection, and correction algorithms.\n\n**Note**: Ensure that the other parameter is of a type that supports the bitwise XOR operation, such as integers or objects that implement the __xor__ method. The node function will handle the conversion of the other parameter to a Node object if necessary.\n\n**Output Example**: If the current Node instance represents the value 5 (binary 0101) and the other parameter represents the value 3 (binary 0011), the result of the __xor__ method would be a Node object representing the value 6 (binary 0110)."
      ],
      "code_start_line": 552,
      "code_end_line": 555,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __xor__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.xor(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\operators.py/xor"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__iter__",
      "md_content": [
        "**__iter__**: The function of __iter__ is to provide an iterable interface for the Node object, allowing it to be iterated over in a consistent manner.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The __iter__ method is designed to make the Node object iterable. When called, it imports the iterate function from the opto.trace.containers module. The iterate function is then invoked with the Node object (self) as its argument. The iterate function determines the appropriate iterable class to use based on the type of the Node object's data attribute. It handles various types of collections such as lists, tuples, sets, and dictionaries, and returns an iterable object accordingly. This ensures that the Node object can be iterated over seamlessly, regardless of the type of its data attribute.\n\n**Note**: \n- The Node object must have a data attribute that is a list, tuple, set, or dictionary.\n- The iterate function handles the conversion of sets to lists and wraps items in lists or dictionaries with node objects.\n\n**Output Example**: \nIf the Node object's data attribute is a list [1, 2, 3], iterating over the Node object would yield:\n```\nnode(1)\nnode(2)\nnode(3)\n```\nIf the Node object's data attribute is a dictionary {'a': 1, 'b': 2}, iterating over the Node object would yield:\n```\n(node('a'), 1)\n(node('b'), 2)\n```"
      ],
      "code_start_line": 557,
      "code_end_line": 560,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __iter__(self):\n        import opto.trace.containers as ct\n\n        return ct.iterate(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\containers.py/iterate"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__len__",
      "md_content": [
        "**__len__**: The function of __len__ is to return the number of elements contained in the Node object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Node class.\n\n**Code Description**: The __len__ method is a special method in Python that is used to define the behavior of the len() function for instances of a class. In this implementation, the __len__ method returns the length of the internal data structure, self._data, which is assumed to be a collection such as a list, dictionary, or any other iterable. The method ensures that the return type is an integer, which is a requirement for the __len__ method in Python. This method provides a straightforward way to get the size of the Node's data without directly accessing the internal data structure.\n\n**Note**: \n- The __len__ method strictly returns an integer value representing the number of elements in the Node's internal data structure.\n- If users need a Node object representing the length, they should use a different method, such as node.len(), instead of __len__.\n\n**Output Example**: \nIf the Node's internal data structure, self._data, contains 5 elements, calling len(node_instance) will return:\n5"
      ],
      "code_start_line": 562,
      "code_end_line": 566,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __len__(self):\n        # __len__ restricts return type to be integer\n        # therefore, we only return integer here\n        # if users want a Node, they need to call node.len() instead\n        return len(self._data)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__lt__",
      "md_content": [
        "**__lt__**: The function of __lt__ is to define the behavior of the less-than operator (<) for Node objects.\n\n**parameters**: The parameters of this function.\n· self: The instance of the Node object on the left-hand side of the < operator.\n· other: The object on the right-hand side of the < operator, which can be another Node or a value that can be converted into a Node.\n\n**Code Description**: The __lt__ method is a special method in Python that allows objects to implement behavior for the less-than operator (<). In this implementation, the method first imports the necessary operators from the opto.trace.operators module. It then calls the lt function from the operators module, passing in the current Node instance (self) and the result of converting the other object into a Node using the node function.\n\nThe node function is responsible for creating a Node object from the other parameter. If the other parameter is already a Node, it is returned as is. Otherwise, a new Node object is created from the other parameter. This ensures that the lt function always receives Node objects as its arguments.\n\nThe lt function from the operators module performs the actual comparison between the two Node objects and returns the result.\n\n**Note**: \n- The __lt__ method relies on the node function to ensure that the other parameter is converted into a Node object if it is not already one.\n- The comparison logic is delegated to the lt function from the opto.trace.operators module.\n\n**Output Example**: A possible return value of the __lt__ method could be a boolean value, such as True or False, indicating whether the current Node instance is less than the other Node instance or value."
      ],
      "code_start_line": 572,
      "code_end_line": 575,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __lt__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.lt(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__le__",
      "md_content": [
        "**__le__**: The function of __le__ is to define the behavior of the \"less than or equal to\" (<=) comparison operator for Node objects.\n\n**parameters**: The parameters of this function.\n· self: The instance of the Node object on the left-hand side of the <= operator.\n· other: The object on the right-hand side of the <= operator, which can be another Node or a value that can be converted into a Node.\n\n**Code Description**: The __le__ function is a special method in Python that allows the use of the <= operator with Node objects. When the <= operator is used, this method is called with the Node instance (self) and the other object (other) being compared.\n\n1. The function imports the operators module from the opto.trace package as ops.\n2. It then calls the le function from the ops module, passing in the current Node instance (self) and the result of the node function applied to the other object.\n\nThe node function is used to ensure that the other object is converted into a Node if it is not already one. This conversion is necessary because the le function in the ops module expects both arguments to be Node objects.\n\nThe le function in the ops module performs the actual comparison between the two Node objects and returns the result.\n\n**Note**:\n- The __le__ method ensures that comparisons using the <= operator are consistent and meaningful for Node objects.\n- The node function is used to handle the conversion of the other object to a Node, ensuring compatibility with the le function in the ops module.\n\n**Output Example**: A possible return value of the __le__ function could be a boolean value, such as True or False, indicating whether the left-hand side Node is less than or equal to the right-hand side Node."
      ],
      "code_start_line": 580,
      "code_end_line": 583,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __le__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.le(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__gt__",
      "md_content": [
        "**__gt__**: The function of __gt__ is to compare if the current Node object is greater than another object.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node object.\n· other: The object to compare with the current Node instance.\n\n**Code Description**: The __gt__ method is a special method in Python used to define the behavior of the greater-than operator (>) for instances of a class. In this implementation, the method first imports the operators module from the opto.trace package. It then calls the gt function from the operators module, passing the current Node instance (self) and another Node instance created from the other parameter using the node function.\n\nThe node function is responsible for converting the other parameter into a Node object if it is not already one. This ensures that the comparison is always between two Node objects. The gt function from the operators module performs the actual comparison and returns the result.\n\n**Note**:\n- The other parameter can be any object that can be converted into a Node using the node function.\n- The comparison relies on the gt function from the operators module, which should be defined to handle Node comparisons appropriately.\n\n**Output Example**: A possible return value of the __gt__ method could be a boolean value, such as True or False, indicating whether the current Node instance is greater than the other object."
      ],
      "code_start_line": 588,
      "code_end_line": 591,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __gt__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.gt(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__ge__",
      "md_content": [
        "**__ge__**: The function of __ge__ is to compare the current Node object with another object to determine if the current Node is greater than or equal to the other object.\n\n**parameters**: The parameters of this function.\n· self: The current instance of the Node object.\n· other: The object to compare with the current Node.\n\n**Code Description**: The __ge__ method is a special method in Python used to define the behavior of the greater than or equal to (>=) operator for instances of a class. In this implementation, the method imports the `opto.trace.operators` module as `ops` and uses the `ge` function from this module to perform the comparison.\n\nThe method first converts the `other` object into a Node object using the `node` function. This ensures that the comparison is always between two Node objects, regardless of the initial type of `other`. The `node` function is designed to create a Node object from a given message, handling various scenarios such as whether the message is already a Node, whether it should be trainable, and whether it has any constraints.\n\nOnce the `other` object is converted into a Node, the `ge` function from the `ops` module is called with `self` and the newly created Node as arguments. The `ge` function is responsible for performing the actual comparison and returning the result.\n\n**Note**:\n- The `__ge__` method ensures that comparisons are always made between Node objects by converting the `other` object using the `node` function.\n- The `node` function handles various scenarios to create a Node object, making the comparison process robust and flexible.\n\n**Output Example**: A possible return value of the `__ge__` method could be a boolean value, such as `True` or `False`, indicating whether the current Node is greater than or equal to the `other` object."
      ],
      "code_start_line": 596,
      "code_end_line": 599,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __ge__(self, other):\n        import opto.trace.operators as ops\n\n        return ops.ge(self, node(other))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__eq__",
      "md_content": [
        "**__eq__**: The function of __eq__ is to compare the current Node object with another object to determine if they are equal.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class.\n· other: The object to compare with the current Node instance.\n\n**Code Description**: The __eq__ method is designed to enable comparison between a Node object and another object to check for equality. The method first checks if the 'other' object is an instance of the Node class. If it is, the method extracts the 'data' attribute from the 'other' Node object. Then, it compares the '_data' attribute of the current Node instance with the 'other' object (or its 'data' attribute if 'other' is a Node). The method returns True if the '_data' attributes are equal, and False otherwise.\n\n**Note**: \n- This method overrides the default equality comparison behavior in Python.\n- It ensures that two Node objects are considered equal if their '_data' attributes are equal.\n- If 'other' is not a Node instance, the method directly compares 'self._data' with 'other'.\n\n**Output Example**: \n- If `self._data` is 5 and `other` is a Node instance with `data` attribute 5, the method returns True.\n- If `self._data` is 5 and `other` is 10, the method returns False."
      ],
      "code_start_line": 606,
      "code_end_line": 611,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __eq__(self, other):\n        # import opto.trace.operators as ops\n        # return ops.eq(self, node(other))\n        if isinstance(other, Node):\n            other = other.data\n        return self._data == other\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__hash__",
      "md_content": [
        "**__hash__**: The function of __hash__ is to return the hash value of the Node object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Node class.\n\n**Code Description**: The __hash__ method in the Node class is an override of the built-in __hash__ method. It calls the __hash__ method of its superclass using the super() function. This ensures that the hash value of the Node object is consistent with the hash value defined in its superclass. By doing so, it maintains the integrity and uniqueness of the hash value for instances of the Node class, which is crucial for operations that rely on hashing, such as using Node instances as keys in dictionaries or storing them in sets.\n\n**Note**: \n- The __hash__ method should be consistent with the __eq__ method. If two objects are considered equal (using the __eq__ method), they must return the same hash value.\n- Overriding the __hash__ method is essential when you need custom behavior for hashing, but in this case, it simply defers to the superclass implementation.\n\n**Output Example**: The return value of the __hash__ method will be an integer representing the hash value of the Node object, as determined by the superclass's __hash__ method. For example, if the superclass's __hash__ method returns 123456 for a particular Node instance, then calling hash(node_instance) will also return 123456."
      ],
      "code_start_line": 613,
      "code_end_line": 614,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __hash__(self):\n        return super().__hash__()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__bool__",
      "md_content": [
        "**__bool__**: The function of __bool__ is to provide a boolean representation of the Node object.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Node class.\n\n**Code Description**: The __bool__ method is a special method in Python that is used to define the boolean value of an object. In this implementation, the method returns the boolean value of the instance variable `_data`. The expression `bool(self._data)` converts `_data` to its boolean equivalent. If `_data` is a non-empty value (such as a non-empty list, string, or a non-zero number), the method will return `True`. If `_data` is an empty value (such as an empty list, string, or zero), the method will return `False`. This allows the Node object to be used in boolean contexts, such as in conditional statements.\n\n**Note**: \n- Ensure that the `_data` attribute is properly initialized in the Node class, as its value directly affects the boolean representation of the Node object.\n- This method does not trace the conversion process, meaning it directly returns the boolean value without additional logging or processing.\n\n**Output Example**: \n- If `_data` is a non-empty list, e.g., `[1, 2, 3]`, the return value will be `True`.\n- If `_data` is an empty list, e.g., `[]`, the return value will be `False`."
      ],
      "code_start_line": 616,
      "code_end_line": 618,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __bool__(self):\n        # not tracing this conversion\n        return bool(self._data)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "format",
      "md_content": [
        "**format**: The function of format is to format the data contained within the Node object if the data is a string.\n\n**parameters**: The parameters of this Function.\n· *args: Variable length argument list.\n· **kwargs: Arbitrary keyword arguments.\n\n**Code Description**: The `format` function first checks if the `_data` attribute of the Node object is of type `str`. If `_data` is not a string, it raises an `AttributeError` indicating that the object does not have a `format` attribute. This ensures that only string data can be formatted using this function. \n\nNext, the function imports the `opto.trace.operators` module as `ops`. It then calls the `format` function from the `ops` module, passing the current Node object (`self`) along with any additional arguments (`*args`) and keyword arguments (`**kwargs`). This delegation allows the `format` function in the `ops` module to handle the actual formatting logic.\n\n**Note**: \n- Ensure that the `_data` attribute of the Node object is a string before calling the `format` function to avoid an `AttributeError`.\n- The `opto.trace.operators` module must be available and contain a `format` function that can handle the passed arguments and keyword arguments.\n\n**Output Example**: \nIf the `_data` attribute of the Node object is a string, the `format` function will return the formatted string as processed by the `opto.trace.operators.format` function. For example, if `_data` is `\"Hello, {}\"` and the arguments passed are `\"World\"`, the return value might be `\"Hello, World\"`."
      ],
      "code_start_line": 621,
      "code_end_line": 627,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def format(self, *args, **kwargs):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'format'.\")\n\n        import opto.trace.operators as ops\n\n        return ops.format(self, *args, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "capitalize",
      "md_content": [
        "**capitalize**: The function of capitalize is to convert the first character of the string stored in the `_data` attribute of the Node object to uppercase.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The `capitalize` function first checks if the `_data` attribute of the Node object is of type `str`. If `_data` is not a string, it raises an `AttributeError` indicating that the object does not have a `capitalize` attribute. This ensures that the function is only applied to string data. If `_data` is a string, the function imports the `capitalize` function from the `opto.trace.operators` module and returns the result of calling this `capitalize` function with the current Node object (`self`) as its argument. This modular approach allows for the actual capitalization logic to be handled by the `opto.trace.operators` module, promoting code reusability and separation of concerns.\n\n**Note**: \n- Ensure that the `_data` attribute of the Node object is a string before calling the `capitalize` function to avoid raising an `AttributeError`.\n- The function relies on the `opto.trace.operators` module, so make sure this module is correctly implemented and accessible.\n\n**Output Example**: If the `_data` attribute of the Node object is `\"hello world\"`, the `capitalize` function will return `\"Hello world\"`."
      ],
      "code_start_line": 629,
      "code_end_line": 634,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def capitalize(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'capitalize'.\")\n        import opto.trace.operators as ops\n\n        return ops.capitalize(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "lower",
      "md_content": [
        "**lower**: The function of lower is to convert the string data contained within the object to lowercase.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**: The lower function is designed to operate on an instance's internal data, specifically converting it to lowercase if it is a string. The function first checks if the type of the instance's _data attribute is a string. If _data is not a string, it raises an AttributeError, indicating that the object does not have a 'lower' attribute. This ensures that the function only attempts to convert string data to lowercase, preventing type errors. If the _data attribute is a string, the function imports the lower function from the opto.trace.operators module and applies it to the instance, returning the result.\n\n**Note**: \n- This function will raise an AttributeError if the _data attribute is not of type str.\n- Ensure that the opto.trace.operators module is available and contains a lower function that can handle the conversion.\n\n**Output Example**: \nIf the _data attribute of the instance is \"Hello World\", the function will return \"hello world\"."
      ],
      "code_start_line": 636,
      "code_end_line": 641,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def lower(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'lower'.\")\n        import opto.trace.operators as ops\n\n        return ops.lower(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "upper",
      "md_content": [
        "**upper**: The function of upper is to convert the internal data of the Node object to uppercase if it is a string.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The upper function first checks if the internal data attribute (_data) of the Node object is of type string. If _data is not a string, it raises an AttributeError indicating that the object does not have an 'upper' attribute. If _data is a string, the function imports the upper function from the opto.trace.operators module and returns the result of calling this imported upper function with the current Node object as its argument.\n\n**Note**: \n- This function will only work if the _data attribute of the Node object is a string. If _data is of any other type, an AttributeError will be raised.\n- Ensure that the opto.trace.operators module is correctly implemented and accessible, as this function relies on it.\n\n**Output Example**: \nIf the _data attribute of the Node object is \"hello\", calling the upper function will return \"HELLO\"."
      ],
      "code_start_line": 643,
      "code_end_line": 648,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def upper(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'upper'.\")\n        import opto.trace.operators as ops\n\n        return ops.upper(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "swapcase",
      "md_content": [
        "**swapcase**: The function of swapcase is to convert all uppercase characters in the string to lowercase and vice versa.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The swapcase function is a method designed to operate on an instance's _data attribute. It first checks if the _data attribute is of type str. If _data is not a string, the function raises an AttributeError, indicating that the object does not have a swapcase attribute. This ensures that the function only processes string data. If the _data attribute is a string, the function imports the swapcase function from the opto.trace.operators module and applies it to the instance, returning the result. This modular approach allows for the swapcase operation to be defined and maintained separately in the operators module.\n\n**Note**: \n- The _data attribute must be a string; otherwise, an AttributeError will be raised.\n- Ensure that the opto.trace.operators module is correctly implemented and accessible.\n\n**Output Example**: \nIf the _data attribute of the instance is \"Hello World\", the swapcase function will return \"hELLO wORLD\"."
      ],
      "code_start_line": 650,
      "code_end_line": 655,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def swapcase(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'swapcase'.\")\n        import opto.trace.operators as ops\n\n        return ops.swapcase(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "title",
      "md_content": [
        "**title**: The function of title is to retrieve the title attribute of the Node object if it exists.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the Node class.\n\n**Code Description**: The title function checks if the _data attribute of the Node instance is a string. If _data is not a string, it raises an AttributeError indicating that the object does not have a title attribute. If _data is a string, it imports the title function from the opto.trace.operators module and returns the result of calling this imported title function with the current Node instance as its argument.\n\n**Note**: \n- Ensure that the _data attribute of the Node instance is a string before calling the title function to avoid an AttributeError.\n- The function relies on the title function from the opto.trace.operators module, so ensure that this module is correctly imported and available.\n\n**Output Example**: \nIf the _data attribute of the Node instance is a string, the function will return the result of the title function from the opto.trace.operators module. For example, if the title function in the operators module processes the string and returns a formatted title, the output will be that formatted title."
      ],
      "code_start_line": 657,
      "code_end_line": 662,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def title(self):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'title'.\")\n        import opto.trace.operators as ops\n\n        return ops.title(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "split",
      "md_content": [
        "**split**: The function of split is to divide a string into a list of substrings based on a specified separator.\n\n**parameters**: The parameters of this Function.\n· sep: The delimiter according to which the string is split. If not specified or None, any whitespace string is a separator.\n· maxsplit: The maximum number of splits to do. -1 (the default value) means no limit on the number of splits.\n\n**Code Description**: The split function is designed to operate on an object that contains a string. It first checks if the object's _data attribute is of type str. If _data is not a string, it raises an AttributeError indicating that the split operation is not applicable to the object's data type. If _data is a string, the function imports the split function from the opto.trace.operators module and delegates the actual splitting operation to this imported function, passing along the separator and maxsplit parameters.\n\n**Note**: \n- This function will raise an AttributeError if the _data attribute of the object is not a string.\n- Ensure that the opto.trace.operators module is available and contains a split function that can handle the parameters passed to it.\n\n**Output Example**: \nIf the _data attribute of the object is \"hello world\" and the split function is called with the default parameters, the return value would be:\n```python\n['hello', 'world']\n```"
      ],
      "code_start_line": 664,
      "code_end_line": 669,
      "params": [
        "self",
        "sep",
        "maxsplit"
      ],
      "have_return": true,
      "code_content": "    def split(self, sep=None, maxsplit=-1):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'split'.\")\n        import opto.trace.operators as ops\n\n        return ops.split(self, sep, maxsplit)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "strip",
      "md_content": [
        "**strip**: The function of strip is to remove leading and trailing characters from a string stored in the object's `_data` attribute.\n\n**parameters**: The parameters of this Function.\n· chars: A string specifying the set of characters to be removed. If not provided, whitespace characters are removed by default.\n\n**Code Description**: The `strip` function first checks if the `_data` attribute of the object is of type `str`. If `_data` is not a string, it raises an `AttributeError` indicating that the object does not have a `strip` attribute. This ensures that the function is only applied to string data. The function then imports the `strip` function from the `opto.trace.operators` module and calls this imported `strip` function, passing the current object and the `chars` parameter to it. This design allows for the actual stripping operation to be handled by the `strip` function in the `opto.trace.operators` module, potentially allowing for more complex or customized stripping behavior.\n\n**Note**: \n- Ensure that the `_data` attribute is a string before calling the `strip` function to avoid the `AttributeError`.\n- The `chars` parameter is optional. If not provided, the function will default to removing whitespace characters.\n\n**Output Example**: \nIf `_data` is `\"  example  \"` and `chars` is not provided, the return value might be `\"example\"`. If `_data` is `\"--example--\"` and `chars` is `\"-\"`, the return value might be `\"example\"`."
      ],
      "code_start_line": 671,
      "code_end_line": 676,
      "params": [
        "self",
        "chars"
      ],
      "have_return": true,
      "code_content": "    def strip(self, chars=None):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'strip'.\")\n        import opto.trace.operators as ops\n\n        return ops.strip(self, chars)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "replace",
      "md_content": [
        "**replace**: The function of replace is to substitute occurrences of a specified substring within the Node's data with a new substring.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the Node class.\n· old: The substring that needs to be replaced.\n· new: The substring that will replace the old substring.\n· count: (optional) The maximum number of occurrences to replace. Default is -1, which means replace all occurrences.\n\n**Code Description**: The replace function is designed to perform a substring replacement operation on the data contained within a Node object. The function first checks if the data type of the Node's internal data (_data) is a string. If it is not a string, it raises an AttributeError, indicating that the replace operation is not applicable to the data type.\n\nThe function then imports the replace function from the opto.trace.operators module. It proceeds to call this imported replace function, passing the current Node instance (self), and the old and new substrings wrapped in Node objects using the node function. The count parameter is also passed along to control the number of replacements.\n\nThe node function is used to ensure that the old and new substrings are appropriately converted into Node objects if they are not already. This ensures consistency and proper handling within the replace operation.\n\n**Note**: \n- The replace function only works if the Node's internal data is a string. Attempting to use it with non-string data will result in an AttributeError.\n- The count parameter allows for partial replacements, where only a specified number of occurrences are replaced. If count is set to -1, all occurrences will be replaced.\n\n**Output Example**: A possible return value of the replace function could be a new Node object with the specified substring replacements applied to its internal string data. For instance, if the original Node's data is \"hello world\" and the replace function is called with old=\"world\", new=\"there\", the resulting Node's data would be \"hello there\"."
      ],
      "code_start_line": 678,
      "code_end_line": 683,
      "params": [
        "self",
        "old",
        "new",
        "count"
      ],
      "have_return": true,
      "code_content": "    def replace(self, old, new, count=-1):\n        if type(self._data) is not str:\n            raise AttributeError(f\"{type(self._data)} object has no attribute 'replace'.\")\n        import opto.trace.operators as ops\n\n        return ops.replace(self, node(old), node(new), count)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "items",
      "md_content": [
        "**items**: The function of items is to retrieve and return the items associated with the current instance of the Node class.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters other than the implicit 'self' which refers to the instance of the Node class.\n\n**Code Description**: The items function is designed to import the items function from the opto.trace.containers module and then call this imported function, passing the current instance (self) as an argument. This allows the function to retrieve the items related to the current Node instance by leveraging the functionality provided in the opto.trace.containers module.\n\n**Note**: \n- Ensure that the opto.trace.containers module is correctly installed and accessible in your environment, as the items function relies on it.\n- This function assumes that the imported items function from the opto.trace.containers module is designed to handle the Node instance appropriately.\n\n**Output Example**: \nThe return value of this function will depend on the implementation of the items function in the opto.trace.containers module. Typically, it might return a list, dictionary, or another collection of items associated with the Node instance. For example:\n```python\n[\n    {'id': 1, 'name': 'Item1'},\n    {'id': 2, 'name': 'Item2'}\n]\n```"
      ],
      "code_start_line": 686,
      "code_end_line": 689,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def items(self):\n        import opto.trace.containers as ct\n\n        return ct.items(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "pop",
      "md_content": [
        "**pop**: The function of pop is to remove and return an element from a Node object at a specified index.\n\n**parameters**: The parameters of this function.\n· __index: An optional integer parameter that specifies the index of the element to be removed. The default value is -1, which means the last element will be removed.\n\n**Code Description**: The pop function is designed to remove and return an element from a Node object at a specified index. It imports the pop function from the opto.trace.operators module and utilizes the node function to handle the index parameter. The node function ensures that the index is properly converted into a Node object if it is not already one. This allows for consistent handling of the index parameter within the pop function.\n\nThe pop function works as follows:\n1. It imports the necessary operators from the opto.trace.operators module.\n2. It calls the ops.pop function, passing the current Node object (self) and the index parameter converted to a Node object using the node function.\n\nThe relationship with its callees is as follows:\n- The node function is used to ensure that the index parameter is properly converted into a Node object.\n- The ops.pop function from the opto.trace.operators module is used to perform the actual removal and return of the element from the Node object.\n\n**Note**: \n- The default value of the __index parameter is -1, which means the last element will be removed if no index is specified.\n- The node function is used to handle the index parameter, ensuring it is properly converted into a Node object.\n\n**Output Example**: A possible return value of the pop function could be the element that was removed from the Node object at the specified index. For example, if the Node object contained the elements [1, 2, 3] and the index parameter was 1, the return value would be 2, and the Node object would be updated to [1, 3]."
      ],
      "code_start_line": 691,
      "code_end_line": 695,
      "params": [
        "self",
        "__index"
      ],
      "have_return": true,
      "code_content": "    def pop(self, __index=-1):\n        # python does hidden type checks\n        import opto.trace.operators as ops\n\n        return ops.pop(self, node(__index))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "append",
      "md_content": [
        "**append**: The function of append is to add elements to a collection or list within the Node object.\n\n**parameters**: The parameters of this function.\n· self: The instance of the Node class on which the method is called.\n· *args: Variable-length positional arguments to be appended.\n· **kwargs: Variable-length keyword arguments to be appended.\n\n**Code Description**: The `append` method is a member of the `Node` class in the `opto.trace.nodes.py` module. This method is designed to add elements to a collection or list within the Node object. It achieves this by internally calling the `call` method with the string \"append\" as the function name, along with any positional (`*args`) and keyword arguments (`**kwargs`) provided.\n\nThe `call` method, which is invoked by `append`, dynamically calls the specified function (in this case, \"append\") on the `Node` object. It first converts all positional and keyword arguments to `Node` objects using the `node` function, ensuring that the arguments are compatible with the Node's internal structure. After conversion, it retrieves the \"append\" function from the `Node` object using `getattr` and invokes it with the converted arguments.\n\nThis design allows the `append` method to flexibly handle various types of input while ensuring that all elements being appended are properly formatted as `Node` objects.\n\n**Note**:\n- The `append` method relies on the `call` method to dynamically invoke the \"append\" function on the `Node` object.\n- All arguments passed to `append` are converted to `Node` objects before being appended.\n- The `self` parameter must be a valid instance of the `Node` class.\n\n**Output Example**: A possible return value of the `append` method could be the result of the \"append\" function invoked on the `Node` object with the provided arguments. For instance, if the \"append\" function adds elements to a list, the return value might be the updated list."
      ],
      "code_start_line": 697,
      "code_end_line": 698,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def append(self, *args, **kwargs):\n        return self.call(\"append\", *args, **kwargs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node/call"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "ParameterNode",
      "md_content": [
        "**ParameterNode**: The function of ParameterNode is to represent a trainable node in a computational graph.\n\n**attributes**:\n- value: The initial value of the node.\n- name: The name of the node.\n- trainable: A boolean indicating whether the node is trainable or not.\n- description: A string describing the node.\n- constraint: A constraint on the node.\n- info: Additional information about the node.\n\n**Code Description**: The ParameterNode class is a subclass of the Node class and represents a trainable node in a computational graph. It is used to store and manipulate data in the graph. The class has an initializer method that takes in various parameters such as value, name, trainable, description, constraint, and info. These parameters are used to initialize the attributes of the ParameterNode object.\n\nThe initializer method also calls the initializer method of the superclass (Node) to set the value and name attributes. It then sets the trainable, description, constraint, and info attributes based on the provided parameters. Additionally, it adds the ParameterNode object to the 'parameter' dependency set.\n\nThe ParameterNode class also defines a __str__ method that returns a string representation of the node. This method allows users to easily look up the node in the feedback dictionary.\n\n**Note**:\n- The ParameterNode class inherits from the Node class, which is a data node in a directed graph.\n- The value attribute represents the initial value of the node.\n- The name attribute represents the name of the node.\n- The trainable attribute indicates whether the node is trainable or not.\n- The description attribute provides information about the node.\n- The constraint attribute represents a constraint on the node.\n- The info attribute stores additional information about the node.\n\n**Output Example**:\nA possible return value of the __str__ method could be \"ParameterNode: (name, dtype=<class 'type'>, data=value)\"."
      ],
      "code_start_line": 701,
      "code_end_line": 720,
      "params": [],
      "have_return": true,
      "code_content": "class ParameterNode(Node[T]):\n    # This is a shorthand of a trainable Node.\n    def __init__(\n        self,\n        value,\n        *,\n        name=None,\n        trainable=True,\n        description=\"[ParameterNode] This is a ParameterNode in a computational graph.\",\n        constraint=None,\n        info=None,\n    ) -> None:\n        super().__init__(\n            value, name=name, trainable=trainable, description=description, constraint=constraint, info=info\n        )\n        self._dependencies['parameter'].add(self)\n\n    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"ParameterNode: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/__init__",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/construct_update_dict",
        "opto\\optimizers\\opro.py",
        "opto\\optimizers\\optimizers.py",
        "opto\\optimizers\\optimizers.py/AbstractOptimizer/__init__",
        "opto\\optimizers\\optimizers.py/Optimizer/__init__",
        "opto\\optimizers\\optimizers.py/Optimizer/update",
        "opto\\optimizers\\optimizers.py/Optimizer/_step",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/__init__",
        "opto\\trace\\containers.py",
        "opto\\trace\\containers.py/Seq/parameters_dict",
        "opto\\trace\\containers.py/Map/parameters_dict",
        "opto\\trace\\modules.py",
        "opto\\trace\\modules.py/ParameterContainer/parameters",
        "opto\\trace\\modules.py/ParameterContainer/parameters_dict",
        "opto\\trace\\modules.py/Module/_set",
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_node_shape",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_color",
        "opto\\trace\\propagators\\graph_propagator.py",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the ParameterNode class with specified attributes.\n\n**parameters**: The parameters of this Function.\n· value: The initial value assigned to the ParameterNode.\n· name: An optional name for the ParameterNode. Default is None.\n· trainable: A boolean indicating whether the parameter is trainable. Default is True.\n· description: A string describing the ParameterNode. Default is \"[ParameterNode] This is a ParameterNode in a computational graph.\"\n· constraint: An optional constraint applied to the parameter. Default is None.\n· info: Additional optional information about the parameter. Default is None.\n\n**Code Description**: The __init__ function initializes a ParameterNode object by calling the constructor of its superclass with the provided parameters. It sets the initial value, name, trainable status, description, constraint, and additional information for the ParameterNode. After initializing the superclass, it adds the current instance to the '_dependencies' dictionary under the 'parameter' key. This ensures that the ParameterNode is properly registered within the computational graph's dependency management system.\n\n**Note**: Points to note about the use of the code\n- Ensure that the 'value' parameter is provided when creating an instance of ParameterNode.\n- The 'name', 'constraint', and 'info' parameters are optional and can be omitted if not needed.\n- The 'trainable' parameter defaults to True, indicating that the parameter will be included in training processes unless explicitly set to False.\n- The 'description' parameter provides a default description but can be customized as needed."
      ],
      "code_start_line": 703,
      "code_end_line": 716,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def __init__(\n        self,\n        value,\n        *,\n        name=None,\n        trainable=True,\n        description=\"[ParameterNode] This is a ParameterNode in a computational graph.\",\n        constraint=None,\n        info=None,\n    ) -> None:\n        super().__init__(\n            value, name=name, trainable=trainable, description=description, constraint=constraint, info=info\n        )\n        self._dependencies['parameter'].add(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to provide a string representation of the ParameterNode object.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the ParameterNode class.\n\n**Code Description**: The `__str__` method is designed to return a human-readable string that represents the current state of a `ParameterNode` object. This method is particularly useful for debugging and logging purposes, as it provides a concise summary of the node's key attributes.\n\nWhen called, the `__str__` method constructs a string that includes:\n- The name of the node, accessed via `self.name`. This name is managed by the `name` method of the `AbstractNode` class, which returns the value of the private attribute `_name`.\n- The data type of the node's data, obtained using `type(self._data)`.\n- The actual data stored in the node, accessed via `self._data`.\n\nThe string is formatted as follows:\n```\nParameterNode: ({self.name}, dtype={type(self._data)}, data={self._data})\n```\nThis format ensures that the string includes the node's name, the type of its data, and the data itself, all in a clear and structured manner.\n\n**Note**: \n- The `__str__` method should be used when a string representation of the `ParameterNode` is needed, such as in logging or debugging scenarios.\n- Ensure that the node's data (`self._data`) is in a state that can be meaningfully represented as a string.\n\n**Output Example**: \nIf a `ParameterNode` object has a name \"node:0\", data type `<class 'int'>`, and data `42`, the `__str__` method will return:\n```\nParameterNode: (node:0, dtype=<class 'int'>, data=42)\n```"
      ],
      "code_start_line": 718,
      "code_end_line": 720,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"ParameterNode: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "MessageNode",
      "md_content": [
        "**MessageNode**: The MessageNode class represents the output of an operator in a computational graph.\n\n**attributes**:\n- value: The value of the node.\n- inputs: The input nodes of the MessageNode. It can be a list or a dictionary.\n- description: A string that describes the operator associated with the MessageNode.\n- constraint: A constraint on the node.\n- name: The name of the node.\n- info: Additional information about the node.\n\n**Code Description**:\nThe MessageNode class is a subclass of the Node class and inherits its attributes and methods. It overrides the __init__ method to include the inputs, description, constraint, name, and info parameters. The inputs parameter can be a list or a dictionary, and it represents the input nodes of the MessageNode. The description parameter is a string that describes the operator associated with the MessageNode. The constraint parameter specifies a constraint on the node. The name parameter is the name of the node. The info parameter is additional information about the node.\n\nThe __init__ method initializes the MessageNode by calling the __init__ method of the Node class and passing the value, name, description, constraint, and info parameters. It checks if the inputs parameter is a list or a dictionary and creates a dictionary with the names of the nodes as keys if it is a list. It then assigns the inputs to the _inputs attribute of the MessageNode. If the GRAPH.TRACE flag is False, it checks if the MessageNode has any inputs and raises an assertion error if it does. It adds the parents and dependencies if the GRAPH.TRACE flag is True.\n\nThe inputs property returns a copy of the _inputs attribute.\n\nThe __str__ method returns a string representation of the MessageNode, including its name, data type, and data.\n\nThe _add_feedback method is called to add feedback from a child node. It adds the feedback to the _feedback attribute of the MessageNode.\n\nThe external_dependencies property returns a set of external dependencies based on the info attribute of the MessageNode.\n\nThe _add_dependencies method is called to add dependencies from a parent node. It adds the parameter and expandable dependencies to the _dependencies attribute of the MessageNode.\n\n**Note**:\n- The MessageNode class is used to represent the output of an operator in a computational graph.\n- The inputs parameter can be a list or a dictionary, and it represents the input nodes of the MessageNode.\n- The description parameter is a string that describes the operator associated with the MessageNode.\n- The constraint parameter specifies a constraint on the node.\n- The name parameter is the name of the node.\n- The info parameter is additional information about the node.\n\n**Output Example**:\nA possible appearance of the MessageNode object when converted to a string could be:\n\"MessageNode: (node_name, dtype=<class 'int'>, data=10)\""
      ],
      "code_start_line": 723,
      "code_end_line": 793,
      "params": [],
      "have_return": true,
      "code_content": "class MessageNode(Node[T]):\n    \"\"\"Output of an operator.\n\n    description: a string to describe the operator it begins with\n    [operator_name] and then describes the operator. When referring to\n    inputs use the keys in args (if args is a dict), or the names of the\n    nodes in args (if args is a list). Here're some examples:\n\n    MessageNode(node_a, inputs=[node_a], description=\"[identity] This is an identity operator.\")\n    MessageNode(copy_node_a, inputs=[node_a], description=\"[copy] This is a copy operator.\")\n    MesssageNode(1, inputs={'a':node_a, 'b':node_b}, description=\"[Add] This is an add operator of a and b.\")\n    \"\"\"\n    # TODO document what needs to go into info\n\n    def __init__(\n        self,\n        value,\n        *,\n        inputs: Union[List[Node], Dict[str, Node]],  # extra\n        description: str,\n        constraint=None,\n        name=None,\n        info=None,\n    ) -> None:\n        super().__init__(value, name=name, description=description, constraint=constraint, info=info)\n\n        assert isinstance(inputs, list) or isinstance(inputs, dict), \"Inputs to MessageNode must be a list or a dict.\"\n        # If inputs is not a dict, we create a dict with the names of the nodes as keys\n        if isinstance(inputs, list):\n            inputs = {v.name: v for v in inputs}\n        self._inputs = inputs\n\n        # If not tracing, MessageNode would just behave like a Node.\n        if not GRAPH.TRACE:\n            assert len(self._inputs) == 0, \"MessageNode should have no inputs when not tracing.\"\n\n        # Add parents if we are tracing\n        for k, v in self._inputs.items():\n            assert isinstance(v, Node), f\"Input {k} is not a Node.\"\n            self._add_parent(v)\n            self._add_dependencies(v)  # Initializes the dependencies on parameter and expandable nodes\n\n        if len(self.external_dependencies)>0:\n            self._dependencies['expandable'].add(self)\n\n\n    @property\n    def inputs(self):\n        return copy.copy(self._inputs)\n\n    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"MessageNode: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n\n    def _add_feedback(self, child, feedback):\n        \"\"\"Add feedback from a child.\"\"\"\n        super()._add_feedback(child, feedback)\n        assert len(self._feedback[child]) == 1, \"MessageNode should have only one feedback from each child.\"\n\n    @property\n    def external_dependencies(self):\n        if isinstance(self.info, dict) and isinstance(self.info.get('output'), Node):\n            if len(self.info['output'].parameter_dependencies) > len(self.parameter_dependencies):\n                return self.info['output'].parameter_dependencies - self.parameter_dependencies\n        return set()\n\n    def _add_dependencies(self, parent):\n        assert parent is not self, \"Cannot add self as a parent.\"\n        assert isinstance(parent, Node), f\"{parent} is {type(parent)}, which is not a Node.\"\n        self._dependencies['parameter'] = self._dependencies['parameter'] | parent._dependencies['parameter']\n        self._dependencies['expandable'] = self._dependencies['expandable'] | parent._dependencies['expandable']\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/get_fun_name",
        "opto\\optimizers\\function_optimizer.py/repr_function_call",
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback",
        "opto\\optimizers\\opro.py",
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/wrap",
        "opto\\trace\\containers.py",
        "opto\\trace\\nodes.py/Node/backward",
        "opto\\trace\\nodes.py/ExceptionNode",
        "opto\\trace\\propagators\\graph_propagator.py",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate",
        "opto\\trace\\propagators\\propagators.py",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/__call__",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/propagate",
        "opto\\trace\\propagators\\propagators.py/Propagator/propagate",
        "opto\\trace\\propagators\\propagators.py/Propagator/_propagate",
        "opto\\trace\\propagators\\propagators.py/SumPropagator/_propagate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize a MessageNode object with the given parameters.\n\n**parameters**:\n- self: The instance of the class.\n- value: The value of the MessageNode object.\n- inputs: The inputs to the MessageNode object, which can be either a list or a dictionary of Node objects.\n- description: The description of the MessageNode object.\n- constraint: An optional constraint on the MessageNode object.\n- name: An optional name for the MessageNode object.\n- info: Additional information about the MessageNode object.\n\n**Code Description**:\nThe `__init__` function is the constructor of the MessageNode class. It initializes a MessageNode object with the provided parameters. The function first calls the constructor of the parent class, AbstractNode, passing the value, name, description, constraint, and info parameters.\n\nNext, the function checks if the inputs parameter is either a list or a dictionary. If it is not, an assertion error is raised with the message \"Inputs to MessageNode must be a list or a dict.\" This ensures that the inputs are of the correct type.\n\nIf the inputs parameter is a list, the function creates a dictionary with the names of the nodes as keys and the nodes themselves as values. This is done to ensure that the inputs can be accessed by their names.\n\nThe function then assigns the inputs to the _inputs attribute of the MessageNode object.\n\nIf the GRAPH.TRACE flag is not set, indicating that tracing is not enabled, the function asserts that the _inputs attribute is empty. This is because when not tracing, a MessageNode should have no inputs.\n\nNext, the function iterates over the items in the _inputs dictionary. For each item, it checks if the value is an instance of the Node class. If it is not, an assertion error is raised with the message \"Input {k} is not a Node.\" This ensures that all inputs are valid Node objects.\n\nFor each valid input, the function calls the _add_parent method of the MessageNode object to add the input as a parent. This method adds the parent node to the hierarchical structure of the graph.\n\nThe function also calls the _add_dependencies method of the MessageNode object to add the dependencies on parameters and expandable nodes. This method updates the _dependencies attribute of the MessageNode object.\n\nFinally, if the external_dependencies attribute of the MessageNode object is not empty, indicating that there are external dependencies, the function adds the MessageNode object to the 'expandable' set of the _dependencies attribute.\n\n**Note**:\n- The inputs parameter should be either a list or a dictionary of Node objects.\n- When not tracing, a MessageNode should have no inputs.\n- The inputs should be valid Node objects.\n- The _add_parent method adds the parent node to the hierarchical structure of the graph.\n- The _add_dependencies method adds the dependencies on parameters and expandable nodes to the MessageNode object.\n- The external_dependencies attribute indicates the external dependencies of the MessageNode object."
      ],
      "code_start_line": 737,
      "code_end_line": 766,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def __init__(\n        self,\n        value,\n        *,\n        inputs: Union[List[Node], Dict[str, Node]],  # extra\n        description: str,\n        constraint=None,\n        name=None,\n        info=None,\n    ) -> None:\n        super().__init__(value, name=name, description=description, constraint=constraint, info=info)\n\n        assert isinstance(inputs, list) or isinstance(inputs, dict), \"Inputs to MessageNode must be a list or a dict.\"\n        # If inputs is not a dict, we create a dict with the names of the nodes as keys\n        if isinstance(inputs, list):\n            inputs = {v.name: v for v in inputs}\n        self._inputs = inputs\n\n        # If not tracing, MessageNode would just behave like a Node.\n        if not GRAPH.TRACE:\n            assert len(self._inputs) == 0, \"MessageNode should have no inputs when not tracing.\"\n\n        # Add parents if we are tracing\n        for k, v in self._inputs.items():\n            assert isinstance(v, Node), f\"Input {k} is not a Node.\"\n            self._add_parent(v)\n            self._add_dependencies(v)  # Initializes the dependencies on parameter and expandable nodes\n\n        if len(self.external_dependencies)>0:\n            self._dependencies['expandable'].add(self)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name",
        "opto\\trace\\nodes.py/AbstractNode/_add_parent",
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/MessageNode/external_dependencies",
        "opto\\trace\\nodes.py/MessageNode/_add_dependencies"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "inputs",
      "md_content": [
        "**inputs**: The function of inputs is to return a copy of the `_inputs` attribute of the object.\n\n**parameters**:\n- self: The current object.\n\n**Code Description**:\nThe `inputs` function is a method of the `MessageNode` class. It returns a copy of the `_inputs` attribute of the object. The `_inputs` attribute is a dictionary that stores the input nodes of the `MessageNode` object.\n\nThe purpose of this function is to provide access to the input nodes of the `MessageNode` object. By returning a copy of the `_inputs` attribute, it ensures that the original dictionary is not modified when accessing the input nodes.\n\nThis function can be useful when you need to retrieve the input nodes of a `MessageNode` object for further processing or analysis.\n\n**Note**:\n- The returned copy of the `_inputs` attribute is a shallow copy, which means that the keys and values of the dictionary are copied, but the objects themselves are not. If the values of the dictionary are mutable objects, modifying them will affect the original objects.\n- The `_inputs` attribute is a private attribute and should not be modified directly. Use the `inputs` function to access the input nodes instead.\n\n**Output Example**:\n```\n{\n    'input1': <Node object at 0x12345678>,\n    'input2': <Node object at 0x23456789>,\n    ...\n}\n```"
      ],
      "code_start_line": 770,
      "code_end_line": 771,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def inputs(self):\n        return copy.copy(self._inputs)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/repr_function_call",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__str__",
      "md_content": [
        "**__str__**: The function of __str__ is to provide a string representation of the MessageNode object.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the MessageNode class.\n\n**Code Description**: The __str__ method in the MessageNode class returns a formatted string that includes the name of the node, the data type of the node's data, and the data itself. This method is useful for debugging and logging purposes, as it provides a clear and concise representation of the node's state.\n\nThe method calls the `name` method from the AbstractNode class to retrieve the name of the node. The `name` method returns the value of the private attribute `_name`, which is set when the node is registered in the graph. The `type(self._data)` function is used to get the data type of the node's data, and `self._data` is used to access the actual data stored in the node.\n\nThe returned string follows the format: \"MessageNode: (name, dtype=data_type, data=data)\", where `name` is the node's name, `data_type` is the type of the data, and `data` is the actual data.\n\n**Note**: \n- The __str__ method should be used when a string representation of the MessageNode object is needed, such as in logging or debugging scenarios.\n- Ensure that the node has been properly initialized and registered before calling this method to avoid any unexpected behavior.\n\n**Output Example**: \nIf the name of the node is \"node:0\", the data type is `<class 'int'>`, and the data is `42`, the __str__ method will return:\n```\nMessageNode: (node:0, dtype=<class 'int'>, data=42)\n```"
      ],
      "code_start_line": 773,
      "code_end_line": 775,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __str__(self) -> str:\n        # str(node) allows us to look up in the feedback dictionary easily\n        return f\"MessageNode: ({self.name}, dtype={type(self._data)}, data={self._data})\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/name"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_add_feedback",
      "md_content": [
        "**_add_feedback**: The function of _add_feedback is to add feedback from a child node.\n\n**parameters**: The parameters of this Function.\n· child: The child node from which the feedback is received.\n· feedback: The feedback data provided by the child node.\n\n**Code Description**: The _add_feedback function is designed to handle feedback from child nodes within a MessageNode. It first calls the parent class's _add_feedback method to ensure any inherited behavior is executed. After that, it asserts that the length of the feedback list for the given child node is exactly one. This assertion ensures that each child node provides only one piece of feedback, maintaining the integrity and expected behavior of the MessageNode.\n\n**Note**: \n- This function relies on the parent class's _add_feedback method, so it is crucial that the parent class is correctly implemented.\n- The assertion will raise an AssertionError if a child node provides more than one piece of feedback, which helps in debugging and maintaining the correct structure of feedback within the MessageNode."
      ],
      "code_start_line": 777,
      "code_end_line": 780,
      "params": [
        "self",
        "child",
        "feedback"
      ],
      "have_return": false,
      "code_content": "    def _add_feedback(self, child, feedback):\n        \"\"\"Add feedback from a child.\"\"\"\n        super()._add_feedback(child, feedback)\n        assert len(self._feedback[child]) == 1, \"MessageNode should have only one feedback from each child.\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "external_dependencies",
      "md_content": [
        "**external_dependencies**: The function of external_dependencies is to determine the external dependencies of a MessageNode object.\n\n**parameters**:\n- self: The MessageNode object itself.\n\n**Code Description**:\nThe `external_dependencies` function is a method within the `MessageNode` class that calculates and returns the external dependencies of the node. It checks if the `info` attribute of the `MessageNode` instance is a dictionary and if it contains an 'output' key that is an instance of the `Node` class. If these conditions are met, it compares the length of the parameter dependencies of the 'output' node with the parameter dependencies of the current `MessageNode`. If the 'output' node has more parameter dependencies, it returns the difference between the two sets of dependencies. This indicates that the `external_dependencies` function relies on the `parameter_dependencies` function of the `Node` class to determine the parameter dependencies of the nodes it interacts with.\n\nThe purpose of the `external_dependencies` function is to identify any external dependencies that the `MessageNode` relies on, which are not already accounted for in its own parameter dependencies. By returning the set of external dependencies, users can gain insights into the dependencies of the `MessageNode` and ensure that all necessary dependencies are properly handled.\n\nIt is important to note that the `external_dependencies` function assumes that the `info` attribute is a dictionary and that the 'output' key contains a valid `Node` object. If these assumptions are not met, the function will return an empty set.\n\n**Note**: \n- The `external_dependencies` function relies on the `parameter_dependencies` function of the `Node` class to determine the parameter dependencies of the nodes it interacts with.\n- The `info` attribute of the `MessageNode` instance must be a dictionary and contain an 'output' key that is an instance of the `Node` class for the function to work correctly.\n\n**Output Example**: A possible return value of the `external_dependencies` function could be a set of external dependencies, such as:\n```\n{'dependency1', 'dependency2', 'dependency3'}\n```"
      ],
      "code_start_line": 783,
      "code_end_line": 787,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def external_dependencies(self):\n        if isinstance(self.info, dict) and isinstance(self.info.get('output'), Node):\n            if len(self.info['output'].parameter_dependencies) > len(self.parameter_dependencies):\n                return self.info['output'].parameter_dependencies - self.parameter_dependencies\n        return set()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/MessageNode/__init__",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/Node/info",
        "opto\\trace\\nodes.py/Node/parameter_dependencies"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_add_dependencies",
      "md_content": [
        "**_add_dependencies**: The function of _add_dependencies is to add dependencies on parameters and expandable nodes to the current MessageNode object.\n\n**Parameters**:\n- parent: The parent node to add as a dependency.\n\n**Code Description**:\nThe `_add_dependencies` function is used to add dependencies on parameters and expandable nodes to the current MessageNode object. It takes a `parent` parameter, which is the parent node to be added as a dependency.\n\nThe function first checks if the `parent` is not the same as the current object itself. If it is, an assertion error is raised with the message \"Cannot add self as a parent.\"\n\nNext, it checks if the `parent` is an instance of the `Node` class. If it is not, an assertion error is raised with a message indicating that the `parent` is not a Node.\n\nIf both assertions pass, the function proceeds to add the dependencies. It updates the `_dependencies` dictionary of the current object by taking the union of the `parameter` and `expandable` dependencies of the `parent` node. This is done using the bitwise OR operator (`|`).\n\nFinally, the function returns without any explicit return value.\n\n**Note**:\n- The `parent` parameter should be a valid Node object.\n- The function assumes that the current object is a MessageNode.\n- The function updates the `_dependencies` dictionary of the current object to include the dependencies from the `parent` node."
      ],
      "code_start_line": 789,
      "code_end_line": 793,
      "params": [
        "self",
        "parent"
      ],
      "have_return": false,
      "code_content": "    def _add_dependencies(self, parent):\n        assert parent is not self, \"Cannot add self as a parent.\"\n        assert isinstance(parent, Node), f\"{parent} is {type(parent)}, which is not a Node.\"\n        self._dependencies['parameter'] = self._dependencies['parameter'] | parent._dependencies['parameter']\n        self._dependencies['expandable'] = self._dependencies['expandable'] | parent._dependencies['expandable']\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/MessageNode/__init__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "ExceptionNode",
      "md_content": [
        "**ExceptionNode**: The ExceptionNode class represents a node containing an exception message.\n\n**attributes**:\n- value: The exception value.\n- inputs: The input nodes of the ExceptionNode. It can be a list or a dictionary.\n- description: A string that describes the ExceptionNode.\n- constraint: A constraint on the node.\n- name: The name of the node.\n- info: Additional information about the node.\n\n**Code Description**:\nThe ExceptionNode class is a subclass of the MessageNode class and inherits its attributes and methods. It overrides the __init__ method to include the value, inputs, description, constraint, name, and info parameters. The value parameter represents the exception value. The inputs parameter can be a list or a dictionary, and it represents the input nodes of the ExceptionNode. The description parameter is a string that describes the ExceptionNode. The constraint parameter specifies a constraint on the node. The name parameter is the name of the node. The info parameter is additional information about the node.\n\nThe __init__ method initializes the ExceptionNode by calling the __init__ method of the MessageNode class and passing the value, inputs, description, constraint, name, and info parameters. It checks if the value is an instance of trace.ExecutionError and formats the value accordingly. It then calls the __init__ method of the MessageNode class and passes the formatted value, inputs, description, constraint, name, and info parameters.\n\n**Note**:\n- The ExceptionNode class represents a node containing an exception message.\n- The value parameter represents the exception value.\n- The inputs parameter can be a list or a dictionary, and it represents the input nodes of the ExceptionNode.\n- The description parameter is a string that describes the ExceptionNode.\n- The constraint parameter specifies a constraint on the node.\n- The name parameter is the name of the node.\n- The info parameter is additional information about the node.\n\n**Output Example**:\nA possible appearance of the ExceptionNode object when converted to a string could be:\n\"ExceptionNode: (node_name, dtype=<class 'int'>, data=10)\""
      ],
      "code_start_line": 796,
      "code_end_line": 814,
      "params": [],
      "have_return": false,
      "code_content": "class ExceptionNode(MessageNode[T]):\n    \"\"\"Node containing the exception message.\"\"\"\n\n    def __init__(\n        self,\n        value: Exception,\n        *,\n        inputs: Union[List[Node], Dict[str, Node]],\n        description: str = \"[ExceptionNode] This is node containing the error of execution.\",\n        constraint=None,\n        name=None,\n        info=None,\n    ) -> None:\n        e = value\n        error_type = re.search(r\"<class '(.*)'>\", str(type(e))).group(1)\n        from opto import trace\n        if not isinstance(value, trace.ExecutionError):\n            value = f\"({error_type}) {str(e)}\"\n        super().__init__(value, inputs=inputs, description=description, constraint=constraint, name=name, info=info)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/fun",
        "opto\\trace\\bundle.py/FunModule/wrap",
        "opto\\trace\\errors.py",
        "opto\\trace\\errors.py/ExecutionError/__init__",
        "opto\\trace\\nodes.py/NodeVizStyleGuide/get_color",
        "tests\\unit_tests\\test_error_handling.py"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/MessageNode"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the ExceptionNode class.\n\n**parameters**:\n- value: The exception value to be stored in the ExceptionNode.\n- inputs: The inputs to the ExceptionNode, which can be either a list of nodes or a dictionary of nodes.\n- description: A string that describes the ExceptionNode. The default value is \"[ExceptionNode] This is node containing the error of execution.\"\n- constraint: An optional constraint on the ExceptionNode.\n- name: An optional name for the ExceptionNode.\n- info: Additional information about the ExceptionNode.\n\n**Code Description**:\nThe __init__ method of the ExceptionNode class initializes an instance of the ExceptionNode with the given parameters. It first assigns the value parameter to the variable e. Then, it uses regular expression to extract the error type from the string representation of the exception value. The re.search function searches for the pattern \"<class '(.*)'>\" in the string and retrieves the matched group, which represents the error type. \n\nNext, it imports the trace module from the opto package. This import is necessary because the isinstance function is used later in the code. \n\nThe code then checks if the value is an instance of the ExecutionError class from the trace module. If it is not, it formats the exception message by concatenating the error type and the string representation of the exception value. This ensures that the exception message is informative and includes the error type.\n\nFinally, the super().__init__ method is called to initialize the ExceptionNode instance with the value, inputs, description, constraint, name, and info parameters. The super() function is used to call the __init__ method of the base class (Node) and pass the parameters to it.\n\n**Note**:\n- The ExceptionNode class is used to represent a node in a computational graph that contains an exception value. It is typically used to handle errors that occur during the execution of code within a tracing context.\n- The value parameter should be an instance of the Exception class or a subclass of it.\n- The inputs parameter should be a list of nodes or a dictionary of nodes that serve as inputs to the ExceptionNode.\n- The description parameter is optional and can be used to provide additional information about the ExceptionNode.\n- The constraint parameter is optional and can be used to specify a constraint on the ExceptionNode.\n- The name parameter is optional and can be used to assign a name to the ExceptionNode.\n- The info parameter is optional and can be used to provide additional information about the ExceptionNode.\n- When creating an instance of the ExceptionNode class, make sure to provide the necessary inputs and ensure that the value parameter is an instance of the Exception class or a subclass of it."
      ],
      "code_start_line": 799,
      "code_end_line": 814,
      "params": [
        "self",
        "value"
      ],
      "have_return": false,
      "code_content": "    def __init__(\n        self,\n        value: Exception,\n        *,\n        inputs: Union[List[Node], Dict[str, Node]],\n        description: str = \"[ExceptionNode] This is node containing the error of execution.\",\n        constraint=None,\n        name=None,\n        info=None,\n    ) -> None:\n        e = value\n        error_type = re.search(r\"<class '(.*)'>\", str(type(e))).group(1)\n        from opto import trace\n        if not isinstance(value, trace.ExecutionError):\n            value = f\"({error_type}) {str(e)}\"\n        super().__init__(value, inputs=inputs, description=description, constraint=constraint, name=name, info=info)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\errors.py/ExecutionError",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    }
  ],
  "opto\\trace\\operators.py": [
    {
      "type": "FunctionDef",
      "name": "clone",
      "md_content": [
        "**clone**: The function of clone is to create a deep copy of the input object `x`.\n\n**parameters**: The parameters of this Function.\n· x: The object to be cloned. It can be of any type.\n\n**Code Description**: The `clone` function is designed to generate a deep copy of the provided object `x`. This is achieved using the `copy.deepcopy` method from Python's `copy` module. A deep copy means that all levels of the object are copied recursively, ensuring that the new object is entirely independent of the original. This is particularly useful when dealing with complex objects that contain nested structures, as it prevents changes in the cloned object from affecting the original object and vice versa.\n\n**Note**: \n- Ensure that the `copy` module is imported before using the `clone` function.\n- Be aware that deep copying can be resource-intensive for large or complex objects, as it involves duplicating every element within the object.\n\n**Output Example**: \nIf `x` is a list `[1, 2, [3, 4]]`, calling `clone(x)` will return a new list `[1, 2, [3, 4]]` that is a deep copy of `x`. Changes to the nested list in the cloned object will not affect the original list."
      ],
      "code_start_line": 12,
      "code_end_line": 14,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def clone(x: Any):\n    \"\"\" This is a clone operator of x. \"\"\"\n    return copy.deepcopy(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "identity",
      "md_content": [
        "**identity**: The function of identity is to return a duplicate of the input object.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input object that will be duplicated.\n\n**Code Description**: The identity function takes a single parameter, x, and returns a duplicate of this parameter by calling its clone method. The clone method is a part of the Node class, which creates and returns a duplicate of the current Node object. When identity is called with an object, it effectively behaves the same as calling the clone method on that object. This ensures that the original object remains unmodified, and a new instance with the same attributes and states is returned.\n\nThe identity function is integral to operations that require object duplication within the project. It relies on the clone method from the Node class, which imports the clone function from the opto.trace.operators module and applies it to the current instance of the Node class. This standardized operation ensures consistency in how objects are duplicated across the project.\n\n**Note**: \n- Ensure that the input object x has a clone method implemented; otherwise, the identity function will raise an AttributeError.\n- The identity function does not modify the original object; it only creates and returns a duplicate.\n\n**Output Example**: If the input object x is an instance of the Node class with specific attributes and states, the return value of the identity function will be a new instance of the Node class that is a duplicate of the original instance. For example, if the original Node instance has attributes like name and value, the cloned instance will have the same name and value."
      ],
      "code_start_line": 17,
      "code_end_line": 19,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def identity(x: Any):\n    # identity(x) behaves the same as x.clone()\n    return x.clone()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node/clone"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "pos",
      "md_content": [
        "**pos**: The function of pos is to return the unary positive of the input value x.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value to which the unary positive operator will be applied.\n\n**Code Description**: The pos function takes a single parameter x and applies the unary positive operator to it. This operator is represented by the plus sign (+) in Python. The unary positive operator does not change the value of x; it simply returns x itself. This function is useful in contexts where the unary positive operator needs to be explicitly applied to a value.\n\nIn the project, the pos function is called by the __pos__ method of the Node class located in opto\\trace\\nodes.py. When the unary positive operator is used on an instance of the Node class (e.g., +node_instance), the __pos__ method is invoked, which in turn calls the pos function from the opto.trace.operators module. This ensures that the unary positive operation is consistently applied to instances of the Node class.\n\n**Note**: \n- The pos function does not alter the input value; it simply returns it.\n- Ensure that the input value x is of a type that supports the unary positive operator.\n\n**Output Example**: \nIf the input value x is 5, the return value will be 5.\nIf the input value x is -3.2, the return value will be -3.2."
      ],
      "code_start_line": 26,
      "code_end_line": 28,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def pos(x: Any):\n    \"\"\" This is a pos operator of x. \"\"\"\n    return +x\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__pos__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "neg",
      "md_content": [
        "**neg**: The function of neg is to return the negation of the input value.\n\n**parameters**: The parameters of this Function.\n· x: The input value to be negated. It can be of any type that supports the unary negation operator.\n\n**Code Description**: The neg function takes a single parameter, x, and returns its negation. This is achieved using the unary negation operator (-). The function is designed to work with any type that supports this operator, such as integers, floats, and other numeric types.\n\nIn the context of the project, the neg function is called by the __neg__ method of the Node class in the opto\\trace\\nodes.py module. When the unary negation operator is applied to an instance of the Node class (e.g., -node_instance), the __neg__ method is invoked. This method imports the neg function from the opto.trace.operators module and applies it to the instance, effectively negating the Node object.\n\n**Note**: Ensure that the input value x is of a type that supports the unary negation operator to avoid runtime errors.\n\n**Output Example**: If the input value x is 5, the function will return -5. If the input value x is -3.2, the function will return 3.2."
      ],
      "code_start_line": 32,
      "code_end_line": 34,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def neg(x: Any):\n    \"\"\" This is a neg operator of x. \"\"\"\n    return -x\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__neg__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "abs",
      "md_content": [
        "**abs**: The function of abs is to return the absolute value of the input x.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value for which the absolute value is to be calculated.\n\n**Code Description**: The abs function takes a single parameter x and returns its absolute value. The function is a straightforward wrapper around Python's built-in abs() function, which computes the absolute value of a given number. This function is designed to be used within the opto.trace.operators module.\n\nIn the context of its usage within the project, the abs function is called by the __abs__ method of the Node class located in opto\\trace\\nodes.py. When the __abs__ method is invoked on an instance of the Node class, it imports the abs function from the opto.trace.operators module and applies it to the instance. This allows the Node class to leverage the abs function to compute the absolute value of its instances.\n\n**Note**: \n- Ensure that the input x is a type that supports the absolute value operation, such as int, float, or any custom object that implements the __abs__ method.\n- The function relies on Python's built-in abs() function, so its behavior and limitations are consistent with that.\n\n**Output Example**: \n- If x is -5, the function will return 5.\n- If x is 3.14, the function will return 3.14.\n- If x is an instance of a custom class that implements the __abs__ method, the function will return the result of that method."
      ],
      "code_start_line": 38,
      "code_end_line": 40,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def abs(x: Any):\n    \"\"\" This is an abs operator of x. \"\"\"\n    return abs(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__abs__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "invert",
      "md_content": [
        "**invert**: The function of invert is to perform a bitwise NOT operation on the input value x.\n\n**parameters**: The parameters of this Function.\n· x: The input value on which the bitwise NOT operation will be performed. It can be of any type that supports the bitwise NOT operation.\n\n**Code Description**: The invert function takes a single parameter x and returns the result of applying the bitwise NOT operation to x. The bitwise NOT operation, denoted by the tilde (~) operator, inverts each bit of the input value. For example, if x is an integer, each bit in the binary representation of x will be flipped (0s become 1s and 1s become 0s).\n\nIn the context of the project, the invert function is called by the __invert__ method of the Node class in the opto\\trace\\nodes.py module. When the __invert__ method is invoked on an instance of the Node class, it imports the invert function from the opto.trace.operators module and applies it to the instance. This allows the Node class to support the bitwise NOT operation using the ~ operator.\n\n**Note**: Ensure that the input value x is of a type that supports the bitwise NOT operation. Using types that do not support this operation will result in a TypeError.\n\n**Output Example**: \n- If x is an integer with a value of 5, the return value will be -6.\n- If x is an integer with a value of 0, the return value will be -1."
      ],
      "code_start_line": 44,
      "code_end_line": 46,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def invert(x: Any):\n    \"\"\" This is an invert operator of x. \"\"\"\n    return ~x\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__invert__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "round",
      "md_content": [
        "**round**: The function of round is to round a given value `x` to a specified number of decimal places `n`.\n\n**parameters**: The parameters of this Function.\n· x: The value to be rounded. This can be of any type that supports rounding.\n· n: The number of decimal places to round to. This can be of any type that can be interpreted as an integer.\n\n**Code Description**: The `round` function is designed to round a given value `x` to `n` decimal places. It takes two parameters: `x`, which is the value to be rounded, and `n`, which specifies the number of decimal places to round to. The function returns the result of the built-in `round` function applied to these parameters.\n\nIn the context of its usage within the project, the `round` function is called by the `__round__` method of the `Node` class in the `opto\\trace\\nodes.py` file. The `__round__` method imports the `round` function from `opto.trace.operators` and applies it to the instance of the `Node` class (`self`). If a parameter `n` is provided, it is passed to the `round` function; otherwise, `None` is passed.\n\n**Note**: \n- Ensure that the types of `x` and `n` are compatible with the built-in `round` function to avoid runtime errors.\n- The `round` function in this context is a wrapper around Python's built-in `round` function, so it inherits its behavior and limitations.\n\n**Output Example**: \nIf `x` is 3.14159 and `n` is 2, the function will return 3.14.\nIf `x` is 3.14159 and `n` is 0, the function will return 3."
      ],
      "code_start_line": 50,
      "code_end_line": 52,
      "params": [
        "x",
        "n"
      ],
      "have_return": true,
      "code_content": "def round(x: Any, n: Any):\n    \"\"\" This is a round operator of x. \"\"\"\n    return round(x, n)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__round__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "floor",
      "md_content": [
        "**floor**: The function of floor is to compute the largest integer less than or equal to a given number x.\n\n**parameters**: The parameters of this Function.\n· x: A numeric value of any type (int, float, etc.) that you want to apply the floor operation to.\n\n**Code Description**: The floor function takes a single parameter x and returns the largest integer less than or equal to x. Internally, it uses the `math.floor` method from Python's math module to perform this operation. This function is useful in scenarios where you need to round down a floating-point number to the nearest whole number.\n\nIn the project, this function is called by the `__floor__` method of the `Node` class located in `opto\\trace\\nodes.py`. The `__floor__` method imports the `floor` function from `opto.trace.operators` and applies it to the instance of the `Node` class. This indicates that the `Node` class instances can be floored directly, leveraging the `floor` function to achieve this.\n\n**Note**: Ensure that the input parameter x is a numeric value; otherwise, the function will raise a TypeError. This function is dependent on the `math` module, so ensure that it is available in your environment.\n\n**Output Example**: \n- If `x` is 3.7, `floor(x)` will return 3.\n- If `x` is -2.3, `floor(x)` will return -3."
      ],
      "code_start_line": 56,
      "code_end_line": 60,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def floor(x: Any):\n    \"\"\" This is a floor operator of x. \"\"\"\n    import math\n\n    return math.floor(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__floor__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "ceil",
      "md_content": [
        "**ceil**: The function of ceil is to return the smallest integer greater than or equal to a given number.\n\n**parameters**: The parameters of this Function.\n· x: A numeric value of any type (int, float, etc.) that you want to round up to the nearest integer.\n\n**Code Description**: The ceil function is designed to round up a given numeric value to the nearest integer. It imports the math module and utilizes the math.ceil() method to perform this operation. The function takes a single parameter, x, which can be any numeric type. When called, it returns the smallest integer that is greater than or equal to x.\n\nIn the context of the project, the ceil function is called by the __ceil__ method of the Node class located in opto\\trace\\nodes.py. This indicates that the Node class leverages the ceil function to provide a ceiling operation on its instances. When __ceil__ is invoked on a Node object, it imports the ceil function from opto.trace.operators and applies it to the Node instance, effectively rounding up the value represented by the Node.\n\n**Note**: Ensure that the input parameter x is a numeric value; otherwise, the function will raise a TypeError. The function relies on the math module, so it must be available in the environment where the code is executed.\n\n**Output Example**: \n- If x = 4.2, ceil(x) will return 5.\n- If x = -3.7, ceil(x) will return -3.\n- If x = 7, ceil(x) will return 7."
      ],
      "code_start_line": 64,
      "code_end_line": 68,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def ceil(x: Any):\n    \"\"\" This is a ceil operator of x. \"\"\"\n    import math\n\n    return math.ceil(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__ceil__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "trunc",
      "md_content": [
        "**trunc**: The function of trunc is to truncate the decimal part of a number, returning the integer part.\n\n**parameters**: The parameters of this Function.\n· x: The number to be truncated. It can be of any type that is compatible with the math.trunc function, typically an integer or a float.\n\n**Code Description**: The trunc function is designed to truncate the decimal part of a given number, effectively returning its integer part. This is achieved by utilizing the math.trunc function from Python's math module. When the trunc function is called with a number x, it imports the math module and then applies math.trunc to x, returning the truncated integer value.\n\nIn the context of the project, the trunc function is called by the __trunc__ method of the Node class located in opto\\trace\\nodes.py. The __trunc__ method imports the trunc function from opto.trace.operators and applies it to the instance of the Node class. This indicates that the Node class instances can be truncated using the trunc function, ensuring that any Node object can be converted to its integer representation if needed.\n\n**Note**: \n- Ensure that the input x is a type that can be handled by the math.trunc function, such as an integer or a float.\n- The function will raise a TypeError if x is not a number.\n\n**Output Example**: \nIf the input x is 3.14, the function will return 3.\nIf the input x is -2.99, the function will return -2."
      ],
      "code_start_line": 72,
      "code_end_line": 76,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def trunc(x: Any):\n    \"\"\" This is a trunc operator of x. \"\"\"\n    import math\n\n    return math.trunc(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__trunc__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "add",
      "md_content": [
        "**add**: The function of add is to perform an addition operation on two inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type.\n· y: The second operand, which can be of any type.\n\n**Code Description**: The add function takes two parameters, x and y, and returns their sum. The function is designed to handle operands of any type, leveraging Python's dynamic typing and operator overloading capabilities. This means that the function can add numbers, concatenate strings, or combine other compatible types as defined by the '+' operator in Python.\n\nIn the project, the add function is utilized in the __add__ method of the Node class located in opto\\trace\\nodes.py. When the __add__ method is called on a Node object, it imports the add function from opto.trace.operators and uses it to add the Node's data to another operand. This demonstrates the function's flexibility in handling different types of data within the Node class.\n\n**Note**: Ensure that the types of x and y are compatible with the '+' operator to avoid runtime errors. For example, adding a string to an integer will raise a TypeError.\n\n**Output Example**: \n- If x = 3 and y = 5, add(x, y) will return 8.\n- If x = \"Hello\" and y = \" World\", add(x, y) will return \"Hello World\"."
      ],
      "code_start_line": 83,
      "code_end_line": 85,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def add(x: Any, y: Any):\n    \"\"\" This is an add operator of x and y. \"\"\"\n    return x + y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__add__",
        "tests\\unit_tests\\test_apply_op.py",
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "subtract",
      "md_content": [
        "**subtract**: The function of subtract is to perform a subtraction operation between two operands, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type that supports the subtraction operation.\n· y: The second operand, which can be of any type that supports the subtraction operation.\n\n**Code Description**: The subtract function takes two parameters, x and y, and returns the result of subtracting y from x. This function is designed to handle any data types that support the subtraction operator (-). In the context of the project, this function is utilized by the __sub__ method of the Node class in the opto\\trace\\nodes.py module. When the subtraction operator (-) is used between two Node objects, the __sub__ method is invoked, which in turn calls the subtract function from the opto.trace.operators module. This allows for a seamless and consistent subtraction operation between Node objects.\n\n**Note**: Ensure that the operands x and y are of compatible types that support the subtraction operation to avoid runtime errors.\n\n**Output Example**: \n- If x = 10 and y = 5, the function will return 5.\n- If x = [1, 2, 3] and y = [1, 1, 1], the function will return [0, 1, 2] (assuming the operands are lists and the subtraction operation is defined for lists in this context)."
      ],
      "code_start_line": 89,
      "code_end_line": 91,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def subtract(x: Any, y: Any):\n    \"\"\" This is a subtract operator of x and y. \"\"\"\n    return x - y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__sub__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "multiply",
      "md_content": [
        "**multiply**: The function of multiply is to perform a multiplication operation between two inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand in the multiplication operation. It can be of any type that supports the multiplication operator (*).\n· y: The second operand in the multiplication operation. It can be of any type that supports the multiplication operator (*).\n\n**Code Description**: The multiply function takes two parameters, x and y, and returns the result of multiplying these two parameters using the multiplication operator (*). This function is designed to be generic and can handle any types of inputs that support the multiplication operation. \n\nIn the context of the project, the multiply function is called by the __mul__ method of the Node class in the opto\\trace\\nodes.py module. When the __mul__ method is invoked, it imports the multiply function from the opto.trace.operators module and applies it to the current instance (self) and another operand (other). This allows for the multiplication of Node objects or Node-compatible objects using the * operator.\n\n**Note**: Ensure that the types of x and y are compatible with the multiplication operator to avoid runtime errors. If either x or y does not support multiplication, a TypeError will be raised.\n\n**Output Example**: \n- If x = 3 and y = 4, multiply(x, y) will return 12.\n- If x = [1, 2] and y = 3, multiply(x, y) will return [1, 2, 1, 2, 1, 2]."
      ],
      "code_start_line": 95,
      "code_end_line": 97,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def multiply(x: Any, y: Any):\n    \"\"\" This is a multiply operator of x and y. \"\"\"\n    return x * y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__mul__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "floor_divide",
      "md_content": [
        "**floor_divide**: The function of floor_divide is to perform floor division between two operands, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The dividend, which can be of any type that supports the floor division operation.\n· y: The divisor, which can be of any type that supports the floor division operation.\n\n**Code Description**: The floor_divide function takes two parameters, x and y, and returns the result of the floor division operation (x // y). Floor division is an operation that divides two numbers and rounds down the result to the nearest integer. This function is designed to handle any types that support the floor division operator (//).\n\nIn the context of the project, the floor_divide function is called by the __floordiv__ method of the Node class in the opto\\trace\\nodes.py module. When the __floordiv__ method is invoked on a Node object with another operand, it imports the floor_divide function from the opto.trace.operators module and applies it to the Node object and the other operand. This indicates that the floor_divide function is integral to the Node class's ability to handle floor division operations, ensuring that the operation is performed correctly and consistently within the project's framework.\n\n**Note**: Ensure that both x and y are of types that support the floor division operation to avoid runtime errors. The function does not perform type checking or validation, so improper types may lead to unexpected behavior or exceptions.\n\n**Output Example**: \nIf x = 7 and y = 3, the function call floor_divide(7, 3) will return 2, as 7 // 3 equals 2."
      ],
      "code_start_line": 101,
      "code_end_line": 103,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def floor_divide(x: Any, y: Any):\n    \"\"\" This is a floor_divide operator of x and y. \"\"\"\n    return x // y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__floordiv__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "divide",
      "md_content": [
        "**divide**: The function of divide is to perform division between two operands, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The dividend, which can be of any type that supports division.\n· y: The divisor, which can be of any type that supports division.\n\n**Code Description**: The divide function takes two parameters, x and y, and returns the result of dividing x by y. This function is designed to handle any types that support the division operation. It is a straightforward implementation of the division operator, encapsulated within a function for modularity and reuse.\n\nIn the context of the project, the divide function is called by the __truediv__ method of the Node class located in opto\\trace\\nodes.py. When the division operator (/) is used between two Node objects, the __truediv__ method is invoked. This method imports the divide function from opto.trace.operators and applies it to the current Node instance (self) and the other operand (other), which is converted to a Node if it is not already one. This ensures that the division operation is consistently handled within the framework of Node objects.\n\n**Note**: Ensure that the divisor y is not zero to avoid a ZeroDivisionError. Additionally, both x and y should be of compatible types that support the division operation.\n\n**Output Example**: \nIf x is 10 and y is 2, the function will return 5.0.\nIf x is 9 and y is 3, the function will return 3.0."
      ],
      "code_start_line": 107,
      "code_end_line": 109,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def divide(x: Any, y: Any):\n    \"\"\" This is a divide operator of x and y. \"\"\"\n    return x / y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__truediv__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "mod",
      "md_content": [
        "**mod**: The function of mod is to perform the modulo operation between two values, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The dividend in the modulo operation. It can be of any type that supports the modulo operation.\n· y: The divisor in the modulo operation. It can be of any type that supports the modulo operation.\n\n**Code Description**: The mod function takes two parameters, x and y, and returns the result of the modulo operation (x % y). This operation finds the remainder when x is divided by y. The function is designed to handle any types that support the modulo operation, making it versatile for various use cases.\n\nIn the project, this function is utilized by the __mod__ method of the Node class in the opto\\trace\\nodes.py module. When the __mod__ method is called on a Node object with another value, it imports the mod function from the opto.trace.operators module and applies it to the Node object and the other value. This integration allows Node objects to use the modulo operation seamlessly with other values, enhancing their arithmetic capabilities.\n\n**Note**: Ensure that both x and y are of types that support the modulo operation to avoid runtime errors.\n\n**Output Example**: \n- If x is 10 and y is 3, the return value will be 1.\n- If x is 20 and y is 7, the return value will be 6."
      ],
      "code_start_line": 113,
      "code_end_line": 115,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def mod(x: Any, y: Any):\n    \"\"\" This is a mod operator of x and y. \"\"\"\n    return x % y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__mod__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "divmod",
      "md_content": [
        "**divmod**: The function of divmod is to perform the divmod operation on two inputs, x and y, and return the result.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type that supports the divmod operation.\n· y: The second operand, which can be of any type that supports the divmod operation.\n\n**Code Description**: The divmod function takes two parameters, x and y, and applies the built-in Python divmod function to them. The divmod function returns a tuple containing the quotient and the remainder when dividing x by y. This function is a straightforward wrapper around Python's built-in divmod, providing a consistent interface for performing this operation within the project.\n\nIn the context of its usage within the project, the divmod function is called by the __divmod__ method of the Node class in the opto\\trace\\nodes.py module. When the __divmod__ method is invoked on a Node object, it imports the divmod function from the opto.trace.operators module and applies it to the Node instance and another operand. This integration ensures that the divmod operation can be seamlessly used with Node objects, allowing for consistent and predictable behavior when performing division and modulus operations within the project's tracing framework.\n\n**Note**: Ensure that both x and y are of types that support the divmod operation to avoid runtime errors. The function relies on Python's built-in divmod, so the behavior and constraints of the built-in function apply here as well.\n\n**Output Example**: \nIf x is 10 and y is 3, the return value will be (3, 1), where 3 is the quotient and 1 is the remainder."
      ],
      "code_start_line": 119,
      "code_end_line": 121,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def divmod(x: Any, y: Any):\n    \"\"\" This is a divmod operator of x and y. \"\"\"\n    return divmod(x, y)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__divmod__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "power",
      "md_content": [
        "**power**: The function of power is to compute the result of raising x to the power of y.\n\n**parameters**: The parameters of this Function.\n· x: The base value, which can be of any type that supports the power operation.\n· y: The exponent value, which can be of any type that supports the power operation.\n\n**Code Description**: The power function takes two arguments, x and y, and returns the result of x raised to the power of y (x**y). This function is a simple implementation of the power operation and relies on Python's built-in exponentiation operator (**). \n\nIn the context of the project, this function is utilized by the __pow__ method of the Node class in the opto\\trace\\nodes.py module. When the __pow__ method is called on a Node object with another value, it imports the power function from the opto.trace.operators module and applies it to the Node object and the other value. This allows for the use of the power operator (**) directly on Node objects, enabling more intuitive mathematical operations within the project's framework.\n\n**Note**: Ensure that the types of x and y are compatible with the power operation to avoid runtime errors.\n\n**Output Example**: \nIf x is 2 and y is 3, the function will return 8, as 2**3 equals 8."
      ],
      "code_start_line": 125,
      "code_end_line": 127,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def power(x: Any, y: Any):\n    \"\"\" This is a power operator of x and y. \"\"\"\n    return x**y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__pow__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "lshift",
      "md_content": [
        "**lshift**: The function of lshift is to perform a left bitwise shift operation on two given inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type that supports the left shift operation.\n· y: The second operand, which can be of any type that supports the left shift operation.\n\n**Code Description**: The lshift function takes two parameters, x and y, and returns the result of the left bitwise shift operation (x << y). This operation shifts the bits of x to the left by the number of positions specified by y. The function is designed to work with any types that support the left shift operation, typically integers.\n\nIn the context of the project, the lshift function is called by the __lshift__ method of the Node class in the opto\\trace\\nodes.py module. The __lshift__ method imports the lshift function from the opto.trace.operators module and applies it to the current instance (self) and another operand (other). This indicates that the Node class uses the lshift function to define its own left shift behavior, allowing instances of Node to be shifted left using the << operator.\n\n**Note**: Ensure that the operands x and y are of types that support the left shift operation to avoid runtime errors.\n\n**Output Example**: \nIf x is 4 (binary 100) and y is 2, the function will return 16 (binary 10000), as the bits of 4 are shifted left by 2 positions."
      ],
      "code_start_line": 131,
      "code_end_line": 133,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def lshift(x: Any, y: Any):\n    \"\"\" This is a lshift operator of x and y. \"\"\"\n    return x << y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__lshift__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "rshift",
      "md_content": [
        "**rshift**: The function of rshift is to perform a bitwise right shift operation on two operands, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type that supports the right shift operation.\n· y: The second operand, which can be of any type that supports the right shift operation.\n\n**Code Description**: The rshift function takes two parameters, x and y, and returns the result of the bitwise right shift operation (x >> y). This operation shifts the bits of x to the right by the number of positions specified by y. The function is designed to handle any type that supports the right shift operation, typically integers.\n\nIn the context of its usage within the project, the rshift function is called by the __rshift__ method of the Node class in the opto\\trace\\nodes.py module. The __rshift__ method imports the rshift function from the opto.trace.operators module and applies it to the current instance (self) and another node (other). This indicates that the rshift function is used to facilitate bitwise right shift operations between nodes within the project.\n\n**Note**: Ensure that the operands x and y are of types that support the right shift operation to avoid runtime errors.\n\n**Output Example**: \nIf x is 8 (binary 1000) and y is 2, the function call rshift(8, 2) will return 2 (binary 10)."
      ],
      "code_start_line": 137,
      "code_end_line": 139,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def rshift(x: Any, y: Any):\n    \"\"\" This is a rshift operator of x and y. \"\"\"\n    return x >> y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__rshift__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "and_",
      "md_content": [
        "**and_**: The function of and_ is to perform a bitwise AND operation between two inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand, which can be of any type that supports the bitwise AND operation.\n· y: The second operand, which can be of any type that supports the bitwise AND operation.\n\n**Code Description**: The and_ function takes two parameters, x and y, and returns the result of the bitwise AND operation between them. This operation is denoted by the '&' symbol in Python. The function is straightforward and relies on Python's built-in bitwise AND operator to compute the result.\n\nIn the context of its usage within the project, the and_ function is called by the __and__ method of the Node class in the opto\\trace\\nodes.py module. When the __and__ method is invoked on a Node object with another operand, it imports the and_ function from the opto.trace.operators module and applies it to the Node instance and the other operand. This allows for a seamless bitwise AND operation between Node objects or between a Node object and another compatible operand.\n\n**Note**: Ensure that the operands x and y are of types that support the bitwise AND operation to avoid any runtime errors.\n\n**Output Example**: \nIf x = 6 (binary 110) and y = 3 (binary 011), the function call and_(6, 3) will return 2 (binary 010)."
      ],
      "code_start_line": 143,
      "code_end_line": 145,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def and_(x: Any, y: Any):\n    \"\"\" This is an and operator of x and y. \"\"\"\n    return x & y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__and__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "or_",
      "md_content": [
        "**or_**: The function of or_ is to perform a bitwise OR operation between two inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first operand for the bitwise OR operation. It can be of any type that supports the bitwise OR operation.\n· y: The second operand for the bitwise OR operation. It can be of any type that supports the bitwise OR operation.\n\n**Code Description**: The or_ function takes two parameters, x and y, and returns the result of the bitwise OR operation between them. The bitwise OR operation is denoted by the \"|\" operator in Python. This function is designed to be a utility function that can be used wherever a bitwise OR operation is needed.\n\nIn the context of its usage within the project, the or_ function is called by the __or__ method of the Node class in the opto\\trace\\nodes.py module. The __or__ method imports the or_ function from the opto.trace.operators module and applies it to the current Node instance (self) and another Node instance (other). This allows for the use of the \"|\" operator to combine two Node instances using the bitwise OR operation.\n\n**Note**: Ensure that the operands x and y are of types that support the bitwise OR operation to avoid TypeErrors.\n\n**Output Example**: If x is 5 (binary 0101) and y is 3 (binary 0011), the return value of or_(x, y) would be 7 (binary 0111)."
      ],
      "code_start_line": 149,
      "code_end_line": 151,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def or_(x: Any, y: Any):\n    \"\"\" This is an or operator of x and y. \"\"\"\n    return x | y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__or__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "xor",
      "md_content": [
        "**xor**: The function of xor is to perform a bitwise XOR operation between two inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: Any - The first operand for the XOR operation.\n· y: Any - The second operand for the XOR operation.\n\n**Code Description**: The xor function takes two parameters, x and y, and returns the result of the bitwise XOR operation between them. The bitwise XOR operation compares each bit of its operands and returns 1 if the bits are different, and 0 if they are the same. This function is useful in various scenarios, such as cryptography, error detection, and correction algorithms.\n\nIn the context of the project, the xor function is called by the __xor__ method of the Node class in the opto\\trace\\nodes.py module. The __xor__ method imports the xor function from the opto.trace.operators module and applies it to the current Node instance and another Node instance or value. This allows for the use of the ^ operator to perform a bitwise XOR operation between Node objects, enhancing the functionality and usability of the Node class.\n\n**Note**: Ensure that the inputs x and y are of types that support the bitwise XOR operation, such as integers or objects that implement the __xor__ method.\n\n**Output Example**: Mock up a possible appearance of the code's return value.\nIf x = 5 (binary 0101) and y = 3 (binary 0011), the result of xor(x, y) would be 6 (binary 0110)."
      ],
      "code_start_line": 155,
      "code_end_line": 157,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def xor(x: Any, y: Any):\n    \"\"\" This is a xor operator of x and y. \"\"\"\n    return x ^ y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__xor__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "lt",
      "md_content": [
        "**lt**: The function of lt is to compare two values and determine if the first value is less than the second value.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be compared. It can be of any type that supports comparison operations.\n· y: The second value to be compared. It can be of any type that supports comparison operations.\n\n**Code Description**: The lt function takes two parameters, x and y, and returns the result of the comparison x < y. This function leverages Python's built-in less-than operator to perform the comparison. The function is designed to work with any data types that support the less-than comparison, such as integers, floats, and strings. The function returns a boolean value: True if x is less than y, and False otherwise.\n\n**Note**: \n- Ensure that the types of x and y are compatible for comparison to avoid TypeError.\n- This function does not handle cases where x and y are of different types that cannot be compared directly.\n\n**Output Example**: \n- lt(3, 5) returns True because 3 is less than 5.\n- lt(10, 2) returns False because 10 is not less than 2.\n- lt('apple', 'banana') returns True because 'apple' is lexicographically less than 'banana'."
      ],
      "code_start_line": 164,
      "code_end_line": 166,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def lt(x: Any, y: Any):\n    \"\"\" This is a lt operator of x and y. \"\"\"\n    return x < y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "le",
      "md_content": [
        "**le**: The function of le is to compare two values, x and y, and determine if x is less than or equal to y.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be compared. It can be of any type that supports comparison operations.\n· y: The second value to be compared. It can be of any type that supports comparison operations.\n\n**Code Description**: The le function performs a comparison between two values, x and y, using the less than or equal to (<=) operator. It returns a boolean value: True if x is less than or equal to y, and False otherwise. This function is useful in scenarios where you need to enforce or check ordering constraints between two values.\n\n**Note**: \n- Ensure that the types of x and y are compatible for comparison. If they are not, a TypeError will be raised.\n- This function relies on the underlying implementation of the <= operator for the types of x and y.\n\n**Output Example**: \n- le(3, 5) returns True because 3 is less than 5.\n- le(5, 5) returns True because 5 is equal to 5.\n- le(7, 5) returns False because 7 is greater than 5."
      ],
      "code_start_line": 170,
      "code_end_line": 172,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def le(x: Any, y: Any):\n    \"\"\" This is a le operator of x and y. \"\"\"\n    return x <= y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "eq",
      "md_content": [
        "**eq**: The function of eq is to compare two values, x and y, for equality.\n\n**parameters**: The parameters of this function.\n· x: The first value to be compared. It can be of any data type.\n· y: The second value to be compared. It can be of any data type.\n\n**Code Description**: The eq function takes two parameters, x and y, and returns a boolean value indicating whether the two parameters are equal. The comparison is performed using the equality operator (==), which checks if the values of x and y are the same. This function is useful for determining if two variables or objects hold the same value or state.\n\n**Note**: \n- The function relies on the built-in equality operator (==), so the behavior of the comparison depends on how the equality operator is implemented for the data types of x and y.\n- If x and y are of different types, the function will return False unless the types are comparable and considered equal by the equality operator.\n\n**Output Example**: \n- eq(5, 5) returns True\n- eq('hello', 'hello') returns True\n- eq([1, 2, 3], [1, 2, 3]) returns True\n- eq(5, '5') returns False"
      ],
      "code_start_line": 176,
      "code_end_line": 178,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def eq(x: Any, y: Any):\n    \"\"\" This is an eq operator of x and y. \"\"\"\n    return x == y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "ne",
      "md_content": [
        "**ne**: The function of ne is to compare two values, x and y, and determine if they are not equal.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be compared. It can be of any data type.\n· y: The second value to be compared. It can be of any data type.\n\n**Code Description**: The ne function takes two parameters, x and y, and returns a boolean value indicating whether x is not equal to y. The function uses the != operator to perform the comparison. If x and y are not equal, the function returns True; otherwise, it returns False. This function is useful for scenarios where you need to check inequality between two values.\n\n**Note**: \n- Ensure that the data types of x and y are compatible for comparison to avoid unexpected results.\n- This function does not perform type conversion; it strictly compares the values as they are.\n\n**Output Example**: \n- ne(5, 3) returns True because 5 is not equal to 3.\n- ne('apple', 'orange') returns True because the strings 'apple' and 'orange' are not equal.\n- ne(10, 10) returns False because both values are equal."
      ],
      "code_start_line": 182,
      "code_end_line": 184,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def ne(x: Any, y: Any):\n    \"\"\" This is a ne operator of x and y. \"\"\"\n    return x != y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "ge",
      "md_content": [
        "**ge**: The function of ge is to compare two values and determine if the first value is greater than or equal to the second value.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be compared. It can be of any type that supports comparison operations.\n· y: The second value to be compared. It can be of any type that supports comparison operations.\n\n**Code Description**: The ge function takes two parameters, x and y, and returns the result of the comparison x >= y. This means it checks if x is greater than or equal to y. The function leverages Python's built-in comparison operators to perform this task. The return value is a boolean: True if x is greater than or equal to y, and False otherwise.\n\n**Note**: \n- Ensure that the types of x and y are compatible for comparison to avoid TypeErrors.\n- This function is useful in scenarios where conditional logic is based on the comparison of two values.\n\n**Output Example**: \n- ge(5, 3) returns True because 5 is greater than 3.\n- ge(2, 2) returns True because 2 is equal to 2.\n- ge(1, 4) returns False because 1 is not greater than or equal to 4."
      ],
      "code_start_line": 188,
      "code_end_line": 190,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def ge(x: Any, y: Any):\n    \"\"\" This is a ge operator of x and y. \"\"\"\n    return x >= y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "gt",
      "md_content": [
        "**gt**: The function of gt is to compare two values and determine if the first value is greater than the second value.\n\n**parameters**: The parameters of this Function.\n· x: The first value to be compared. It can be of any type that supports the greater-than (>) comparison.\n· y: The second value to be compared. It can be of any type that supports the greater-than (>) comparison.\n\n**Code Description**: The gt function takes two parameters, x and y, and returns the result of the comparison x > y. This means that the function evaluates whether the value of x is greater than the value of y. The function is designed to work with any data types that support the greater-than comparison operator. The return value is a boolean: True if x is greater than y, and False otherwise.\n\n**Note**: \n- Ensure that the types of x and y are compatible for comparison using the greater-than operator. If the types are not compatible, a TypeError will be raised.\n- This function does not perform any type checking or validation, so it is the responsibility of the user to provide appropriate arguments.\n\n**Output Example**: \n- gt(5, 3) returns True because 5 is greater than 3.\n- gt(2, 4) returns False because 2 is not greater than 4.\n- gt('b', 'a') returns True because 'b' is greater than 'a' in lexicographical order."
      ],
      "code_start_line": 194,
      "code_end_line": 196,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def gt(x: Any, y: Any):\n    \"\"\" This is a gt operator of x and y. \"\"\"\n    return x > y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "cond",
      "md_content": [
        "**cond**: The function of cond is to select and return `x` if `condition` is True, otherwise it returns `y`.\n\n**parameters**: The parameters of this Function.\n· condition: A boolean or any value that can be evaluated as a boolean.\n· x: The value to be returned if `condition` is True.\n· y: The value to be returned if `condition` is False.\n\n**Code Description**: The `cond` function is a simple utility that evaluates a given `condition` and returns one of two provided values based on the result of that evaluation. Specifically, if `condition` evaluates to True, the function returns `x`; otherwise, it returns `y`. \n\nThe function begins by ensuring that all input data (`x`, `y`, and `condition`) are read and assigned to local variables. This step is somewhat redundant in this context but ensures that the inputs are processed. The core logic is implemented in a single return statement that uses a conditional expression (ternary operator) to decide which value to return based on the truthiness of `condition`.\n\nThis function is called in the project by unit tests located in `tests\\unit_tests\\test_nodes.py`. These tests likely verify the correctness of the `cond` function by passing various conditions and corresponding values for `x` and `y`, ensuring that the function returns the expected result in each case.\n\n**Note**: \n- Ensure that `condition` is a value that can be evaluated as a boolean.\n- The function does not perform any type checking or validation on the inputs.\n\n**Output Example**: \n- If `condition` is True, `x` is returned.\n- If `condition` is False, `y` is returned.\n\nFor instance:\n- `cond(True, 'apple', 'orange')` returns `'apple'`.\n- `cond(False, 'apple', 'orange')` returns `'orange'`."
      ],
      "code_start_line": 203,
      "code_end_line": 206,
      "params": [
        "condition",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def cond(condition: Any, x: Any, y: Any):\n    \"\"\" This selects x if condition is True, otherwise y. \"\"\"\n    x, y, condition = x, y, condition  # This makes sure all data are read\n    return x if condition else y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "not_",
      "md_content": [
        "**not_**: The function of not_ is to return the logical negation of the input value x.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value to be negated.\n\n**Code Description**: The not_ function takes a single parameter x of any type and returns the logical negation of x. In Python, the logical negation operator `not` is used to invert the truth value of the operand. If x is a truthy value (e.g., True, non-zero numbers, non-empty collections), the function will return False. Conversely, if x is a falsy value (e.g., False, 0, None, empty collections), the function will return True. This function is useful for scenarios where you need to invert the boolean value of a given input.\n\n**Note**: \n- The input parameter x can be of any type, but the function will evaluate its truthiness according to Python's standard rules for boolean context.\n- Ensure that the input value is appropriate for logical negation to avoid unexpected results.\n\n**Output Example**: \n- not_(True) will return False.\n- not_(0) will return True.\n- not_([1, 2, 3]) will return False.\n- not_('') will return True."
      ],
      "code_start_line": 210,
      "code_end_line": 212,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def not_(x: Any):\n    \"\"\" This is a not operator of x. \"\"\"\n    return not x\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "is_",
      "md_content": [
        "**is_**: The function of is_ is to determine whether x is equal to y using identity comparison.\n\n**parameters**: The parameters of this Function.\n· x: The first object to be compared.\n· y: The second object to be compared.\n\n**Code Description**: The is_ function checks if the two provided arguments, x and y, are the same object in memory. This is done using the identity operator `is`, which returns True if both x and y refer to the same object, and False otherwise. This type of comparison is different from the equality operator `==`, which checks if the values of the objects are equal, not necessarily if they are the same object.\n\n**Note**: \n- Use this function when you need to verify that two variables point to the exact same object, not just equivalent values.\n- This function is particularly useful when dealing with singleton objects or when you need to ensure that two references are indeed pointing to the same memory location.\n\n**Output Example**: \n- `is_(a, b)` returns `True` if `a` and `b` are the same object.\n- `is_(a, b)` returns `False` if `a` and `b` are different objects, even if they have the same content."
      ],
      "code_start_line": 216,
      "code_end_line": 218,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def is_(x: Any, y: Any):\n    \"\"\" Whether x is equal to y. \"\"\"\n    return x is y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "is_not",
      "md_content": [
        "**is_not**: The function of is_not is to determine whether two variables, `x` and `y`, are not the same object in memory.\n\n**parameters**: The parameters of this Function.\n· x: The first variable to be compared.\n· y: The second variable to be compared.\n\n**Code Description**: The `is_not` function checks if the two provided variables, `x` and `y`, do not refer to the same object in memory. This is achieved using the `is not` operator in Python, which returns `True` if `x` and `y` are not the same object, and `False` otherwise. This function is useful when you need to ensure that two variables are distinct objects, rather than just having the same value.\n\n**Note**: \n- This function checks for object identity, not equality of values. Two different objects with the same value will still return `True`.\n- This function is particularly useful in scenarios where object identity is crucial, such as when dealing with mutable objects or singleton patterns.\n\n**Output Example**: \n- `is_not(5, 5)` would return `False` because both `5`s are the same immutable integer object.\n- `is_not([], [])` would return `True` because each `[]` creates a new list object in memory.\n- `is_not(a, b)` where `a` and `b` are references to the same object would return `False`."
      ],
      "code_start_line": 222,
      "code_end_line": 224,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def is_not(x: Any, y: Any):\n    \"\"\" Whether x is not equal to y. \"\"\"\n    return x is not y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "in_",
      "md_content": [
        "**in_**: The function of in_ is to determine whether an element x is present within a collection y.\n\n**parameters**: The parameters of this Function.\n· x: The element to be checked for presence within the collection y.\n· y: The collection in which the presence of element x is to be checked.\n\n**Code Description**: The in_ function takes two parameters, x and y, and returns a boolean value indicating whether x is present in y. This is achieved using Python's built-in membership operator `in`, which checks for the presence of an element within a collection such as a list, tuple, set, or dictionary. The function is straightforward and leverages Python's efficient membership testing capabilities.\n\nIn the context of its usage within the project, the in_ function is called by the __contains__ method of the Node class in the opto\\trace\\nodes.py module. The __contains__ method uses the in_ function to determine if a given item is part of the Node instance. This is done by importing the in_ function from the opto.trace.operators module and applying it to the item and the Node instance itself. This integration ensures that the Node class can utilize the in_ function to perform membership tests, thereby enhancing its functionality.\n\n**Note**: \n- Ensure that the collection y supports the membership test operation.\n- The function will raise a TypeError if y is not a collection type that supports the `in` operator.\n\n**Output Example**: \n- If x is 3 and y is [1, 2, 3, 4], the function will return True.\n- If x is 'a' and y is 'hello', the function will return False."
      ],
      "code_start_line": 228,
      "code_end_line": 230,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def in_(x: Any, y: Any):\n    \"\"\" Whether x is in y. \"\"\"\n    return x in y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__contains__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "not_in",
      "md_content": [
        "**not_in**: The function of not_in is to determine whether a given element `x` is not present within another collection `y`.\n\n**parameters**: The parameters of this function.\n· x: The element to be checked for non-membership within the collection `y`.\n· y: The collection in which the presence of the element `x` is to be checked.\n\n**Code Description**: The not_in function takes two parameters, `x` and `y`. It evaluates whether the element `x` is not contained within the collection `y`. The function returns a boolean value: `True` if `x` is not in `y`, and `False` if `x` is in `y`. This is achieved using the `not in` operator in Python, which checks for non-membership.\n\n**Note**: \n- The collection `y` can be any iterable, such as a list, tuple, set, or string.\n- The function does not modify the input parameters.\n- Ensure that `y` is a valid iterable to avoid runtime errors.\n\n**Output Example**: \n- `not_in(3, [1, 2, 4, 5])` returns `True` because 3 is not in the list `[1, 2, 4, 5]`.\n- `not_in('a', 'apple')` returns `False` because 'a' is in the string 'apple'."
      ],
      "code_start_line": 234,
      "code_end_line": 236,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def not_in(x: Any, y: Any):\n    \"\"\" Whether x is not in y. \"\"\"\n    return x not in y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "getitem",
      "md_content": [
        "**getitem**: The function of getitem is to retrieve an element from a given object `x` using the specified `index`.\n\n**parameters**: The parameters of this Function.\n· x: The object from which an element is to be retrieved. This can be any type that supports indexing, such as lists, tuples, or dictionaries.\n· index: The index or key used to access the element within the object `x`.\n\n**Code Description**: The getitem function is a straightforward implementation of the indexing operation. It takes two parameters: `x` and `index`. The function returns the element of `x` located at the position specified by `index`. This is achieved using the standard indexing syntax `x[index]`.\n\nIn the context of its usage within the project, the getitem function is called by the `__getitem__` method of the `Node` class in the `opto.trace.nodes` module. When the `__getitem__` method is invoked on a `Node` instance with a specific key, it imports the getitem function from the `opto.trace.operators` module and uses it to retrieve the corresponding element from the `Node` instance. This allows for a modular and reusable approach to element retrieval within the project.\n\n**Note**: \n- Ensure that the object `x` supports the indexing operation with the provided `index`. Otherwise, an error will be raised.\n- The type of `index` should be compatible with the indexing mechanism of the object `x`.\n\n**Output Example**: \nIf `x` is a list `[10, 20, 30]` and `index` is `1`, the return value of `getitem(x, index)` will be `20`."
      ],
      "code_start_line": 241,
      "code_end_line": 243,
      "params": [
        "x",
        "index"
      ],
      "have_return": true,
      "code_content": "def getitem(x: Any, index: Any):\n    \"\"\" This is a getitem operator of x based on index. \"\"\"\n    return x[index]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__getitem__",
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "pop",
      "md_content": [
        "**pop**: The function of pop is to remove and return an element from a list `x` at the specified `index`.\n\n**parameters**: The parameters of this Function.\n· x: The list from which an element will be removed.\n· index: The position of the element to be removed from the list.\n\n**Code Description**: The `pop` function is designed to operate on a list `x` and remove the element located at the specified `index`. The function utilizes the built-in `pop` method of Python lists, which not only removes the element at the given index but also returns it. This allows the user to both modify the list by removing an element and capture the removed element for further use. The function is straightforward and leverages Python's native list handling capabilities to achieve its purpose efficiently.\n\n**Note**: \n- Ensure that the `index` provided is within the valid range of the list `x`. If the `index` is out of range, a `IndexError` will be raised.\n- The list `x` will be modified in place, meaning the original list will be changed after the function call.\n\n**Output Example**: \nIf `x = [10, 20, 30, 40]` and `index = 2`, calling `pop(x, index)` will return `30` and modify `x` to `[10, 20, 40]`."
      ],
      "code_start_line": 247,
      "code_end_line": 249,
      "params": [
        "x",
        "index"
      ],
      "have_return": true,
      "code_content": "def pop(x: Any, index: Any):\n    \"\"\" This is a pop operator of x based on index. \"\"\"\n    return x.pop(index)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "len_",
      "md_content": [
        "**len_**: The function of len_ is to return the length of the input object x.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input object whose length is to be calculated.\n\n**Code Description**: The len_ function is a utility that computes and returns the length of the input object x by leveraging Python's built-in len() function. This function is designed to be a simple wrapper around the built-in len() function, providing a consistent interface for length calculation within the project.\n\nThe function is called by the len method of the Node class in the opto\\trace\\nodes.py module. When the len method of a Node instance is invoked, it imports the len_ function from the opto.trace.operators module and applies it to the Node instance. This design allows the Node class to utilize the len_ function for determining its length, ensuring modularity and reusability of the len_ function across different parts of the project.\n\n**Note**: Ensure that the input object x is of a type that supports the len() operation, such as lists, strings, tuples, or other collections. Passing an unsupported type will result in a TypeError.\n\n**Output Example**: \n- If x is a list [1, 2, 3], len_(x) will return 3.\n- If x is a string \"hello\", len_(x) will return 5."
      ],
      "code_start_line": 253,
      "code_end_line": 255,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def len_(x: Any):\n    \"\"\" This is a len operator of x. \"\"\"\n    return len(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/len"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "ord_",
      "md_content": [
        "**ord_**: The function of ord_ is to return the Unicode number of a character.\n\n**parameters**: The parameters of this Function.\n· x: Any - The character whose Unicode number is to be returned.\n\n**Code Description**: The ord_ function takes a single parameter, x, which is expected to be a character. It returns the Unicode code point of that character using Python's built-in ord() function. The ord() function is a standard Python function that converts a single character into its corresponding Unicode integer value. This is useful for various applications, such as encoding, decoding, and character manipulation.\n\n**Note**: \n- The input parameter x should be a single character. If x is not a single character, the ord() function will raise a TypeError.\n- This function is designed to handle any character that can be represented in Unicode.\n\n**Output Example**: \n- ord_('A') will return 65.\n- ord_('€') will return 8364."
      ],
      "code_start_line": 260,
      "code_end_line": 262,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def ord_(x: Any):\n    \"\"\" The unicode number of a character. \"\"\"\n    return ord(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "chr_",
      "md_content": [
        "**chr_**: The function of chr_ is to return the character corresponding to a given Unicode number.\n\n**parameters**: The parameters of this Function.\n· x: A Unicode number (integer) that represents a specific character.\n\n**Code Description**: The chr_ function takes a single parameter, x, which is expected to be an integer representing a Unicode code point. The function then uses Python's built-in chr() function to convert this Unicode number into its corresponding character. The result is the character that the Unicode number represents. This function is useful for converting numerical Unicode values into their string character equivalents.\n\n**Note**: \n- The input parameter x must be a valid Unicode code point. If x is not a valid Unicode code point, a ValueError will be raised.\n- The function does not perform any type checking or validation on the input parameter, so it is the caller's responsibility to ensure that x is a valid integer within the Unicode range.\n\n**Output Example**: \n- chr_(65) will return 'A'.\n- chr_(8364) will return '€'."
      ],
      "code_start_line": 266,
      "code_end_line": 268,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def chr_(x: Any):\n    \"\"\" The character of a unicode number. \"\"\"\n    return chr(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "concat",
      "md_content": [
        "**concat**: The function of concat is to concatenate two given inputs, x and y.\n\n**parameters**: The parameters of this Function.\n· x: The first input to be concatenated. It can be of any type.\n· y: The second input to be concatenated. It can be of any type.\n\n**Code Description**: The concat function takes two parameters, x and y, and returns their concatenation using the + operator. This function is designed to handle inputs of any type, leveraging Python's dynamic typing and the + operator's ability to concatenate various data types such as strings, lists, and tuples. \n\nIn the context of its usage within the project, the concat function is called by the __add__ method of the Node class in the opto\\trace\\nodes.py module. When the __add__ method is invoked, it checks the type of the _data attribute of the Node instance. If _data is a string, the concat function is used to concatenate the current Node instance with another Node instance created from the other parameter. This ensures that string concatenation is handled appropriately within the Node class.\n\n**Note**: \n- Ensure that the types of x and y are compatible with the + operator to avoid TypeErrors.\n- The behavior of the + operator varies depending on the types of x and y. For example, it concatenates strings and lists but adds numbers.\n\n**Output Example**: \n- If x is \"Hello\" and y is \"World\", the return value will be \"HelloWorld\".\n- If x is [1, 2] and y is [3, 4], the return value will be [1, 2, 3, 4].\n- If x is (1, 2) and y is (3, 4), the return value will be (1, 2, 3, 4)."
      ],
      "code_start_line": 272,
      "code_end_line": 274,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def concat(x: Any, y: Any):\n    \"\"\" This is a concatenation operator of x and y. \"\"\"\n    return x + y\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__add__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "lower",
      "md_content": [
        "**lower**: The function of lower is to convert all characters in the input `x` to lower case.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value that will be converted to lower case. It is expected to be a string or an object that has a `lower()` method.\n\n**Code Description**: The `lower` function takes a single parameter `x` and returns the result of calling the `lower()` method on `x`. This method is typically available on string objects in Python and converts all uppercase characters in the string to their lowercase counterparts. If `x` is not a string or does not have a `lower()` method, the function will raise an AttributeError.\n\n**Note**: \n- Ensure that the input `x` is a string or an object that implements a `lower()` method to avoid runtime errors.\n- This function does not handle non-string inputs that do not have a `lower()` method.\n\n**Output Example**: \n```python\nlower(\"HELLO\")  # Returns \"hello\"\nlower(\"Python\")  # Returns \"python\"\n```"
      ],
      "code_start_line": 278,
      "code_end_line": 280,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def lower(x: Any):\n    \"\"\" This makes all characters in x lower case. \"\"\"\n    return x.lower()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "upper",
      "md_content": [
        "**upper**: The function of upper is to convert all characters in the input to upper case.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value that will be converted to upper case. This can be any type that supports the `upper()` method, typically a string.\n\n**Code Description**: The `upper` function takes a single parameter `x` and returns the result of calling the `upper()` method on `x`. The `upper()` method is a built-in string method in Python that converts all lowercase letters in a string to uppercase letters. If `x` is not a string or does not support the `upper()` method, the function will raise an AttributeError.\n\n**Note**: \n- Ensure that the input `x` is of a type that supports the `upper()` method, typically a string, to avoid runtime errors.\n- This function does not modify the original input but returns a new string with all characters in upper case.\n\n**Output Example**: \n```python\nresult = upper(\"hello world\")\nprint(result)  # Output: \"HELLO WORLD\"\n```"
      ],
      "code_start_line": 284,
      "code_end_line": 286,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def upper(x: Any):\n    \"\"\" This makes all characters in x upper case. \"\"\"\n    return x.upper()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "title",
      "md_content": [
        "**title**: The function of title is to convert the first character of each word in a string to uppercase and the remaining characters to lowercase.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input parameter which is expected to be a string.\n\n**Code Description**: The title function takes a single parameter, x, which is expected to be a string. It applies the title() method to the string, which capitalizes the first character of each word and converts all other characters to lowercase. This is useful for formatting strings in a standardized way, such as for titles or headings.\n\n**Note**: \n- The input should be a string for the function to work correctly. If the input is not a string, it may result in an AttributeError since the title() method is specific to string objects.\n- This function does not handle non-alphabetic characters differently; they will remain unchanged.\n\n**Output Example**: \nIf the input string is \"hello world\", the function will return \"Hello World\".\nIf the input string is \"PYTHON programming\", the function will return \"Python Programming\"."
      ],
      "code_start_line": 290,
      "code_end_line": 292,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def title(x: Any):\n    \"\"\" This makes the first character to upper case and the rest to lower case. \"\"\"\n    return x.title()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "swapcase",
      "md_content": [
        "**swapcase**: The function of swapcase is to swap the case of all characters in the input: converting uppercase characters to lowercase and vice-versa.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value whose characters' cases are to be swapped. This can be any type that supports the `swapcase` method, typically a string.\n\n**Code Description**: The swapcase function takes a single parameter `x` and returns a new value where all uppercase characters in `x` are converted to lowercase, and all lowercase characters are converted to uppercase. The function leverages the built-in `swapcase` method available on string-like objects in Python. This method is particularly useful for text processing tasks where case conversion is required.\n\n**Note**: \n- The input `x` must be of a type that supports the `swapcase` method, such as a string. If `x` does not support this method, the function will raise an AttributeError.\n- The function does not modify the original input but returns a new value with the cases swapped.\n\n**Output Example**: \n- If the input is `\"Hello World\"`, the output will be `\"hELLO wORLD\"`.\n- If the input is `\"Python3.8\"`, the output will be `\"pYTHON3.8\"`."
      ],
      "code_start_line": 296,
      "code_end_line": 298,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def swapcase(x: Any):\n    \"\"\" Swaps the case of all characters: uppercase character to lowercase and vice-versa. \"\"\"\n    return x.swapcase()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "capitalize",
      "md_content": [
        "**capitalize**: The function of capitalize is to convert the first character of a string to uppercase.\n\n**parameters**: The parameters of this Function.\n· x: Any - The input value that is expected to be a string.\n\n**Code Description**: The capitalize function takes a single parameter, `x`, which is expected to be a string. It utilizes the built-in `capitalize` method of Python strings to convert the first character of the string to uppercase while leaving the rest of the string unchanged. The function then returns the modified string. If `x` is not a string, the function will raise an AttributeError since the `capitalize` method is not available for non-string types.\n\n**Note**: \n- Ensure that the input `x` is a string to avoid runtime errors.\n- This function does not modify the original string but returns a new string with the first character capitalized.\n\n**Output Example**: \n```python\ncapitalize(\"hello world\")  # Returns \"Hello world\"\ncapitalize(\"python\")       # Returns \"Python\"\n```"
      ],
      "code_start_line": 302,
      "code_end_line": 304,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def capitalize(x: Any):\n    \"\"\" Converts the first character of a string to uppercase. \"\"\"\n    return x.capitalize()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "split",
      "md_content": [
        "**split**: The function of split is to divide a string `x` into parts based on the occurrence of a substring `y`, returning the segments of the string without the substring `y`.\n\n**parameters**: The parameters of this function.\n· x: The main string that needs to be split.\n· y: The substring used as the delimiter to split the main string `x`.\n· maxsplit: An optional parameter that specifies the maximum number of splits to perform. The default value is -1, which means no limit on the number of splits.\n\n**Code Description**: The `split` function takes three parameters: `x`, `y`, and `maxsplit`. It utilizes Python's built-in `split` method to divide the string `x` into parts wherever the substring `y` occurs. The `maxsplit` parameter controls the maximum number of splits that can be performed. If `maxsplit` is not provided, or if it is set to -1, the function will split the string at all occurrences of the substring `y`. The function returns a list containing the parts of the string `x` that were separated by the substring `y`.\n\n**Note**: \n- The function will return a list of strings.\n- If the substring `y` is not found in the main string `x`, the function will return a list containing the original string `x` as its only element.\n- If `maxsplit` is set to 0, the function will return a list containing the original string `x` as its only element, as no splitting will be performed.\n\n**Output Example**: \n```python\nsplit(\"hello world\", \" \") \n# Output: ['hello', 'world']\n\nsplit(\"apple,banana,cherry\", \",\", 1) \n# Output: ['apple', 'banana,cherry']\n\nsplit(\"one,two,three,four\", \",\", 2) \n# Output: ['one', 'two', 'three,four']\n\nsplit(\"no delimiter here\", \",\") \n# Output: ['no delimiter here']\n```"
      ],
      "code_start_line": 308,
      "code_end_line": 310,
      "params": [
        "x",
        "y",
        "maxsplit"
      ],
      "have_return": true,
      "code_content": "def split(x: Any, y: Any, maxsplit: Any = -1):\n    \"\"\" Splits the string by finding a substring y in string x, return the first part and second part of string x without y. \"\"\"\n    return x.split(y, maxsplit)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "strip",
      "md_content": [
        "**strip**: The function of strip is to remove the leading and trailing characters from the input `x`.\n\n**parameters**: The parameters of this function.\n· `x`: The input from which leading and trailing characters will be removed. It can be of any type that supports the `strip` method, typically a string.\n· `chars`: Optional. A string specifying the set of characters to be removed. If not provided, whitespace characters will be removed by default.\n\n**Code Description**: The `strip` function is designed to clean up the input `x` by removing any leading and trailing characters specified by the `chars` parameter. If `chars` is not provided, the function defaults to removing whitespace characters. The function leverages the built-in `strip` method available in Python for strings, ensuring efficient and reliable performance. The return value is the cleaned version of `x` with the specified characters removed from both ends.\n\n**Note**: \n- The input `x` must be of a type that supports the `strip` method, such as a string.\n- If `chars` is not specified, the function will remove whitespace characters by default.\n- This function does not modify the original input but returns a new string with the specified characters removed.\n\n**Output Example**: \n- `strip(\"  hello  \")` returns `\"hello\"`.\n- `strip(\"##hello##\", \"#\")` returns `\"hello\"`."
      ],
      "code_start_line": 314,
      "code_end_line": 316,
      "params": [
        "x",
        "chars"
      ],
      "have_return": true,
      "code_content": "def strip(x: Any, chars=None):\n    \"\"\" Removes the leading and trailing characters of x. \"\"\"\n    return x.strip(chars)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "replace",
      "md_content": [
        "**replace**: The function of replace is to replace all occurrences of a specified substring within a given string with another substring.\n\n**parameters**: The parameters of this function.\n· x: The original string in which the replacement is to be made.\n· old: The substring that needs to be replaced.\n· new: The substring that will replace the old substring.\n· count: The maximum number of occurrences to replace. If not specified, all occurrences will be replaced. The default value is -1, which means replace all occurrences.\n\n**Code Description**: The replace function takes four parameters: x, old, new, and count. It utilizes the built-in string method `replace` to substitute all instances of the substring specified by `old` with the substring specified by `new` within the string `x`. The `count` parameter controls the number of replacements to be made. If `count` is set to -1 (the default value), all occurrences of the substring `old` will be replaced by `new`. If `count` is a positive integer, only that many occurrences of `old` will be replaced.\n\n**Note**: \n- The function is case-sensitive, meaning that it will only replace substrings that match the case of `old`.\n- If `old` is not found in `x`, the original string `x` will be returned unchanged.\n- The `count` parameter must be a non-negative integer or -1.\n\n**Output Example**: \n- replace(\"hello world\", \"world\", \"there\") returns \"hello there\".\n- replace(\"hello world world\", \"world\", \"there\", 1) returns \"hello there world\".\n- replace(\"hello world\", \"WORLD\", \"there\") returns \"hello world\" (case-sensitive)."
      ],
      "code_start_line": 320,
      "code_end_line": 322,
      "params": [
        "x",
        "old",
        "new",
        "count"
      ],
      "have_return": true,
      "code_content": "def replace(x: Any, old: Any, new: Any, count: Any = -1):\n    \"\"\" Replaces all occurrences of substring y in string x with z. \"\"\"\n    return x.replace(old, new, count)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "format",
      "md_content": [
        "**format**: The function of format is to fill in a string template with content using the str.format() method.\n\n**parameters**: The parameters of this Function.\n· x: A string template that contains placeholders to be filled.\n· *args: Positional arguments to be used for filling the placeholders in the string template.\n· **kwargs: Keyword arguments to be used for filling the placeholders in the string template.\n\n**Code Description**: The format function takes a string template `x` and fills it with the provided positional (`*args`) and keyword arguments (`**kwargs`). It leverages Python's built-in `str.format()` method to perform this operation. The `str.format()` method allows for complex string formatting operations, including the insertion of variables, formatting of numbers, and more. By passing the arguments and keyword arguments to `x.format(*args, **kwargs)`, the function dynamically replaces the placeholders in the string template with the corresponding values.\n\n**Note**: \n- Ensure that the string template `x` contains valid placeholders that match the provided arguments.\n- The function will raise a `KeyError` if a placeholder in the template does not have a corresponding keyword argument.\n- The function will raise an `IndexError` if a placeholder in the template does not have a corresponding positional argument.\n\n**Output Example**: \nIf the function is called as follows:\n```python\nformat(\"Hello, {}!\", \"World\")\n```\nThe return value will be:\n```python\n\"Hello, World!\"\n```\n\nIf the function is called with keyword arguments:\n```python\nformat(\"Hello, {name}!\", name=\"Alice\")\n```\nThe return value will be:\n```python\n\"Hello, Alice!\"\n```"
      ],
      "code_start_line": 326,
      "code_end_line": 328,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def format(x: Any, *args, **kwargs):\n    \"\"\" Fills in a string template with content, str.format(). \"\"\"\n    return x.format(*args, **kwargs)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "node_getattr",
      "md_content": [
        "**node_getattr**: The function of node_getattr is to get the value of the specified attribute from the given object.\n\n**Parameters**:\n- obj: A Node object from which the attribute value is to be retrieved.\n- attr: A string representing the name of the attribute to be retrieved.\n\n**Code Description**:\nThe `node_getattr` function takes in a `Node` object `obj` and a string `attr` as parameters. It first checks if the `obj` is an instance of a dictionary. If it is, it retrieves the value associated with the `attr` key from the dictionary. Otherwise, it uses the `getattr` function to retrieve the value of the `attr` attribute from the `obj`.\n\nThis function is used in the `getattr` method of the `Node` class in the `opto.trace.nodes.py` module. The `getattr` method is responsible for getting the value of the specified attribute from the `Node` object. It calls the `node_getattr` function passing itself (`self`) and the specified attribute (`key`) as arguments.\n\n**Note**:\n- The `node_getattr` function assumes that the `obj` parameter is a valid `Node` object.\n- If the `obj` is not an instance of a dictionary and does not have the specified attribute, a `AttributeError` will be raised.\n\n**Output Example**:\nIf `obj` is a dictionary and contains the attribute `attr`, the function will return the value associated with the `attr` key. Otherwise, it will return the value of the `attr` attribute from the `obj`."
      ],
      "code_start_line": 331,
      "code_end_line": 333,
      "params": [
        "obj",
        "attr"
      ],
      "have_return": true,
      "code_content": "def node_getattr(obj: Node, attr: str):\n    \"\"\" This operator gets attr of obj. \"\"\"\n    return obj[attr] if isinstance(obj, dict) else getattr(obj, attr)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/getattr"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "call",
      "md_content": [
        "**call**: The function of call is to call the function `fun` with the provided arguments `args` and `kwargs`.\n\n**parameters**:\n- `fun`: A Node object representing the function to be called.\n- `*args`: Variable-length argument list.\n- `**kwargs`: Keyword arguments.\n\n**Code Description**:\nThe `call` function takes a `fun` parameter, which is a Node object representing the function to be called. It also accepts variable-length arguments `args` and keyword arguments `kwargs`. The purpose of this function is to call the function `fun` with the provided arguments.\n\nFirst, the function assigns the value of `fun` to a local variable `fun` by accessing the `_data` attribute of the `fun` object. This allows the function to work with the actual function object rather than the Node object.\n\nNext, the function checks if the `fun` object is callable using the `callable()` function. If it is not callable, an `AssertionError` is raised with the message \"The function must be callable.\"\n\nThen, the function calls the `fun` function with the provided arguments `args` and keyword arguments `kwargs` using the `*args` and `**kwargs` syntax. The result of the function call is stored in the `output` variable.\n\nFinally, the function returns the `output` variable.\n\n**Note**:\n- The `fun` parameter must be a callable function.\n- The `args` parameter can accept any number of positional arguments.\n- The `kwargs` parameter can accept any number of keyword arguments.\n\n**Output Example**:\nIf the `fun` function is defined as follows:\n```python\ndef add(a, b):\n    return a + b\n```\nand the `call` function is called with `fun=add` and `args=(2, 3)`, the output will be `5`."
      ],
      "code_start_line": 340,
      "code_end_line": 347,
      "params": [
        "fun"
      ],
      "have_return": true,
      "code_content": "def call(fun: Node, *args, **kwargs):\n    \"\"\" This operator calls the function `fun` with args (args_0, args_1, etc.) and kwargs. If there are no args or kwargs, i.e. call(fun=function_name), the function takes no input. \"\"\"\n    # Run the function as it is\n    fun = fun._data\n    # Call the node with the input arguments\n    assert callable(fun), \"The function must be callable.\"\n    output = fun(*args, **kwargs)\n    return output\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/__call__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    }
  ],
  "opto\\trace\\trace.py": [
    {
      "type": "ClassDef",
      "name": "stop_tracing",
      "md_content": [
        "**stop_tracing**: The function of stop_tracing is to disable tracing within a specific context.\n\n**attributes**:\n- None\n\n**Code Description**:\nThe `stop_tracing` class is a context manager that is used to disable tracing within a specific context. When the `stop_tracing` object is entered, it sets the `GRAPH.TRACE` attribute to `False`, effectively disabling tracing. When the context is exited, the `GRAPH.TRACE` attribute is set back to `True`, enabling tracing again.\n\nThis class is typically used in conjunction with the `trace` module to control the tracing behavior of a program. Tracing is a technique used to monitor the execution of a program by recording information about each executed statement. By disabling tracing within a specific context, developers can exclude certain parts of the code from being traced, which can be useful for performance optimization or debugging purposes.\n\nIn the project, the `stop_tracing` class is called in the `test_bundle.py` file within the `run` function. It is used to disable tracing while executing certain code blocks. This allows developers to selectively trace or exclude specific parts of the code during testing.\n\n**Note**:\n- The `stop_tracing` class is a context manager, so it should be used within a `with` statement to ensure proper entry and exit.\n- Disabling tracing can be useful for performance optimization or debugging purposes, but it should be used with caution as it may affect the accuracy of the tracing results."
      ],
      "code_start_line": 5,
      "code_end_line": 12,
      "params": [],
      "have_return": false,
      "code_content": "class stop_tracing:\n    \"\"\"A contextmanager to disable tracing.\"\"\"\n\n    def __enter__(self):\n        GRAPH.TRACE = False\n\n    def __exit__(self, type, value, traceback):\n        GRAPH.TRACE = True\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\__init__.py",
        "tests\\unit_tests\\test_bundle.py/run"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__enter__",
      "md_content": [
        "**__enter__**: The function of __enter__ is to set the tracing state to False.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the class that contains this method.\n\n**Code Description**: The __enter__ method is a special method used in the context management protocol in Python. When an instance of the class containing this method is used in a `with` statement, the __enter__ method is automatically invoked at the beginning of the block. In this specific implementation, the __enter__ method sets the `TRACE` attribute of the `GRAPH` object to `False`. This action effectively stops or disables tracing within the context of the `with` statement. The `GRAPH` object is assumed to be a global or otherwise accessible object that controls tracing functionality.\n\n**Note**: \n- Ensure that the `GRAPH` object and its `TRACE` attribute are properly defined and accessible within the scope where this method is used.\n- This method is typically used in conjunction with the `__exit__` method to manage resources or states within a `with` statement."
      ],
      "code_start_line": 8,
      "code_end_line": 9,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __enter__(self):\n        GRAPH.TRACE = False\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__exit__",
      "md_content": [
        "**__exit__**: The function of __exit__ is to reset the tracing state by setting `GRAPH.TRACE` to `True`.\n\n**parameters**: The parameters of this Function.\n· type: The exception type, if any exception was raised.\n· value: The exception instance, if any exception was raised.\n· traceback: The traceback object, if any exception was raised.\n\n**Code Description**: The `__exit__` method is a special method used in context management in Python. It is called when the execution of a block inside a `with` statement is finished. In this specific implementation, the `__exit__` method sets the `TRACE` attribute of the `GRAPH` object to `True`. This indicates that tracing should be enabled or resumed after the context block is exited, regardless of whether an exception was raised or not. The method takes three parameters: `type`, `value`, and `traceback`, which are standard for the `__exit__` method and provide information about any exception that may have occurred within the `with` block.\n\n**Note**: \n- This method is part of the context management protocol and is automatically invoked at the end of a `with` statement.\n- The parameters `type`, `value`, and `traceback` are necessary for handling exceptions, but in this implementation, they are not used.\n- Ensure that `GRAPH` and its `TRACE` attribute are properly defined and accessible within the scope where this `__exit__` method is used."
      ],
      "code_start_line": 11,
      "code_end_line": 12,
      "params": [
        "self",
        "type",
        "value",
        "traceback"
      ],
      "have_return": false,
      "code_content": "    def __exit__(self, type, value, traceback):\n        GRAPH.TRACE = True\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\trace\\utils.py": [
    {
      "type": "FunctionDef",
      "name": "contain",
      "md_content": [
        "**contain**: The function of contain is to check if a given node is present in a container of nodes.\n**parameters**:\n- container_of_nodes: A container (such as a list or set) that holds nodes.\n- node: The node to be checked for presence in the container.\n**Code Description**:\nThe `contain` function takes in a container of nodes and a node as parameters. It uses a list comprehension to iterate over the container and checks if the given node is identical (using the `is` operator) to any of the nodes in the container. The function returns `True` if the node is found in the container, and `False` otherwise.\n\nThis function is used in various parts of the project. In the `opto\\trace\\bundle.py/FunModule/forward` function, the `contain` function is called to check if a node is present in the `container_of_nodes` list. It is used to determine the external dependencies of the operator function.\n\nIn the `opto\\trace\\utils.py/MinHeap/__contains__` function, the `contain` function is used to check if an item is present in the `self.heap` list.\n\nThe `contain` function is also used in the `tests\\unit_tests\\test_bundle.py/run` function to check if a node is present in a container of nodes.\n\n**Note**: The `contain` function checks for identity (using the `is` operator) instead of value equality. This means that it will only return `True` if the node is the exact same object in memory as one of the nodes in the container.\n\n**Output Example**: \n```python\ncontainer_of_nodes = [node(1), node(2), node(3)]\nnode = node(2)\nprint(contain(container_of_nodes, node))\n# Output: True\n```"
      ],
      "code_start_line": 11,
      "code_end_line": 13,
      "params": [
        "container_of_nodes",
        "node"
      ],
      "have_return": true,
      "code_content": "def contain(container_of_nodes, node):\n    # check for identity instead of value\n    return any([node is n for n in container_of_nodes])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\bundle.py",
        "opto\\trace\\bundle.py/FunModule/forward",
        "opto\\trace\\utils.py/MinHeap/__contains__",
        "tests\\unit_tests\\test_bundle.py",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_nodes.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parse_eqs_to_dict",
      "md_content": [
        "**parse_eqs_to_dict**: The function of parse_eqs_to_dict is to parse a given text containing equations into a dictionary.\n\n**parameters**: The parameters of this Function.\n· text: A string containing equations separated by new lines. Each equation should be in the format `key=value`.\n\n**Code Description**: The parse_eqs_to_dict function processes a string of equations and converts it into a dictionary where each key-value pair represents an equation. The function follows these steps:\n\n1. **Splitting the Input Text**: The input text is split into individual lines using the newline character (`\\n`) as the delimiter.\n2. **Initialization**: An empty dictionary `result_dict` is initialized to store the parsed key-value pairs. A variable `last_key` is also initialized to keep track of the last processed key.\n3. **Processing Each Line**:\n   - The function iterates over each line in the split text.\n   - If a line is empty, it is skipped.\n   - If a line contains an equals sign (`=`), it is split into a key and a value at the first occurrence of the equals sign. The key is stripped of any leading or trailing whitespace, and the value has any backticks (`) removed. The key-value pair is then added to the dictionary, and `last_key` is updated to the current key.\n   - If a line does not contain an equals sign but `last_key` is set, the line is considered a continuation of the previous value. The line is appended to the value of `last_key` in the dictionary, with any backticks removed.\n4. **Returning the Result**: After processing all lines, the function returns the populated dictionary.\n\n**Note**: \n- The function assumes that each equation is either on a single line or that subsequent lines without an equals sign are continuations of the previous value.\n- Backticks (`) in the values are removed during processing.\n\n**Output Example**: \nGiven the input text:\n```\nx0 = 1\nx1=2\nx2=`2`\nx3= def fun():\\n    print('hello')\\n\nabc_test1=test\n```\nThe function would return:\n```\n{\n    'x0': '1',\n    'x1': '2',\n    'x2': '2',\n    'x3': \"def fun():\\nprint('hello')\",\n    'abc_test1': 'test'\n}\n```"
      ],
      "code_start_line": 16,
      "code_end_line": 42,
      "params": [
        "text"
      ],
      "have_return": true,
      "code_content": "def parse_eqs_to_dict(text):\n    \"\"\"\n    Parse the text of equations into a didctionary\n\n        x0 = 1\n        x1=2\n        x2=`2`\n        x3= def fun():\\n    print('hello')\\n\n        abc_test1=test\n\n    would be parsed into\n\n    {'x0': '1', 'x1': '2', 'x2': '2', 'x3': \"def fun():\\nprint('hello')\", 'abc_test1': 'test'}\n    \"\"\"\n    lines = text.split(\"\\n\")\n    result_dict = {}\n    last_key = None\n    for line in lines:\n        if line == \"\":\n            continue\n        if \"=\" in line:\n            key, value = line.split(\"=\", 1)\n            last_key = key.strip()\n            result_dict[last_key] = value.replace(\"`\", \"\")\n        elif last_key:\n            result_dict[last_key] += \"\\n\" + line.replace(\"`\", \"\")\n    return result_dict\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "MinHeap",
      "md_content": [
        "**MinHeap**: The function of MinHeap is to implement a minimum heap data structure, which supports efficient retrieval and removal of the smallest element.\n\n**attributes**: The attributes of this Class.\n· heap: A list that stores the elements of the heap.\n\n**Code Description**: The MinHeap class provides a minimum heap implementation with various methods to manage the heap's elements. The class supports initialization with an optional array, element insertion, element removal, and peeking at the smallest element. It also includes internal methods to maintain the heap property.\n\n- `__init__(self, arr=None)`: Initializes the heap. If an array is provided, it converts the array into a heap using the `heapify` method. Otherwise, it initializes an empty heap.\n- `__contains__(self, item)`: Checks if an item is in the heap using a helper function `contain`.\n- `__len__(self)`: Returns the number of elements in the heap.\n- `push(self, item)`: Adds a new item to the heap and ensures the heap property is maintained by calling the `_siftup` method.\n- `pop(self)`: Removes and returns the smallest item from the heap. It maintains the heap property by calling the `_siftdown` method after removing the root.\n- `peek(self)`: Returns the smallest item without removing it from the heap.\n- `_siftup(self, idx)`: Ensures the heap property is maintained from a given index upwards to the root.\n- `_siftdown(self, idx)`: Ensures the heap property is maintained from a given index downwards to the leaves.\n- `heapify(self, arr)`: Converts an array into a heap by copying the array and calling `_siftdown` on each non-leaf node.\n\nThe MinHeap class is utilized in the `backward` method of the `Node` class in `opto\\trace\\nodes.py`. In this context, MinHeap is used to manage a priority queue for nodes during a backward pass operation. The `backward` method initializes a MinHeap with the current node and uses it to efficiently process nodes in the correct order, ensuring that feedback is propagated correctly through the graph.\n\n**Note**: \n- The elements stored in the heap must support comparison operations (`lt` and `gt` methods).\n- The `contain` function used in `__contains__` is assumed to be defined elsewhere in the codebase.\n\n**Output Example**: \n- `push(item)`: Adds `item` to the heap.\n- `pop()`: Returns the smallest element, e.g., `3`.\n- `peek()`: Returns the smallest element without removing it, e.g., `3`.\n- `__len__()`: Returns the number of elements in the heap, e.g., `5`.\n- `__contains__(item)`: Returns `True` if `item` is in the heap, otherwise `False`."
      ],
      "code_start_line": 45,
      "code_end_line": 110,
      "params": [],
      "have_return": true,
      "code_content": "class MinHeap:\n    def __init__(self, arr=None):\n        if arr is None:\n            self.heap = []\n        else:\n            self.heap = arr\n            self.heapify(self.heap)\n\n    def __contains__(self, item):\n        # return item in self.heap\n        return contain(self.heap, item)\n\n    def __len__(self):\n        return len(self.heap)\n\n    def push(self, item):\n        self.heap.append(item)\n        self._siftup(len(self.heap) - 1)\n\n    def pop(self):\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()  # Move the last element to the root\n        self._siftdown(0)\n        return root\n\n    def peek(self):\n        return self.heap[0] if self.heap else None\n\n    def _siftup(self, idx):\n        while idx > 0:\n            parent_idx = (idx - 1) // 2\n            # >\n            if self.heap[parent_idx].gt(self.heap[idx]):\n                self.heap[parent_idx], self.heap[idx] = self.heap[idx], self.heap[parent_idx]\n                idx = parent_idx\n            else:\n                break\n\n    def _siftdown(self, idx):\n        last_idx = len(self.heap) - 1\n        while True:\n            left_child_idx = 2 * idx + 1\n            right_child_idx = 2 * idx + 2\n            smallest_idx = idx\n\n            # if left_child_idx <= last_idx and self.heap[left_child_idx] < self.heap[smallest_idx]:\n            if left_child_idx <= last_idx and self.heap[left_child_idx].lt(self.heap[smallest_idx]):\n                smallest_idx = left_child_idx\n            # if right_child_idx <= last_idx and self.heap[right_child_idx] < self.heap[smallest_idx]:\n            if right_child_idx <= last_idx and self.heap[right_child_idx].lt(self.heap[smallest_idx]):\n                smallest_idx = right_child_idx\n\n            if smallest_idx != idx:\n                self.heap[idx], self.heap[smallest_idx] = self.heap[smallest_idx], self.heap[idx]\n                idx = smallest_idx\n            else:\n                break\n\n    def heapify(self, arr):\n        import copy\n\n        self.heap = copy.copy(arr)\n        for i in range((len(self.heap) - 2) // 2, -1, -1):\n            self._siftdown(i)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py",
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize a MinHeap object, optionally transforming an input array into a valid min-heap.\n\n**parameters**: The parameters of this Function.\n· arr: An optional array to be transformed into a min-heap. If not provided, an empty heap is initialized.\n\n**Code Description**: The __init__ method is the constructor for the MinHeap class. It initializes the heap based on the provided input array. If no array is provided (`arr` is `None`), it initializes an empty list to represent the heap. If an array is provided, it assigns this array to the heap and then calls the `heapify` method to transform the array into a valid min-heap.\n\nThe `heapify` method is responsible for ensuring that the array satisfies the heap property, where each parent node is less than or equal to its child nodes. This transformation is crucial for the correct functioning of the heap operations.\n\n**Note**: Points to note about the use of the code\n- If an array is provided during initialization, it will be automatically transformed into a min-heap.\n- The `heapify` method modifies the heap in place and ensures the heap property is maintained.\n- Proper initialization of the heap is essential for the efficiency and correctness of subsequent heap operations such as insertion and deletion."
      ],
      "code_start_line": 46,
      "code_end_line": 51,
      "params": [
        "self",
        "arr"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, arr=None):\n        if arr is None:\n            self.heap = []\n        else:\n            self.heap = arr\n            self.heapify(self.heap)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\utils.py/MinHeap/heapify"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__contains__",
      "md_content": [
        "**__contains__**: The function of `__contains__` is to check if a given item is present in the heap of the `MinHeap` class.\n\n**parameters**: The parameters of this function.\n· item: The item to be checked for presence in the heap.\n\n**Code Description**: The `__contains__` function is a special method in Python that allows the use of the `in` keyword to check for the presence of an item in an instance of the `MinHeap` class. This function takes a single parameter, `item`, which represents the item to be checked.\n\nInternally, the function calls the `contain` function, passing `self.heap` and `item` as arguments. The `contain` function iterates over the `self.heap` list and checks if the `item` is identical to any of the elements in the list using the `is` operator. If the `item` is found, the `contain` function returns `True`; otherwise, it returns `False`.\n\nThis method provides a convenient way to check for the presence of an item in the heap, leveraging the identity check mechanism provided by the `contain` function.\n\n**Note**: The `contain` function checks for identity (using the `is` operator) instead of value equality. This means that `__contains__` will only return `True` if the `item` is the exact same object in memory as one of the elements in `self.heap`.\n\n**Output Example**:\n```python\nmin_heap = MinHeap()\nmin_heap.heap = [node(1), node(2), node(3)]\nitem = node(2)\nprint(item in min_heap)\n# Output: True\n```"
      ],
      "code_start_line": 53,
      "code_end_line": 55,
      "params": [
        "self",
        "item"
      ],
      "have_return": true,
      "code_content": "    def __contains__(self, item):\n        # return item in self.heap\n        return contain(self.heap, item)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\utils.py/contain"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__len__",
      "md_content": [
        "**__len__**: The function of __len__ is to return the number of elements in the MinHeap.\n\n**parameters**: The parameters of this Function.\n· self: Refers to the instance of the MinHeap class.\n\n**Code Description**: The __len__ method is a special method in Python that is used to define the behavior of the len() function for instances of a class. In this case, the __len__ method is implemented for the MinHeap class. When len() is called on an instance of MinHeap, this method returns the number of elements currently stored in the heap. It achieves this by returning the length of the internal list self.heap, which is used to store the heap elements.\n\n**Note**: \n- This method does not take any parameters other than self.\n- It is important to ensure that self.heap is always a list, as the len() function is called on it.\n\n**Output Example**: \nIf the MinHeap instance contains 5 elements, calling len(min_heap_instance) will return 5."
      ],
      "code_start_line": 57,
      "code_end_line": 58,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __len__(self):\n        return len(self.heap)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "push",
      "md_content": [
        "**push**: The function of push is to add a new item to the MinHeap and maintain the heap property.\n\n**parameters**: The parameters of this Function.\n· item: The item to be added to the heap.\n\n**Code Description**: The push function is a method of the MinHeap class that adds a new item to the heap and ensures that the heap property is maintained. When an item is pushed onto the heap, it is first appended to the end of the heap list. This operation increases the size of the heap by one.\n\nAfter appending the new item, the push function calls the _siftup method with the index of the newly added item, which is the last index of the heap list. The _siftup method is responsible for moving the new item up the heap until the heap property is restored. The heap property in a MinHeap requires that each parent node is less than or equal to its child nodes. The _siftup method ensures that this property is maintained by comparing the new item with its parent and swapping them if necessary. This process continues iteratively until the new item is in a position where the heap property is satisfied or it becomes the root of the heap.\n\nThe push function is used in the backward method of the Node class in the context of a priority queue. In the backward method, nodes are processed in a specific order, and the MinHeap is used to manage this order efficiently. When a parent node needs to be added to the queue, the push function is called to insert the parent node into the MinHeap, ensuring that the heap property is maintained and the nodes are processed in the correct order.\n\n**Note**:\n- The push function relies on the _siftup method to maintain the heap property.\n- The heap property ensures that the smallest element is always at the root of the MinHeap.\n- The elements in the heap must implement the gt method correctly for the _siftup method to function properly.\n- The push function is integral to the operation of the MinHeap in managing the order of nodes in the backward method of the Node class."
      ],
      "code_start_line": 60,
      "code_end_line": 62,
      "params": [
        "self",
        "item"
      ],
      "have_return": false,
      "code_content": "    def push(self, item):\n        self.heap.append(item)\n        self._siftup(len(self.heap) - 1)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [
        "opto\\trace\\utils.py/MinHeap/_siftup"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "pop",
      "md_content": [
        "**pop**: The function of pop is to remove and return the root element from the heap.\n\n**parameters**:\n- self: The instance of the MinHeap class.\n\n**Code Description**:\nThe pop function is a method of the MinHeap class that is used to remove and return the root element from the heap. The function first checks if the length of the heap is equal to 1, which indicates that there is only one element in the heap. In this case, the function simply calls the pop method of the heap list and returns the popped element.\n\nIf there are more than one element in the heap, the function proceeds to assign the value of the root element (the first element in the heap) to the variable \"root\". Then, it replaces the root element with the last element in the heap by assigning the popped element from the heap list to the index 0 of the heap list. This step is necessary to maintain the heap property after removing the root element.\n\nAfter replacing the root element, the function calls the _siftdown method to sift down the new root element to its correct position in the heap. This ensures that the heap property is maintained and the new root element is correctly positioned relative to its children.\n\nFinally, the function returns the original root element that was stored in the \"root\" variable.\n\nThe pop function is called by other methods in the MinHeap class, such as the heapify method. It relies on the _siftdown method to maintain the heap property after removing the root element.\n\n**Note**:\n- The pop function assumes that the heap is represented as a list.\n- The function modifies the heap in place and does not return any value.\n- Proper use of the pop function is crucial for maintaining the correctness of heap operations and ensuring that the heap property is maintained.\n\n**Output Example**:\nIf the heap is [5, 7, 9, 11, 13] and the pop function is called, the function will remove and return the root element, which is 5. After the pop operation, the heap will be [7, 9, 11, 13]."
      ],
      "code_start_line": 64,
      "code_end_line": 70,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def pop(self):\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()  # Move the last element to the root\n        self._siftdown(0)\n        return root\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [
        "opto\\trace\\utils.py/MinHeap/_siftdown"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "peek",
      "md_content": [
        "**peek**: The function of peek is to return the smallest element in the MinHeap without removing it.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The peek function is a method of the MinHeap class. It checks if the heap list is non-empty. If the heap contains elements, it returns the first element of the heap list, which is the smallest element due to the properties of a MinHeap. If the heap is empty, it returns None. This function allows users to inspect the smallest element in the heap without modifying the heap structure.\n\n**Note**: \n- The peek function does not alter the state of the heap.\n- It is a read-only operation and is useful for checking the minimum element efficiently.\n\n**Output Example**: \n- If the heap is [1, 3, 5, 7], peek() will return 1.\n- If the heap is empty, peek() will return None."
      ],
      "code_start_line": 72,
      "code_end_line": 73,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def peek(self):\n        return self.heap[0] if self.heap else None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_siftup",
      "md_content": [
        "**_siftup**: The function of _siftup is to maintain the heap property by moving an element up the heap until the heap property is restored.\n\n**parameters**: The parameters of this Function.\n· idx: The index of the element to be moved up in the heap.\n\n**Code Description**: The _siftup function is a helper method used to maintain the heap property in a MinHeap data structure. When an element is added to the heap, it may violate the heap property, which requires that each parent node is less than or equal to its child nodes. The _siftup function corrects this by comparing the element at the given index (idx) with its parent. If the element is smaller than its parent, they are swapped. This process continues iteratively until the element is in a position where the heap property is satisfied, or it becomes the root of the heap.\n\nThe function is called by the push method of the MinHeap class. When a new item is added to the heap using the push method, the item is appended to the end of the heap list. The _siftup function is then called with the index of this new item (which is the last index of the list). This ensures that the new item is moved to its correct position in the heap, maintaining the heap property.\n\n**Note**: \n- The _siftup function assumes that the heap property is only violated between the element at the given index and its parent. It does not check or correct violations further up the tree.\n- This function is designed to work with a MinHeap, where the smallest element should always be at the root.\n- The function relies on the gt method of the elements in the heap to compare their values. Ensure that the elements in the heap implement this method correctly."
      ],
      "code_start_line": 75,
      "code_end_line": 83,
      "params": [
        "self",
        "idx"
      ],
      "have_return": false,
      "code_content": "    def _siftup(self, idx):\n        while idx > 0:\n            parent_idx = (idx - 1) // 2\n            # >\n            if self.heap[parent_idx].gt(self.heap[idx]):\n                self.heap[parent_idx], self.heap[idx] = self.heap[idx], self.heap[parent_idx]\n                idx = parent_idx\n            else:\n                break\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\utils.py/MinHeap/push"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_siftdown",
      "md_content": [
        "**_siftdown**: The function of _siftdown is to maintain the heap property by sifting down an element at a given index in the heap.\n\n**parameters**: The parameters of this Function.\n· idx: The index of the element to be sifted down in the heap.\n\n**Code Description**: The _siftdown function is a helper method used to ensure that the heap property is maintained after an element has been moved to a new position in the heap. This function is particularly useful in operations where the heap structure might be violated, such as after removing the root element or during the initial heap construction.\n\nThe function operates as follows:\n1. It calculates the index of the last element in the heap.\n2. It enters a loop where it calculates the indices of the left and right children of the current element.\n3. It initializes the smallest index as the current index.\n4. It compares the current element with its left and right children to find the smallest element among them.\n5. If one of the children is smaller than the current element, it swaps the current element with the smallest child and updates the current index to the index of the smallest child.\n6. The loop continues until the current element is smaller than both of its children or it has no children.\n\nThe function is called by the pop and heapify methods of the MinHeap class:\n- In the pop method, _siftdown is used after the root element is removed and the last element is moved to the root position. This ensures that the new root element is correctly positioned to maintain the heap property.\n- In the heapify method, _siftdown is called for each non-leaf element in the array to transform the array into a valid heap.\n\n**Note**: Points to note about the use of the code\n- The function assumes that the heap is represented as a list and that each element in the heap has a method lt for comparison.\n- The function modifies the heap in place and does not return any value.\n- Proper use of _siftdown is crucial for maintaining the efficiency and correctness of heap operations such as insertion, deletion, and heap construction."
      ],
      "code_start_line": 85,
      "code_end_line": 103,
      "params": [
        "self",
        "idx"
      ],
      "have_return": false,
      "code_content": "    def _siftdown(self, idx):\n        last_idx = len(self.heap) - 1\n        while True:\n            left_child_idx = 2 * idx + 1\n            right_child_idx = 2 * idx + 2\n            smallest_idx = idx\n\n            # if left_child_idx <= last_idx and self.heap[left_child_idx] < self.heap[smallest_idx]:\n            if left_child_idx <= last_idx and self.heap[left_child_idx].lt(self.heap[smallest_idx]):\n                smallest_idx = left_child_idx\n            # if right_child_idx <= last_idx and self.heap[right_child_idx] < self.heap[smallest_idx]:\n            if right_child_idx <= last_idx and self.heap[right_child_idx].lt(self.heap[smallest_idx]):\n                smallest_idx = right_child_idx\n\n            if smallest_idx != idx:\n                self.heap[idx], self.heap[smallest_idx] = self.heap[smallest_idx], self.heap[idx]\n                idx = smallest_idx\n            else:\n                break\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\utils.py/MinHeap/pop",
        "opto\\trace\\utils.py/MinHeap/heapify"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "heapify",
      "md_content": [
        "**heapify**: The function of heapify is to transform an arbitrary array into a valid min-heap.\n\n**parameters**: The parameters of this Function.\n· arr: The array to be transformed into a min-heap.\n\n**Code Description**: The heapify function is designed to convert a given array into a min-heap, ensuring that the heap property is maintained throughout the array. This function is a method of the MinHeap class and operates as follows:\n\n1. The function begins by importing the copy module and creating a shallow copy of the input array `arr` to avoid modifying the original array. This copy is stored in the instance variable `self.heap`.\n2. It then iterates over the indices of the non-leaf elements of the array in reverse order, starting from the last non-leaf node and moving towards the root. The range for this iteration is calculated as `(len(self.heap) - 2) // 2` to `-1`.\n3. For each index `i` in this range, the function calls the helper method `_siftdown(i)`. The _siftdown method is responsible for maintaining the heap property by sifting down the element at index `i` to its correct position in the heap.\n\nThe heapify function is called during the initialization of the MinHeap object if an array is provided. This ensures that any array passed to the MinHeap constructor is automatically transformed into a valid min-heap.\n\n**Note**: Points to note about the use of the code\n- The heapify function assumes that the elements of the array have a method `lt` for comparison, which is used by the _siftdown method.\n- The function modifies the heap in place and does not return any value.\n- Proper use of the heapify function is crucial for initializing the heap correctly, which in turn ensures the efficiency and correctness of subsequent heap operations such as insertion and deletion."
      ],
      "code_start_line": 105,
      "code_end_line": 110,
      "params": [
        "self",
        "arr"
      ],
      "have_return": false,
      "code_content": "    def heapify(self, arr):\n        import copy\n\n        self.heap = copy.copy(arr)\n        for i in range((len(self.heap) - 2) // 2, -1, -1):\n            self._siftdown(i)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\utils.py/MinHeap/__init__"
      ],
      "reference_who": [
        "opto\\trace\\utils.py/MinHeap/_siftdown"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "for_all_methods",
      "md_content": [
        "**for_all_methods**: The function of for_all_methods is to apply a decorator to all methods of a class.\n\n**parameters**:\n- decorator: The decorator function that will be applied to all methods of the class.\n\n**Code Description**:\nThe `for_all_methods` function is a higher-order function that takes a decorator as input and returns a new decorator. The returned decorator can be used to decorate a class, applying the input decorator to all methods of the class.\n\nThe `for_all_methods` function first defines an inner function called `decorate`. This function takes a class as input and iterates over all the attributes of the class using the `__dict__` attribute. For each attribute that is callable (i.e., a method) and does not start with \"__\" (i.e., not a special method), the function applies the input decorator to the method using the `setattr` function. This effectively replaces the original method with the decorated version.\n\nFinally, the `decorate` function returns the modified class with the decorated methods.\n\nThe `for_all_methods` function itself returns the `decorate` function, allowing it to be used as a decorator for classes.\n\n**Note**:\n- The input decorator should be a function that takes a method as input and returns a new method.\n- The input decorator will be applied to all methods of the class, including inherited methods.\n- The input decorator will replace the original methods with the decorated versions.\n\n**Output Example**:\n```python\n@for_all_methods\ndef my_decorator(method):\n    def wrapper(*args, **kwargs):\n        # Do something before calling the method\n        result = method(*args, **kwargs)\n        # Do something after calling the method\n        return result\n    return wrapper\n\n@my_decorator\nclass MyClass:\n    def method1(self):\n        # Method implementation\n\n    def method2(self):\n        # Method implementation\n```\n\nIn the above example, the `my_decorator` function is applied to all methods of the `MyClass` class using the `for_all_methods` decorator. The `my_decorator` function wraps each method, allowing additional functionality to be added before and after the method is called."
      ],
      "code_start_line": 113,
      "code_end_line": 122,
      "params": [
        "decorator"
      ],
      "have_return": true,
      "code_content": "def for_all_methods(decorator):\n    \"\"\"Applying a decorator to all methods of a class.\"\"\"\n\n    def decorate(cls):\n        for name, attr in cls.__dict__.items():\n            if callable(attr) and not name.startswith(\"__\"):\n                setattr(cls, name, decorator(attr))\n        return cls\n\n    return decorate\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests\\unit_tests\\test_bundle.py",
        "tests\\unit_tests\\test_bundle.py/run",
        "tests\\unit_tests\\test_error_handling.py"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "decorate",
      "md_content": [
        "**decorate**: The function of decorate is to apply a decorator to all callable methods of a class, excluding special methods.\n\n**parameters**: The parameters of this Function.\n· cls: The class whose methods will be decorated.\n\n**Code Description**: The decorate function iterates over all attributes of the provided class (cls). For each attribute, it checks if the attribute is callable (i.e., a method) and if its name does not start with double underscores (which would indicate a special method). If both conditions are met, the function applies a decorator to the method using the setattr function, which updates the class with the decorated method. Finally, the function returns the modified class.\n\n**Note**: \n- This function assumes that a decorator function named decorator is already defined and available in the scope where decorate is used.\n- Special methods (those starting with double underscores) are not decorated by this function.\n\n**Output Example**: \nIf you have a class MyClass with methods method1 and method2, after applying the decorate function, both method1 and method2 will be decorated with the decorator function. The class will be returned with these modifications."
      ],
      "code_start_line": 116,
      "code_end_line": 120,
      "params": [
        "cls"
      ],
      "have_return": true,
      "code_content": "    def decorate(cls):\n        for name, attr in cls.__dict__.items():\n            if callable(attr) and not name.startswith(\"__\"):\n                setattr(cls, name, decorator(attr))\n        return cls\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "opto\\trace\\__init__.py": [],
  "opto\\trace\\propagators\\graph_propagator.py": [
    {
      "type": "ClassDef",
      "name": "TraceGraph",
      "md_content": [
        "**TraceGraph**: The function of TraceGraph is to serve as a feedback container used by the GraphPropagator. It represents a subgraph of nodes and stores user feedback.\n\n**attributes**:\n- graph: A list of Node objects representing the priority queue of nodes in the subgraph.\n- user_feedback: Any type of user feedback associated with the TraceGraph.\n\n**Code Description**:\nThe TraceGraph class is a feedback container used by the GraphPropagator. It is designed to store a subgraph of nodes and user feedback. The class includes the following methods:\n\n1. `__add__(self, other)`: This method is used to combine two TraceGraph objects. It checks if either of the user feedbacks is None, and if so, it assigns the non-None user feedback to the resulting TraceGraph. If both user feedbacks are not None, it checks if they are equal and assigns the user feedback to the resulting TraceGraph. The graph is created by merging the two graphs and sorting them based on the priority level. The method returns a new TraceGraph object with the merged graph and user feedback.\n\n**Note**: \n- The TraceGraph class inherits from the AbstractFeedback class, which defines the `__add__` method.\n- The `__add__` method ensures that the user feedback is consistent when combining two TraceGraph objects.\n\n**Output Example**:\n```python\nTraceGraph(graph=[(1, Node('A')), (2, Node('B'))], user_feedback=None)\n```\n\n**Reference Relationship**:\n- The TraceGraph class is called by the `__add__` method in the TraceGraph class itself.\n- The TraceGraph class is utilized in the `node_to_function_feedback` function in the `opto.optimizers.function_optimizer` module.\n- The TraceGraph class is also used in the `init_feedback` method of the GraphPropagator class in the `opto.trace.propagators.graph_propagator` module."
      ],
      "code_start_line": 9,
      "code_end_line": 30,
      "params": [],
      "have_return": true,
      "code_content": "class TraceGraph(AbstractFeedback):  # TODO rename\n    \"\"\"Feedback container used by GraphPropagator.\"\"\"\n\n    graph: List[Node]  # a priority queue of nodes in the subgraph\n    user_feedback: Any\n\n    def __add__(self, other):\n        assert not (\n            self.user_feedback is None and other.user_feedback is None\n        ), \"One of the user feedback should not be None.\"\n        if self.user_feedback is None or other.user_feedback is None:\n            user_feedback = self.user_feedback if other.user_feedback is None else other.user_feedback\n        else:  # both are not None\n            assert self.user_feedback == other.user_feedback, \"user feedback should be the same for all children\"\n            user_feedback = self.user_feedback\n\n        other_names = [n[1].name for n in other.graph]\n        complement = [\n            x for x in self.graph if x[1].name not in other_names\n        ]  # `in` uses __eq__ which checks the value not the identity\n        graph = [x for x in heapq.merge(complement, other.graph, key=lambda x: x[0])]\n        return TraceGraph(graph=graph, user_feedback=user_feedback)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/node_to_function_feedback",
        "opto\\optimizers\\opro.py",
        "opto\\trace\\propagators\\__init__.py",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/init_feedback",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/aggregate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\propagators\\propagators.py/AbstractFeedback"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__add__",
      "md_content": [
        "**__add__**: The function of __add__ is to merge two TraceGraph objects while ensuring consistency in user feedback and combining their graphs.\n\n**parameters**: The parameters of this Function.\n· self: The first instance of the TraceGraph object.\n· other: The second instance of the TraceGraph object to be added to the first.\n\n**Code Description**: The __add__ method begins by asserting that at least one of the user_feedback attributes from the two TraceGraph objects is not None. If both user_feedback attributes are None, an assertion error is raised with the message \"One of the user feedback should not be None.\"\n\nNext, the method determines the user_feedback for the resulting TraceGraph. If one of the user_feedback attributes is None, it uses the non-None user_feedback. If both are not None, it asserts that they are equal, ensuring consistency, and then uses the user_feedback from the first TraceGraph.\n\nThe method then constructs a list of names from the nodes in the other TraceGraph's graph. It creates a complement list by including nodes from the first TraceGraph's graph that do not have names present in the other TraceGraph's graph. This ensures that nodes with the same name are not duplicated.\n\nFinally, the method merges the complement list and the other TraceGraph's graph using heapq.merge, which merges the lists based on the first element of each tuple (assumed to be a key). The merged list is used to create a new TraceGraph object, which is returned with the combined graph and the determined user_feedback.\n\n**Note**: \n- Ensure that at least one of the TraceGraph objects has a non-None user_feedback before using the __add__ method.\n- If both TraceGraph objects have user_feedback, they must be identical to avoid an assertion error.\n\n**Output Example**: \nAssuming TraceGraph objects `tg1` and `tg2` are being added:\n```python\ntg1 + tg2\n```\nThis would return a new TraceGraph object with a combined graph and consistent user_feedback."
      ],
      "code_start_line": 15,
      "code_end_line": 30,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __add__(self, other):\n        assert not (\n            self.user_feedback is None and other.user_feedback is None\n        ), \"One of the user feedback should not be None.\"\n        if self.user_feedback is None or other.user_feedback is None:\n            user_feedback = self.user_feedback if other.user_feedback is None else other.user_feedback\n        else:  # both are not None\n            assert self.user_feedback == other.user_feedback, \"user feedback should be the same for all children\"\n            user_feedback = self.user_feedback\n\n        other_names = [n[1].name for n in other.graph]\n        complement = [\n            x for x in self.graph if x[1].name not in other_names\n        ]  # `in` uses __eq__ which checks the value not the identity\n        graph = [x for x in heapq.merge(complement, other.graph, key=lambda x: x[0])]\n        return TraceGraph(graph=graph, user_feedback=user_feedback)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "GraphPropagator",
      "md_content": [
        "**GraphPropagator**: The GraphPropagator class is a subclass of the Propagator class. It provides specific implementations for the `init_feedback` and `_propagate` methods, as well as an `aggregate` method. The purpose of this class is to collect all the nodes seen in the path and compute the propagated feedback to the parent nodes based on the child node's description, data, and feedback.\n\n**attributes**:\n- None\n\n**Code Description**:\n- The `init_feedback` method takes two parameters: `node` (the current node) and `feedback` (the user feedback). It returns a TraceGraph object that represents the initial feedback for the given node. The TraceGraph object is created using the TraceGraph class and initialized with the current node and the user feedback.\n\n- The `_propagate` method takes a `child` parameter of type `MessageNode` and computes the propagated feedback to the parent nodes based on the child node's description, data, and feedback. It first creates a list of tuples representing the parents of the child node. Each tuple contains the level of the parent node and the parent node itself. Then, it aggregates the feedback from the child node and creates a TraceGraph object using the TraceGraph class. The aggregated feedback is computed by adding the feedback from the child node to a TraceGraph object that represents the parents of the child node. The external dependencies on parameters not visible in the current graph level are also included in the feedback. Finally, the method returns a dictionary where the keys are the parent nodes and the values are the propagated feedback.\n\n- The `aggregate` method takes a `feedback` parameter of type `Dict[Node, List[TraceGraph]]` and aggregates the feedback from multiple children. It first checks that the length of each value in the feedback dictionary is 1 and that each value is an instance of the TraceGraph class. Then, it sums the feedback values and returns the aggregated feedback as a TraceGraph object.\n\n**Note**:\n- The `init_feedback` and `_propagate` methods are specific implementations of abstract methods defined in the Propagator class.\n- The `aggregate` method is a helper method used by the `_propagate` method to aggregate feedback from multiple children.\n\n**Output Example**:\nGiven a properly implemented GraphPropagator object, the return value of the `_propagate` method might look like the following:\n```python\n{\n    parent_node_1: feedback_data_1,\n    parent_node_2: feedback_data_2,\n    # ... other parent nodes and their respective feedback\n}\n```"
      ],
      "code_start_line": 35,
      "code_end_line": 62,
      "params": [],
      "have_return": true,
      "code_content": "class GraphPropagator(Propagator):\n    \"\"\"A propagator that collects all the nodes seen in the path.\"\"\"\n\n    def init_feedback(self, node, feedback: Any):\n        return TraceGraph(graph=[(node.level, node)], user_feedback=feedback)\n\n    def _propagate(self, child: MessageNode):\n        graph = [(p.level, p) for p in child.parents]  # add the parents\n        feedback = self.aggregate(child.feedback) + TraceGraph(graph=graph, user_feedback=None)\n        assert isinstance(feedback, TraceGraph)\n\n        # For including the external dependencies on parameters not visible\n        # in the current graph level\n        for param in child.external_dependencies:\n            assert isinstance(param, ParameterNode)\n            param._add_feedback(child, feedback)\n\n        return {parent: feedback for parent in child.parents}\n\n    def aggregate(self, feedback: Dict[Node, List[TraceGraph]]):\n        \"\"\"Aggregate feedback from multiple children\"\"\"\n        assert all(len(v) == 1 for v in feedback.values())\n        assert all(isinstance(v[0], TraceGraph) for v in feedback.values())\n        values = [sum(v) for v in feedback.values()]\n        if len(values) == 0:\n            return TraceGraph(graph=[], user_feedback=None)\n        else:\n            return sum(values)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/default_propagator",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/_step",
        "opto\\optimizers\\opro.py",
        "opto\\trace\\nodes.py/Node/backward",
        "opto\\trace\\propagators\\__init__.py",
        "tests\\unit_tests\\test_backward.py"
      ],
      "reference_who": [
        "opto\\trace\\propagators\\propagators.py/Propagator"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "init_feedback",
      "md_content": [
        "**init_feedback**: The function of init_feedback is to initialize feedback for a given node in the GraphPropagator.\n\n**parameters**:\n- node: The node for which feedback is being initialized.\n- feedback: The user feedback associated with the node.\n\n**Code Description**:\nThe init_feedback function is a method of the GraphPropagator class in the opto.trace.propagators.graph_propagator module. It is used to initialize feedback for a given node in the graph propagation process. The function takes two parameters: the node for which feedback is being initialized and the user feedback associated with the node.\n\nInside the function, a TraceGraph object is created using the TraceGraph class. The TraceGraph object is initialized with a graph containing a single tuple representing the level of the node and the node itself. The user feedback is also assigned to the TraceGraph object.\n\nThe TraceGraph object is then returned as the output of the init_feedback function.\n\n**Reference Relationship**:\n- The init_feedback function is called by the backward method in the Node class in the opto.trace.nodes module.\n- The init_feedback function is called by the propagate method in the GraphPropagator class in the opto.trace.propagators.graph_propagator module.\n\n**Note**: It is important to ensure that the node and feedback parameters are properly provided when calling the init_feedback function to avoid potential issues.\n\n**Output Example**:\nIf the node parameter is a Node object representing a node with level 2 and the feedback parameter is \"Good job!\", calling the init_feedback function will return a TraceGraph object with the following attributes:\n- graph: [(2, Node)]\n- user_feedback: \"Good job!\""
      ],
      "code_start_line": 38,
      "code_end_line": 39,
      "params": [
        "self",
        "node",
        "feedback"
      ],
      "have_return": true,
      "code_content": "    def init_feedback(self, node, feedback: Any):\n        return TraceGraph(graph=[(node.level, node)], user_feedback=feedback)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/level",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "_propagate",
      "md_content": [
        "**_propagate**: The function of _propagate is to propagate feedback from a child node to its parent nodes in the graph.\n\n**parameters**:\n- self: The current object.\n- child: The child node from which the feedback is propagated.\n\n**Code Description**:\nThe `_propagate` function is a method of the `GraphPropagator` class in the `graph_propagator.py` module. It takes in the current object (`self`) and a child node (`child`) as parameters. The function first creates a list called `graph` by iterating over the parents of the child node and storing them along with their priority level. The priority level is determined by the `level` attribute of each parent node. The `graph` list represents the parents of the child node.\n\nNext, the function aggregates the feedback from the child node by calling the `aggregate` method of the current object (`self`). The `aggregate` method takes in the feedback from multiple children nodes and returns the aggregated feedback as a `TraceGraph` object. The feedback is obtained from the `feedback` attribute of the child node.\n\nThe function then asserts that the aggregated feedback is an instance of the `TraceGraph` class. This ensures that the feedback is in the correct format.\n\nAfter that, the function iterates over the external dependencies of the child node and adds the feedback to each external dependency by calling the `_add_feedback` method of the external dependency node. This ensures that the feedback is correctly propagated to the external dependencies.\n\nFinally, the function returns a dictionary comprehension that maps each parent node to the aggregated feedback.\n\nThe `_propagate` function is an essential part of the graph propagation process in the `GraphPropagator` class. It is responsible for propagating feedback from a child node to its parent nodes, ensuring that the feedback flows correctly through the graph structure.\n\n**Note**: \n- The function assumes that the child node has a `parents` attribute that returns a list of parent nodes.\n- The function assumes that the child node has an `external_dependencies` attribute that returns a set of external dependency nodes.\n- The function assumes that the child node has a `feedback` attribute that contains the feedback from the child node.\n- The function assumes that the feedback can be aggregated using the `aggregate` method.\n- The function assumes that the external dependencies have a `_add_feedback` method to add the feedback from the child node.\n- The function returns a dictionary that maps each parent node to the aggregated feedback.\n\n**Output Example**: \nIf the child node has two parents, the `_propagate` function will return a dictionary with two key-value pairs, where each key represents a parent node and the corresponding value represents the aggregated feedback from the child node.\n```python\n{\n    parent_node1: aggregated_feedback1,\n    parent_node2: aggregated_feedback2\n}\n```"
      ],
      "code_start_line": 41,
      "code_end_line": 52,
      "params": [
        "self",
        "child"
      ],
      "have_return": true,
      "code_content": "    def _propagate(self, child: MessageNode):\n        graph = [(p.level, p) for p in child.parents]  # add the parents\n        feedback = self.aggregate(child.feedback) + TraceGraph(graph=graph, user_feedback=None)\n        assert isinstance(feedback, TraceGraph)\n\n        # For including the external dependencies on parameters not visible\n        # in the current graph level\n        for param in child.external_dependencies:\n            assert isinstance(param, ParameterNode)\n            param._add_feedback(child, feedback)\n\n        return {parent: feedback for parent in child.parents}\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/parents",
        "opto\\trace\\nodes.py/Node/feedback",
        "opto\\trace\\nodes.py/ParameterNode",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\nodes.py/MessageNode/external_dependencies",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/aggregate"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        true,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "aggregate",
      "md_content": [
        "**aggregate**: The function of aggregate is to aggregate feedback from multiple children.\n\n**Parameters**:\n- feedback: A dictionary that maps a Node to a list of TraceGraph objects representing the feedback from the child nodes.\n\n**Code Description**:\nThe `aggregate` function takes in a dictionary of feedback from multiple children. It first checks that each child has provided exactly one feedback and that the feedback is of type TraceGraph. Then, it calculates the sum of the feedback values for each child and stores them in a list called `values`. If the length of `values` is zero, indicating that there is no feedback, it returns a TraceGraph object with an empty graph and a user_feedback attribute set to None. Otherwise, it returns the sum of the values.\n\nThis function is used to aggregate the feedback received from multiple children nodes. It ensures that the feedback is valid and performs the aggregation by summing the feedback values. The resulting aggregated feedback is returned as a TraceGraph object.\n\n**Reference Relationship**:\n- This function is called by the `summarize` method in the `FunctionOptimizer` class in the `opto.optimizers.function_optimizer` module.\n- This function is also called by the `_propagate` method in the `GraphPropagator` class in the `opto.trace.propagators.graph_propagator` module.\n\n**Note**:\n- The feedback dictionary should contain exactly one feedback value for each child node.\n- The feedback values should be of type TraceGraph.\n- The function assumes that the feedback values can be summed.\n- If there is no feedback, an empty TraceGraph object is returned.\n- The function does not modify the input feedback dictionary.\n\n**Output Example**:\n```python\nTraceGraph(graph=[(1, Node('A')), (2, Node('B'))], user_feedback=None)\n```"
      ],
      "code_start_line": 54,
      "code_end_line": 62,
      "params": [
        "self",
        "feedback"
      ],
      "have_return": true,
      "code_content": "    def aggregate(self, feedback: Dict[Node, List[TraceGraph]]):\n        \"\"\"Aggregate feedback from multiple children\"\"\"\n        assert all(len(v) == 1 for v in feedback.values())\n        assert all(isinstance(v[0], TraceGraph) for v in feedback.values())\n        values = [sum(v) for v in feedback.values()]\n        if len(values) == 0:\n            return TraceGraph(graph=[], user_feedback=None)\n        else:\n            return sum(values)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/summarize",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator/_propagate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph"
      ],
      "special_reference_type": [
        true,
        true
      ]
    }
  ],
  "opto\\trace\\propagators\\propagators.py": [
    {
      "type": "ClassDef",
      "name": "AbstractPropagator",
      "md_content": [
        "**AbstractPropagator**: The function of AbstractPropagator is to serve as a base class for propagating feedback from a child node to its parent nodes in a hierarchical structure.\n\n**attributes**: The attributes of this Class.\n· This class does not define any attributes directly.\n\n**Code Description**: The AbstractPropagator class is designed to facilitate the propagation of feedback from a child node to its parent nodes. It provides a structured way to ensure that feedback is correctly propagated and formatted.\n\n- The `__call__` method is the primary interface for propagating feedback. When this method is called with a `MessageNode` instance as the `child` parameter, it performs several checks and operations:\n  - It asserts that the `child` is an instance of `MessageNode`.\n  - It ensures that all feedback values in the `child` node have a length of at most 1.\n  - It calls the `propagate` method to compute the propagated feedback.\n  - It verifies that the propagated feedback is a dictionary where the keys are the parent nodes and the values are the feedback.\n  - Finally, it returns the propagated feedback.\n\n- The `propagate` method is an abstract method that must be implemented by subclasses. It is responsible for computing the propagated feedback to the parent nodes of the given `child` node. The method should return a dictionary where the keys are the parent nodes and the values are the propagated feedback. Since this method is not implemented in the AbstractPropagator class, it raises a `NotImplementedError`.\n\nThe AbstractPropagator class is extended by the `Propagator` class, which provides specific implementations for the `propagate` method and additional functionalities such as registering custom propagation functions and initializing feedback.\n\n**Note**: \n- The `propagate` method must be implemented in any subclass of AbstractPropagator.\n- The `__call__` method ensures that the feedback is correctly formatted and propagated, making it a critical part of the feedback propagation process.\n\n**Output Example**: \nGiven a properly implemented subclass of AbstractPropagator, the return value of the `__call__` method might look like the following:\n```python\n{\n    parent_node_1: feedback_data_1,\n    parent_node_2: feedback_data_2,\n    # ... other parent nodes and their respective feedback\n}\n```\nThis dictionary maps parent nodes to their respective propagated feedback."
      ],
      "code_start_line": 5,
      "code_end_line": 25,
      "params": [],
      "have_return": true,
      "code_content": "class AbstractPropagator:\n    def __call__(self, child: MessageNode):\n        \"\"\"Calling this method would propagte the feedback from the child to the parents.\"\"\"\n        assert isinstance(child, MessageNode)\n        assert all(\n            [len(f) <= 1 for f in child.feedback.values()]\n        )  # All MessageNode feedback should be at most length 1\n        # TODO maybe just pass node\n        propagated_feedback = self.propagate(child)\n        # Check propagated feedback has the right format\n        # It should be a dictionary with the parents as keys and the feedback as values\n        assert isinstance(propagated_feedback, dict)\n        assert all((p in propagated_feedback for p in child.parents))\n        return propagated_feedback\n\n    def propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        \"\"\"Compute propagated feedback to node.parents of a node. Return a dict where\n        the keys are the parents and the values are the\n        propagated feedback.\n        \"\"\"\n        raise NotImplementedError\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\propagators.py/Propagator"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__call__",
      "md_content": [
        "**__call__**: The function of __call__ is to propagate the feedback from a child node to its parents.\n**parameters**:\n- child: A MessageNode object representing the child node for which the feedback needs to be propagated.\n\n**Code Description**:\nThe `__call__` function is a method of the `AbstractPropagator` class defined in the `propagators.py` module. It is responsible for propagating the feedback from a child node to its parents. The function takes a `child` parameter, which is expected to be a `MessageNode` object.\n\nThe function first checks if the `child` is an instance of `MessageNode` and if the feedback from the child is of the correct format. The feedback should be a dictionary with the parents of the child as keys and the feedback values as values.\n\nNext, the function calls the `propagate` method of the concrete propagator class that inherits from `AbstractPropagator`. This method is expected to be implemented in the concrete propagator class and should perform the actual propagation of feedback. The `propagate` method returns the propagated feedback as a dictionary.\n\nThe function then checks if the propagated feedback has the correct format, ensuring that it is a dictionary and that all the parents of the child are present as keys in the dictionary.\n\nFinally, the function returns the propagated feedback.\n\n**Note**:\n- The `__call__` function is expected to be implemented in a concrete propagator class that inherits from `AbstractPropagator`.\n- The `__call__` function assumes that the feedback from the child is already computed and stored in the `feedback` attribute of the child node.\n- The function raises an error if the child is not an instance of `MessageNode` or if the feedback from the child is not of the correct format.\n\n**Output Example**: A possible appearance of the code's return value could be:\n```\n{\n    parent_node_1: feedback_value_1,\n    parent_node_2: feedback_value_2,\n    ...\n}\n```\nThis example assumes that the propagated feedback is a dictionary with the parent nodes as keys and the corresponding feedback values as values. The actual content of the feedback will depend on the specific implementation and use case within the project."
      ],
      "code_start_line": 6,
      "code_end_line": 18,
      "params": [
        "self",
        "child"
      ],
      "have_return": true,
      "code_content": "    def __call__(self, child: MessageNode):\n        \"\"\"Calling this method would propagte the feedback from the child to the parents.\"\"\"\n        assert isinstance(child, MessageNode)\n        assert all(\n            [len(f) <= 1 for f in child.feedback.values()]\n        )  # All MessageNode feedback should be at most length 1\n        # TODO maybe just pass node\n        propagated_feedback = self.propagate(child)\n        # Check propagated feedback has the right format\n        # It should be a dictionary with the parents as keys and the feedback as values\n        assert isinstance(propagated_feedback, dict)\n        assert all((p in propagated_feedback for p in child.parents))\n        return propagated_feedback\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/parents",
        "opto\\trace\\nodes.py/Node/feedback",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/propagate"
      ],
      "special_reference_type": [
        false,
        false,
        true,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "propagate",
      "md_content": [
        "**propagate**: The function of propagate is to compute and return the propagated feedback to the parents of a given node. It returns a dictionary where the keys are the parents and the values are the propagated feedback.\n\n**parameters**:\n- child: A MessageNode object representing the child node for which the feedback needs to be propagated.\n\n**Code Description**:\nThe `propagate` function is a method of the `AbstractPropagator` class defined in the `propagators.py` module. It is responsible for propagating the feedback from a child node to its parents. The function takes a `child` parameter, which is expected to be a `MessageNode` object.\n\nThe function first checks if the `child` is an instance of `MessageNode` and if the feedback from the child is of the correct format. The feedback should be a dictionary with the parents of the child as keys and the feedback values as values.\n\nNext, the function calls the `propagate` method of the concrete propagator class that inherits from `AbstractPropagator`. This method is expected to be implemented in the concrete propagator class and should perform the actual propagation of feedback. The `propagate` method returns the propagated feedback as a dictionary.\n\nThe function then checks if the propagated feedback has the correct format, ensuring that it is a dictionary and that all the parents of the child are present as keys in the dictionary.\n\nFinally, the function returns the propagated feedback.\n\n**Note**:\n- The `propagate` function is expected to be implemented in a concrete propagator class that inherits from `AbstractPropagator`.\n- The `propagate` function assumes that the feedback from the child is already computed and stored in the `feedback` attribute of the child node.\n- The function raises an error if the child is not an instance of `MessageNode` or if the feedback from the child is not of the correct format."
      ],
      "code_start_line": 20,
      "code_end_line": 25,
      "params": [
        "self",
        "child"
      ],
      "have_return": false,
      "code_content": "    def propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        \"\"\"Compute propagated feedback to node.parents of a node. Return a dict where\n        the keys are the parents and the values are the\n        propagated feedback.\n        \"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator/__call__"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/MessageNode"
      ],
      "special_reference_type": [
        true,
        true
      ]
    },
    {
      "type": "ClassDef",
      "name": "AbstractFeedback",
      "md_content": [
        "**AbstractFeedback**: The function of AbstractFeedback is to serve as a feedback container used by propagators, supporting addition operations.\n\n**attributes**: This class does not define any attributes.\n\n**Code Description**: \nThe AbstractFeedback class is designed to act as a base class for feedback containers used by propagators. It defines the necessary interface for feedback objects that need to support addition operations. The class includes two methods:\n\n1. `__add__(self, other)`: This method is intended to handle the addition of two feedback objects. However, it raises a NotImplementedError, indicating that any subclass must implement this method to define the specific addition behavior.\n\n2. `__radd__(self, other)`: This method supports the addition operation when the AbstractFeedback object is on the right-hand side of the addition. It checks if the other operand is zero, which is useful for operations like sum where the initial value is zero. If the other operand is zero, it returns the current object (self). Otherwise, it delegates the addition operation to the `__add__` method.\n\nThe AbstractFeedback class is utilized in the TraceGraph class, which inherits from AbstractFeedback. The TraceGraph class provides a concrete implementation of the `__add__` method, ensuring that feedback objects can be combined according to specific rules defined within TraceGraph. This relationship indicates that AbstractFeedback serves as a foundational component for more specialized feedback containers like TraceGraph.\n\n**Note**: \n- Any subclass of AbstractFeedback must implement the `__add__` method to define how feedback objects should be combined.\n- The `__radd__` method facilitates the use of AbstractFeedback objects in operations like sum, where the initial value might be zero.\n\n**Output Example**: \nSince AbstractFeedback is an abstract class and does not implement the `__add__` method, it does not produce any direct output. However, a subclass like TraceGraph would produce combined feedback objects when the `__add__` method is called. For example, combining two TraceGraph objects might result in a new TraceGraph object with a merged graph and user feedback."
      ],
      "code_start_line": 28,
      "code_end_line": 38,
      "params": [],
      "have_return": true,
      "code_content": "class AbstractFeedback:\n    \"\"\"Feedback container used by propagators. It needs to support addition.\"\"\"\n\n    def __add__(self, other):\n        raise NotImplementedError\n\n    def __radd__(self, other):\n        if other == 0:  # for support sum\n            return self\n        else:\n            return self.__add__(other)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\graph_propagator.py",
        "opto\\trace\\propagators\\graph_propagator.py/TraceGraph"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__add__",
      "md_content": [
        "**__add__**: The function of __add__ is to define the addition operation for instances of the class.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the class on which the method is called.\n· other: The instance or value to be added to the instance represented by self.\n\n**Code Description**: The __add__ method is intended to define the behavior of the addition operation for instances of the class it belongs to. However, in its current implementation, it raises a NotImplementedError, indicating that the addition operation is not yet implemented for this class. This method is crucial for enabling the use of the '+' operator with instances of the class.\n\nThe __add__ method is also indirectly called by the __radd__ method within the same class. The __radd__ method is designed to handle the addition operation when the instance appears on the right-hand side of the '+' operator. If the other operand is zero, __radd__ returns the instance itself, supporting the use of the sum function. Otherwise, it delegates the addition operation to the __add__ method.\n\n**Note**: \n- The __add__ method currently raises a NotImplementedError, so attempting to use the '+' operator with instances of this class will result in an error.\n- To enable addition, the __add__ method needs to be properly implemented.\n- The __radd__ method relies on __add__ for non-zero operands, so both methods should be considered together when implementing addition functionality."
      ],
      "code_start_line": 31,
      "code_end_line": 32,
      "params": [
        "self",
        "other"
      ],
      "have_return": false,
      "code_content": "    def __add__(self, other):\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\propagators.py/AbstractFeedback/__radd__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__radd__",
      "md_content": [
        "**__radd__**: The function of __radd__ is to handle the addition operation when the instance appears on the right-hand side of the '+' operator.\n\n**parameters**: The parameters of this Function.\n· self: The instance of the class on which the method is called.\n· other: The instance or value to be added to the instance represented by self.\n\n**Code Description**: The __radd__ method is designed to support the addition operation when the instance of the class appears on the right-hand side of the '+' operator. This method is particularly useful for enabling the use of the sum function with instances of the class. When the other operand is zero, __radd__ returns the instance itself, ensuring that the sum function can correctly handle the initial zero value. If the other operand is not zero, the method delegates the addition operation to the __add__ method of the class.\n\nThe __add__ method, which is called by __radd__ for non-zero operands, is intended to define the behavior of the addition operation for instances of the class. However, in its current implementation, __add__ raises a NotImplementedError, indicating that the addition operation is not yet implemented for this class. Therefore, to fully enable addition functionality, the __add__ method needs to be properly implemented.\n\n**Note**: \n- The __add__ method currently raises a NotImplementedError, so attempting to use the '+' operator with instances of this class will result in an error.\n- The __radd__ method relies on __add__ for non-zero operands, so both methods should be considered together when implementing addition functionality.\n\n**Output Example**: \n- If `other` is 0, the method returns the instance itself.\n- If `other` is not 0, the method attempts to return the result of `self.__add__(other)`, which currently raises a NotImplementedError."
      ],
      "code_start_line": 34,
      "code_end_line": 38,
      "params": [
        "self",
        "other"
      ],
      "have_return": true,
      "code_content": "    def __radd__(self, other):\n        if other == 0:  # for support sum\n            return self\n        else:\n            return self.__add__(other)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\propagators\\propagators.py/AbstractFeedback/__add__"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Propagator",
      "md_content": [
        "**Propagator**: The function of Propagator is to propagate feedback from a child node to its parent nodes based on the provided rules and functions.\n\n**attributes**: The attributes of this Class.\n- `override`: A dictionary that stores the override propagate functions for specific operator names.\n\n**Code Description**: The Propagator class is a subclass of the AbstractPropagator class. It provides specific implementations for the `propagate` and `_propagate` methods, as well as additional functionalities such as registering custom propagation functions and initializing feedback.\n\n- The `register` method allows users to register a custom propagate function for a specific operator name. It takes two parameters: `operator_name` (the name of the operator) and `propagate_function` (the custom propagate function). It adds the `operator_name` and `propagate_function` to the `override` dictionary.\n\n- The `propagate` method is responsible for computing the propagated feedback to the parent nodes of the given `child` node. It takes a `child` parameter of type `MessageNode` and returns a dictionary where the keys are the parent nodes and the values are the propagated feedback. It first retrieves the operator name from the `child` node using the `get_op_name` function. If the operator name is found in the `override` dictionary, it calls the corresponding propagate function with the `child` node as the argument. Otherwise, it calls the `_propagate` method to compute the propagated feedback.\n\n- The `init_feedback` method is an abstract method that must be implemented by subclasses. It takes a `feedback` parameter and returns the initialized feedback object that will be propagated recursively. Since this method is not implemented in the Propagator class, it raises a `NotImplementedError` if called.\n\n- The `_propagate` method is a protected method that computes the propagated feedback to the parent nodes based on the `child` node's description, data, and feedback. It takes a `child` parameter of type `MessageNode` and returns a dictionary where the keys are the parent nodes and the values are the propagated feedback. It first creates a list of tuples representing the parents of the `child` node. Then, it aggregates the feedback from the `child` node and creates a `TraceGraph` object. It also adds the external dependencies on parameters not visible in the current graph level. Finally, it returns a dictionary where the keys are the parent nodes and the values are the propagated feedback.\n\n**Note**: \n- The `propagate` method must be implemented in any subclass of Propagator.\n- The `init_feedback` and `_propagate` methods are abstract methods and must be implemented in subclasses.\n- The `register` method allows users to register custom propagate functions for specific operator names, providing flexibility in the feedback propagation process.\n\n**Output Example**: \nGiven a properly implemented subclass of Propagator, the return value of the `propagate` method might look like the following:\n```python\n{\n    parent_node_1: feedback_data_1,\n    parent_node_2: feedback_data_2,\n    # ... other parent nodes and their respective feedback\n}\n```\nThis dictionary maps parent nodes to their respective propagated feedback."
      ],
      "code_start_line": 40,
      "code_end_line": 67,
      "params": [],
      "have_return": true,
      "code_content": "class Propagator(AbstractPropagator):\n    def __init__(self):\n        self.override = dict()  # key: operator name: data: override propagate function\n\n    def register(self, operator_name, propagate_function):\n        self.override[operator_name] = propagate_function\n\n    def propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        operator_name = get_op_name(child.description)\n        if operator_name in self.override:\n            return self.override[operator_name](child)\n        else:\n            return self._propagate(child)\n\n    def init_feedback(self, feedback: Any):\n        \"\"\"\n        Given raw feedback, create the feedback object that will be propagated recursively.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def _propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        \"\"\"Compute propagated feedback to node.parents based on\n        node.description, node.data, and node.feedback. Return a dict where\n        the keys are the parents and the values are the\n        propagated feedback.\n        \"\"\"\n        raise NotImplementedError\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\optimizers\\function_optimizer.py",
        "opto\\optimizers\\function_optimizer.py/FunctionOptimizer/__init__",
        "opto\\optimizers\\opro.py",
        "opto\\optimizers\\optimizers.py",
        "opto\\optimizers\\optimizers.py/Optimizer/__init__",
        "opto\\trace\\propagators\\graph_propagator.py",
        "opto\\trace\\propagators\\graph_propagator.py/GraphPropagator",
        "opto\\trace\\propagators\\propagators.py/SumPropagator"
      ],
      "reference_who": [
        "opto\\trace\\propagators\\propagators.py/AbstractPropagator"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the Propagator class.\n\n**parameters**: The parameters of this Function.\n· This function does not take any parameters.\n\n**Code Description**: The __init__ function is a constructor method for the Propagator class. When an instance of the Propagator class is created, this method is automatically called to set up the initial state of the object. Specifically, it initializes an instance variable named `override` as an empty dictionary. This dictionary is intended to store override propagation functions, where the keys are operator names and the values are the corresponding override functions. This setup allows for flexible and dynamic modification of propagation behavior based on specific operators.\n\n**Note**: \n- The `override` dictionary is initially empty and can be populated later with operator names and their corresponding override functions.\n- This method does not require any arguments and does not return any values.\n- Proper management of the `override` dictionary is essential for ensuring the correct propagation behavior in the Propagator class."
      ],
      "code_start_line": 41,
      "code_end_line": 42,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        self.override = dict()  # key: operator name: data: override propagate function\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "register",
      "md_content": [
        "**register**: The function of register is to associate a given operator name with a specific propagation function.\n\n**parameters**: The parameters of this Function.\n· operator_name: The name of the operator to be registered.\n· propagate_function: The function that defines how the operator should propagate.\n\n**Code Description**: The register function is a method designed to add or override an entry in the `override` dictionary of the Propagator class. When called, it takes two arguments: `operator_name` and `propagate_function`. The `operator_name` is a string that identifies the operator, and `propagate_function` is a callable that defines the behavior of the operator during propagation. The method assigns the `propagate_function` to the `operator_name` key in the `override` dictionary, effectively registering or updating the propagation behavior for that operator.\n\n**Note**: \n- Ensure that `operator_name` is unique within the context of the `override` dictionary to avoid unintentional overwrites.\n- The `propagate_function` should be a valid callable that adheres to the expected signature and behavior required by the Propagator class."
      ],
      "code_start_line": 44,
      "code_end_line": 45,
      "params": [
        "self",
        "operator_name",
        "propagate_function"
      ],
      "have_return": false,
      "code_content": "    def register(self, operator_name, propagate_function):\n        self.override[operator_name] = propagate_function\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "propagate",
      "md_content": [
        "**propagate**: The function of propagate is to compute and return the propagated feedback to the parents of a given MessageNode based on the node's description, data, and feedback.\n\n**parameters**:\n- child: A MessageNode object representing the child node for which the feedback needs to be propagated.\n\n**Code Description**:\nThe `propagate` function is a method of the `Propagator` class. It takes a child `MessageNode` as input and computes the propagated feedback to its parents. The function first checks if there is an override function defined for the operator associated with the child's description. If an override function is defined, it is called to compute the propagated feedback. Otherwise, the default `_propagate` function is called.\n\nThe purpose of the `propagate` function is to compute the propagated feedback from a child `MessageNode` to its parents. The feedback is computed based on the child's description, data, and feedback. The function returns a dictionary where the keys are the parents of the child and the values are the propagated feedback.\n\nThe `propagate` function provides a way to customize the propagation behavior for different types of operators. By defining an override function for a specific operator, developers can specify how the feedback should be propagated for that operator. This allows for flexibility and customization in the propagation process.\n\nIt is important to note that the `propagate` function relies on the `_propagate` function, which is a placeholder and needs to be implemented in a subclass of the `Propagator` class. The implementation of the `_propagate` function will depend on the specific requirements of the operator being propagated. The `_propagate` function raises a `NotImplementedError` to indicate that it needs to be implemented.\n\nThe `propagate` function is called by other parts of the project to propagate feedback from child nodes to parent nodes. It is an essential component of the graph propagation process and plays a crucial role in updating the values of parent nodes based on the feedback received from their child nodes.\n\n**Note**:\n- The `_propagate` function is a placeholder and needs to be implemented in a subclass of the `Propagator` class.\n- The `propagate` function provides a way to customize the propagation behavior for different types of operators.\n- The implementation of the `_propagate` function will depend on the specific requirements of the operator being propagated.\n- The `propagate` function is an essential component of the graph propagation process and plays a crucial role in updating the values of parent nodes based on the feedback received from their child nodes.\n\n**Output Example**:\nIf the `propagate` function is called with a child `MessageNode` object and the feedback is successfully propagated to its parents, the function will return a dictionary where the keys are the parent nodes and the values are the propagated feedback."
      ],
      "code_start_line": 47,
      "code_end_line": 52,
      "params": [
        "self",
        "child"
      ],
      "have_return": true,
      "code_content": "    def propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        operator_name = get_op_name(child.description)\n        if operator_name in self.override:\n            return self.override[operator_name](child)\n        else:\n            return self._propagate(child)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/get_op_name",
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/Node/description",
        "opto\\trace\\nodes.py/MessageNode",
        "opto\\trace\\propagators\\propagators.py/Propagator/_propagate"
      ],
      "special_reference_type": [
        false,
        true,
        false,
        true,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "init_feedback",
      "md_content": [
        "**init_feedback**: The function of init_feedback is to create a feedback object from raw feedback that will be propagated recursively.\n\n**parameters**: The parameters of this Function.\n· feedback: Raw feedback of any type that needs to be processed into a feedback object.\n\n**Code Description**: The init_feedback function is designed to take raw feedback as input and transform it into a feedback object that can be propagated recursively through a system. This function is essential for initializing the feedback mechanism in a propagation process. The function is currently not implemented and raises a NotImplementedError, indicating that it is intended to be overridden in a subclass or implemented later.\n\nIn the context of its usage within the project, init_feedback is called by the backward method of the Node class in opto\\trace\\nodes.py. The backward method is responsible for performing a backward pass through a graph of nodes, propagating feedback from child nodes to parent nodes. During this process, init_feedback is used to initialize the feedback for the current node before it is propagated to its parents. This ensures that the feedback is in the correct format and ready for recursive propagation.\n\n**Note**: \n- The init_feedback function must be implemented before it can be used effectively. \n- It is crucial to ensure that the feedback object created by this function is compatible with the propagation mechanism used in the backward method.\n- Proper implementation of this function is necessary to avoid runtime errors and ensure the correct functioning of the feedback propagation process."
      ],
      "code_start_line": 54,
      "code_end_line": 59,
      "params": [
        "self",
        "feedback"
      ],
      "have_return": false,
      "code_content": "    def init_feedback(self, feedback: Any):\n        \"\"\"\n        Given raw feedback, create the feedback object that will be propagated recursively.\n\n        \"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\nodes.py/Node/backward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_propagate",
      "md_content": [
        "**_propagate**: The function of _propagate is to compute and return the propagated feedback to the parents of a given MessageNode based on the node's description, data, and feedback.\n\n**parameters**:\n- self: The instance of the Propagator class.\n- child: The MessageNode for which the feedback needs to be propagated.\n\n**Code Description**:\nThe _propagate function is a method of the Propagator class. It takes a child MessageNode as input and computes the propagated feedback to its parents. The function first checks if there is an override function defined for the operator associated with the child's description. If an override function is defined, it is called to compute the propagated feedback. Otherwise, the default _propagate function is called.\n\nThe _propagate function raises a NotImplementedError, indicating that it needs to be implemented in a subclass of the Propagator class. This allows for customization of the propagation behavior for different types of operators.\n\nThe purpose of the _propagate function is to compute the propagated feedback from a child MessageNode to its parents. The feedback is computed based on the child's description, data, and feedback. The function returns a dictionary where the keys are the parents of the child and the values are the propagated feedback.\n\nIt is important to note that the _propagate function is a placeholder and needs to be implemented in a subclass of the Propagator class. The implementation of this function will depend on the specific requirements of the operator being propagated.\n\n**Note**:\n- The _propagate function is a placeholder and needs to be implemented in a subclass of the Propagator class.\n- The function raises a NotImplementedError to indicate that it needs to be implemented.\n- The implementation of the _propagate function will depend on the specific requirements of the operator being propagated."
      ],
      "code_start_line": 61,
      "code_end_line": 67,
      "params": [
        "self",
        "child"
      ],
      "have_return": false,
      "code_content": "    def _propagate(self, child: MessageNode) -> Dict[Node, Any]:\n        \"\"\"Compute propagated feedback to node.parents based on\n        node.description, node.data, and node.feedback. Return a dict where\n        the keys are the parents and the values are the\n        propagated feedback.\n        \"\"\"\n        raise NotImplementedError\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\propagators.py/Propagator/propagate"
      ],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/MessageNode"
      ],
      "special_reference_type": [
        true,
        true
      ]
    },
    {
      "type": "ClassDef",
      "name": "SumPropagator",
      "md_content": [
        "**SumPropagator**: The function of SumPropagator is to propagate feedback from a child node to its parent nodes by summing the feedback values.\n\n**attributes**: The attributes of this Class.\n- This class does not define any additional attributes beyond those inherited from the Propagator class.\n\n**Code Description**: The SumPropagator class is a subclass of the Propagator class. It provides specific implementations for the `init_feedback` and `_propagate` methods, which are abstract methods in the Propagator class.\n\n- The `init_feedback` method takes a `feedback` parameter of any type and returns it as-is. This method is used to initialize the feedback object that will be propagated recursively.\n\n- The `_propagate` method is responsible for computing the propagated feedback to the parent nodes of the given `child` node. It takes a `child` parameter of type `MessageNode` and returns a dictionary where the keys are the parent nodes and the values are the propagated feedback.\n\n  - If the `child` node's feedback contains a \"user\" key, it asserts that the \"user\" feedback is the only feedback and that it contains exactly one item. It then extracts this feedback item.\n  \n  - If the \"user\" key is not present, it sums the feedback values from all keys in the `child` node's feedback. It asserts that the feedback list is not empty and that all feedback items are of the same type. If the feedback items are strings, it concatenates them; otherwise, it sums them numerically.\n  \n  - Finally, it returns a dictionary where each parent node of the `child` node is mapped to the computed feedback.\n\nThe SumPropagator class is used within the context of the opto.trace.propagators module, which deals with propagating feedback in a hierarchical structure of nodes. It overrides the abstract methods of the Propagator class to provide a specific feedback propagation mechanism based on summing feedback values.\n\n**Note**: \n- The `init_feedback` method in SumPropagator simply returns the input feedback without any modifications.\n- The `_propagate` method ensures that feedback values are either concatenated (if they are strings) or summed (if they are numeric), and it performs type checks to ensure consistency.\n\n**Output Example**: \nGiven a `child` node with feedback and parent nodes, the return value of the `_propagate` method might look like the following:\n```python\n{\n    parent_node_1: summed_feedback,\n    parent_node_2: summed_feedback,\n    # ... other parent nodes and their respective feedback\n}\n```\nThis dictionary maps parent nodes to their respective propagated feedback, which is the sum of the feedback values from the `child` node."
      ],
      "code_start_line": 75,
      "code_end_line": 93,
      "params": [],
      "have_return": true,
      "code_content": "class SumPropagator(Propagator):\n    def init_feedback(self, feedback: Any):\n        return feedback\n\n    def _propagate(self, child: MessageNode):\n        if \"user\" in child.feedback:\n            assert len(child.feedback) == 1, \"user feedback should be the only feedback\"\n            assert len(child.feedback[\"user\"]) == 1\n            feedback = child.feedback[\"user\"][0]\n        else:\n            # Simply sum the feedback\n            feedback_list = [v[0] for k, v in child.feedback.items()]\n            assert len(feedback_list) > 0\n            assert all([type(feedback_list[0]) == type(f) for f in feedback_list]), \"error in propagate\"\n            if isinstance(feedback_list[0], str):\n                feedback = \"\".join(feedback_list)\n            else:\n                feedback = sum(feedback_list)\n        return {parent: feedback for parent in child.parents}\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "opto\\trace\\propagators\\__init__.py"
      ],
      "reference_who": [
        "opto\\trace\\propagators\\propagators.py/Propagator"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "init_feedback",
      "md_content": [
        "**init_feedback**: The function of init_feedback is to initialize and return the provided feedback.\n\n**parameters**: The parameters of this Function.\n· feedback: Any type of input that represents the feedback to be initialized.\n\n**Code Description**: The init_feedback function is designed to take a single parameter, feedback, which can be of any type. The function simply returns the feedback parameter as it is. This implies that the function's primary purpose is to serve as a placeholder or a pass-through for the feedback data, potentially for further processing or storage within the context of the SumPropagator class.\n\n**Note**: \n- The function does not perform any validation or transformation on the feedback parameter.\n- Ensure that the feedback parameter is provided in the expected format and type as required by the broader application context.\n\n**Output Example**: \nIf the feedback parameter is provided as a string \"Positive feedback\", the function will return \"Positive feedback\".\nIf the feedback parameter is provided as a dictionary {\"score\": 10, \"comment\": \"Excellent\"}, the function will return {\"score\": 10, \"comment\": \"Excellent\"}."
      ],
      "code_start_line": 76,
      "code_end_line": 77,
      "params": [
        "self",
        "feedback"
      ],
      "have_return": true,
      "code_content": "    def init_feedback(self, feedback: Any):\n        return feedback\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "_propagate",
      "md_content": [
        "**_propagate**: The function of _propagate is to calculate the feedback value for a given child node and propagate it to its parent nodes.\n**parameters**:\n- self: The current object.\n- child: The child node for which the feedback needs to be propagated.\n**Code Description**:\nThe `_propagate` function is a method of the `SumPropagator` class in the `propagators.py` module. It takes two parameters, `self` and `child`, where `self` refers to the current `SumPropagator` object and `child` is the child node for which the feedback needs to be propagated.\n\nThe function first checks if the child node has a feedback entry for the \"user\" key. If it does, it assumes that the user feedback is the only feedback and assigns it to the `feedback` variable. Otherwise, it sums up the feedback values from all the keys in the `child.feedback` dictionary and assigns it to the `feedback_list` variable.\n\nNext, the function performs some assertions to ensure the validity of the feedback data. It checks if the `feedback_list` has at least one element and if all the elements in the list have the same type. If the elements are of type string, it concatenates them using the `\"\".join()` method and assigns the result to the `feedback` variable. Otherwise, it calculates the sum of the elements using the `sum()` function and assigns it to the `feedback` variable.\n\nFinally, the function creates a dictionary comprehension to map each parent node of the child node to the calculated feedback value. The parent nodes are obtained by calling the `parents()` function of the child node.\n\nThe `_propagate` function is an important part of the feedback propagation process in the graph structure. It ensures that the feedback from a child node is correctly calculated and propagated to its parent nodes. This is crucial for updating the parameters and optimizing the graph based on the feedback received.\n\n**Note**: The `_propagate` function assumes that the feedback data is stored in the `child.feedback` dictionary, where the keys represent different sources of feedback and the values represent the corresponding feedback values. The function handles two scenarios: when there is only user feedback available and when there are multiple feedback sources that need to be summed up. It is important to ensure that the feedback data is correctly formatted and consistent with the expectations of the function.\n\n**Output Example**: A possible appearance of the code's return value could be:\n```\n{\n    parent_node_1: feedback_value_1,\n    parent_node_2: feedback_value_2,\n    ...\n}\n```\nThis example assumes that the `child.parents` attribute contains a list of parent nodes and the `feedback` variable contains the calculated feedback value for each parent node. The actual structure and content of the return value will depend on the specific implementation and use case within the project."
      ],
      "code_start_line": 79,
      "code_end_line": 93,
      "params": [
        "self",
        "child"
      ],
      "have_return": true,
      "code_content": "    def _propagate(self, child: MessageNode):\n        if \"user\" in child.feedback:\n            assert len(child.feedback) == 1, \"user feedback should be the only feedback\"\n            assert len(child.feedback[\"user\"]) == 1\n            feedback = child.feedback[\"user\"][0]\n        else:\n            # Simply sum the feedback\n            feedback_list = [v[0] for k, v in child.feedback.items()]\n            assert len(feedback_list) > 0\n            assert all([type(feedback_list[0]) == type(f) for f in feedback_list]), \"error in propagate\"\n            if isinstance(feedback_list[0], str):\n                feedback = \"\".join(feedback_list)\n            else:\n                feedback = sum(feedback_list)\n        return {parent: feedback for parent in child.parents}\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/parents",
        "opto\\trace\\nodes.py/Node/feedback",
        "opto\\trace\\nodes.py/MessageNode"
      ],
      "special_reference_type": [
        false,
        false,
        true
      ]
    }
  ],
  "opto\\trace\\propagators\\__init__.py": [],
  "tests\\unit_tests\\not_covered_usage_cases.py": [
    {
      "type": "FunctionDef",
      "name": "func_a",
      "md_content": [],
      "code_start_line": 14,
      "code_end_line": 15,
      "params": [
        "a"
      ],
      "have_return": true,
      "code_content": "def func_a(a):\n    return a + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\not_covered_usage_cases.py/func_b"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "func_b",
      "md_content": [],
      "code_start_line": 19,
      "code_end_line": 20,
      "params": [
        "b"
      ],
      "have_return": true,
      "code_content": "def func_b(b):\n    return func_a(b) + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\not_covered_usage_cases.py/test_nested_function_visibility"
      ],
      "reference_who": [
        "tests\\unit_tests\\not_covered_usage_cases.py/func_a"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_nested_function_visibility",
      "md_content": [],
      "code_start_line": 23,
      "code_end_line": 27,
      "params": [],
      "have_return": false,
      "code_content": "def test_nested_function_visibility():\n    x = node(3)\n    y = func_b(x)\n    fig = y.backward(visualize=True)\n    fig.render()\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\not_covered_usage_cases.py/func_b"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "func_c",
      "md_content": [],
      "code_start_line": 40,
      "code_end_line": 41,
      "params": [
        "dic"
      ],
      "have_return": false,
      "code_content": "def func_c(dic):\n    dic[\"a\"] = 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_fail",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_succeed",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_with_class_failed",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_with_class_success"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_func_c_fail",
      "md_content": [],
      "code_start_line": 44,
      "code_end_line": 47,
      "params": [],
      "have_return": false,
      "code_content": "def test_func_c_fail():\n    dic = {}\n    func_c(dic)\n    assert \"a\" in dic, \"Failed to update dictionary\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\not_covered_usage_cases.py/func_c"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_func_c_succeed",
      "md_content": [],
      "code_start_line": 50,
      "code_end_line": 54,
      "params": [],
      "have_return": false,
      "code_content": "def test_func_c_succeed():\n    dic = {}\n    dic = node(dic)\n    func_c(dic)\n    assert \"a\" in dic, \"Failed to update dictionary\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\not_covered_usage_cases.py/func_c"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Env",
      "md_content": [],
      "code_start_line": 57,
      "code_end_line": 59,
      "params": [],
      "have_return": false,
      "code_content": "class Env(dict):\n    def __init__(self, init_k, init_v):\n        self[init_k] = init_v\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_with_class_failed",
        "tests\\unit_tests\\not_covered_usage_cases.py/test_func_c_with_class_success"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 58,
      "code_end_line": 59,
      "params": [
        "self",
        "init_k",
        "init_v"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, init_k, init_v):\n        self[init_k] = init_v\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_func_c_with_class_failed",
      "md_content": [],
      "code_start_line": 62,
      "code_end_line": 65,
      "params": [],
      "have_return": false,
      "code_content": "def test_func_c_with_class_failed():\n    dic = Env(\"c\", 0)\n    func_c(dic)\n    assert \"a\" in dic, \"Failed to update dictionary\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\not_covered_usage_cases.py/func_c",
        "tests\\unit_tests\\not_covered_usage_cases.py/Env"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_func_c_with_class_success",
      "md_content": [],
      "code_start_line": 68,
      "code_end_line": 72,
      "params": [],
      "have_return": false,
      "code_content": "def test_func_c_with_class_success():\n    dic = node(Env(\"c\", 0))\n    func_c(dic)\n    assert \"a\" in dic, \"Failed to update dictionary\"\n    print(dic)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\not_covered_usage_cases.py/func_c",
        "tests\\unit_tests\\not_covered_usage_cases.py/Env"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    }
  ],
  "tests\\unit_tests\\run.py": [
    {
      "type": "FunctionDef",
      "name": "print_colored",
      "md_content": [],
      "code_start_line": 11,
      "code_end_line": 12,
      "params": [
        "text",
        "color"
      ],
      "have_return": false,
      "code_content": "def print_colored(text, color):\n    print(f\"{color}{text}{RESET}\")\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_apply_op.py": [
    {
      "type": "ClassDef",
      "name": "SubContainer",
      "md_content": [],
      "code_start_line": 7,
      "code_end_line": 9,
      "params": [],
      "have_return": false,
      "code_content": "class SubContainer(NodeContainer):\n    def __init__(self, y):\n        self.y = node(y)\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_apply_op.py/Container/__init__"
      ],
      "reference_who": [
        "opto\\trace\\modules.py/NodeContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 8,
      "code_end_line": 9,
      "params": [
        "self",
        "y"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, y):\n        self.y = node(y)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "ClassDef",
      "name": "Container",
      "md_content": [],
      "code_start_line": 12,
      "code_end_line": 17,
      "params": [],
      "have_return": false,
      "code_content": "class Container(NodeContainer):\n    def __init__(self, x, v):\n        self.x = node(x)\n        self.list_x = [node(x + \"1\"), node(x + \"2\")]\n        self.dict_x = dict(v=v, x=[node(x + \"1\"), node(x + \"2\")])\n        self.sub_x = SubContainer(x)\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\modules.py/NodeContainer"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 13,
      "code_end_line": 17,
      "params": [
        "self",
        "x",
        "v"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, x, v):\n        self.x = node(x)\n        self.list_x = [node(x + \"1\"), node(x + \"2\")]\n        self.dict_x = dict(v=v, x=[node(x + \"1\"), node(x + \"2\")])\n        self.sub_x = SubContainer(x)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_apply_op.py/SubContainer"
      ],
      "special_reference_type": [
        false,
        false
      ]
    }
  ],
  "tests\\unit_tests\\test_backward.py": [
    {
      "type": "FunctionDef",
      "name": "my_fun",
      "md_content": [],
      "code_start_line": 46,
      "code_end_line": 48,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def my_fun(x):\n    \"\"\"Test function\"\"\"\n    return x**2 + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_bundle.py": [
    {
      "type": "FunctionDef",
      "name": "run",
      "md_content": [],
      "code_start_line": 11,
      "code_end_line": 446,
      "params": [
        "trainable"
      ],
      "have_return": true,
      "code_content": "def run(trainable=False):\n    # Test the basic usage of bundle\n    from opto.trace import bundle\n    from functools import partial\n    bundle = partial(bundle, trainable=trainable)\n\n\n    nonlocal_var = node('This is a nonlocal variable')\n    @bundle()\n    def print_test():\n        # Check accessibility\n        print('locals\\n', locals())\n        print(global_var._data)\n        print(nonlocal_var._data)#\n\n    print_test()\n\n    x = Node(1, name=\"node_x\")\n    y = Node(2, name=\"node_y\")\n    condition = Node(True)\n\n\n    # Test node_dict==None\n    @bundle(\"[auto_cond] This selects x if condition is True, otherwise y.\", node_dict=None)\n    def auto_cond(condition: Node, x: Node, y: Node):\n        \"\"\"\n        A function that selects x if condition is True, otherwise y.\n        \"\"\"\n        # You can type comments in the function body\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n\n\n    output = auto_cond(condition, x, y)\n    if not trainable:\n        assert output.name.split(\":\")[0] == \"auto_cond\", output.name.split(\":\")[0]\n    assert output._inputs[x.name] is x and output._inputs[y.name] is y and output._inputs[condition.name] is condition\n\n\n    # Test node_dict=='auto'\n    # here we use the signature to get the keys of message_node._inputs\n    @bundle(\"[cond] This selects x if condition is True, otherwise y.\", node_dict=\"auto\")\n    def cond(condition: Node, x: Node, y: Node):\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n\n\n    output = cond(condition, x, y)\n    if not trainable:\n        assert output.name.split(\":\")[0] == \"cond\",  output.name.split(\":\")[0]\n    assert output._inputs[\"x\"] is x and output._inputs[\"y\"] is y and output._inputs[\"condition\"] is condition\n\n\n    # Test dot is okay for operator name\n    @bundle(\"[fancy.cond] This selects x if condition is True, otherwise y.\", node_dict=\"auto\")\n    def fancy_cond(condition: Node, x: Node, y: Node):\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n\n\n    output = fancy_cond(condition, x, y)\n    if not trainable:\n        assert output.name.split(\":\")[0] == \"fancy.cond\", output.name.split(\":\")[0]\n    assert output._inputs[\"x\"] is x and output._inputs[\"y\"] is y and output._inputs[\"condition\"] is condition\n\n\n    # Test wrapping a function that returns a node\n    @bundle(\"[add_1] Add input x and input y\")\n    def foo(x, y):\n        z = x + y\n        return z\n\n\n    z = foo(x, y)\n    assert z.data == 3\n    if not trainable:\n        assert set(z.parents) == {x, y}\n    else:\n        assert len(z.parents)==3\n\n\n    # Test tracing class method\n    class Foo:\n        @bundle(\"[Foo.add] Add input x and input y\")\n        def add(self, x, y):\n            z = x + y\n            return z\n\n\n    foo = Foo()\n    z = foo.add(x, y)\n\n\n    # Test modifying class attribute\n    class Foo:\n        def __init__(self):\n            self.x = 1\n\n        @bundle()\n        def modify_x(self):\n            self.x = 2\n\n    foo = Foo()\n    foo.modify_x()\n    assert foo.x == 2\n\n\n    # Test composition of bundle with for all_all_methods\n    @for_all_methods\n    def test_cls_decorator(fun):\n        def wrapper(*args, **kwargs):\n            return fun(*args, **kwargs)\n\n        return wrapper\n\n\n    @test_cls_decorator\n    class Foo:\n        # Test automatic description generation\n        @bundle()\n        def add(self, x, y):\n            z = x + y\n            return z\n\n\n    foo = Foo()\n    z = foo.add(x, y)\n\n\n    # Test functions with *args and *kwargs and node_dict=None\n    @bundle(node_dict=None, unpack_input=False)\n    def fun(a, args, kwargs, *_args, **_kwargs):\n        print(a.data)\n        print(args.data)\n        print(kwargs.data)\n        return a\n\n    x = fun(\n        node(1), node(\"args\"), node(\"kwargs\"), node(\"_args_1\"), node(\"_args_2\"), b=node(\"_kwargs_b\"), c=node(\"_kwargs_c\")\n    )\n    print(x, x.inputs)\n    if not trainable:\n        assert len(x.inputs) == 3\n    else:\n        assert len(x.inputs) == 4\n\n\n    # Test functions with *args and *kwargs and node_dict='auto'\n    @bundle(node_dict=\"auto\")  # This is the default behavior\n    def fun(a, args, kwargs, *_args, **_kwargs):\n        print(a)\n        print(args)\n        print(kwargs)\n        for v in _args:\n            print(v)\n        for k, v in _kwargs.items():\n            print(v)\n        return a\n\n\n    x = fun(\n        node(1), node(\"args\"), node(\"kwargs\"), node(\"_args_1\"), node(\"_args_2\"), b=node(\"_kwargs_b\"), c=node(\"_kwargs_c\")\n    )\n    print(x, x.inputs)\n\n\n    # Test stop_tracing\n    x = node(1)\n    y = node(2)\n    with trace.stop_tracing():\n        z = x + y\n    assert z.inputs == {}\n    assert z == 3\n\n    @bundle()  # Test bundle with inline comment\n    def fun(a, b):  # Test bundle with inline comment\n        return a + b\n    assert fun(node(1), node(2)) == 3\n\n    # Test bundle as an inline decorator\n    def fun(a, b):\n        return a + b\n\n    tfun = bundle()(fun)\n    assert tfun(node(1), node(2)) == 3\n\n    tfun = bundle()(fun)  # Test inline bundle with comments\n    assert tfun(node(1), node(2)) == 3\n\n\n    # Test multi-output function\n    @bundle(n_outputs=2)\n    def fun(a, b):\n        return a + b, a - b\n\n\n    x, y = fun(node(1), node(2))\n\n\n    @bundle()  # single output\n    def fun(a, b):\n        return a + b, a - b\n\n\n    x_y = fun(node(1), node(2))\n    assert isinstance(x_y, Node) and len(x_y) == 2\n    assert isinstance(x, Node)\n    assert isinstance(y, Node)\n\n    assert x == x_y[0] and y == x_y[1]\n\n\n    # Test trace codes using nodes\n\n\n    @bundle(traceable_code=True)  # set unpack_input=False to run node-based codes\n    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10\n\n\n    x = node(1)\n    y = node(2)\n    z = test(x, y)\n    assert z == (x + y + 10)\n    assert contain(z.parents, x) and contain(z.parents, y)\n    if not trainable:\n        assert \"test\" in z.name\n\n    z0 = z.info[\"output\"]  # This is the original output\n    assert z == z0\n    assert not contain(z0.parents, x) and not contain(z0.parents, y)\n    assert \"add\" in z0.name\n\n\n    # Test external dependencies\n\n    external_var = node(0)\n\n\n    @bundle()  # set unpack_input=False to run node-based codes\n    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n\n\n    x = node(1)\n    y = node(2)\n    try:\n        z = test(x, y)\n    except TraceMissingInputsError:\n        print(\"This usage throws an error because external_var is not provided as part of the inputs\")\n\n\n    @bundle(node_dict={\"x\": external_var})\n    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n\n\n    z = test(x, y)\n    assert z == (x + y + 10 + external_var.data)\n    assert contain(z.parents, x) and contain(z.parents, y) and contain(z.parents, external_var)\n    assert \"a\" in z.inputs and \"b\" in z.inputs and \"x\" in z.inputs\n\n\n    @bundle(allow_external_dependencies=True)\n    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n\n\n    z = test(x, y)\n    assert z == (x + y + 10 + external_var.data)\n    assert contain(z.parents, x) and contain(z.parents, y)\n    assert contain(z.info[\"external_dependencies\"], external_var)\n    assert \"a\" in z.inputs and \"b\" in z.inputs\n\n    # Test get attribute and call\n\n\n    class Foo:\n        def __init__(self):\n            self.node = node(1)\n            self.non_node = 2\n\n        def trace_fun(self, x: Node):\n            print(x.data)\n            return self.node * 2\n\n        def non_trace_fun(self):\n            return self.non_node * 2\n\n\n    foo = node(Foo())\n    x = node(\"x\")\n    try:\n        foo.node\n        foo.trace_fun()\n    except AttributeError:\n        print(\"The attribute of the wrapped object cannot be directly accessed. Instead use getattr() or call()\")\n\n\n    attr = foo.getattr(\"node\")\n    print(f\"foo_node: {attr}\\nparents {[(p.name, p.data) for p in attr.parents]}\")\n\n\n    attr = foo.getattr(\"non_node\")\n    print(f\"non_node: {attr}\\nparents {[(p.name, p.data) for p in attr.parents]}\")\n\n\n    fun = foo.getattr(\"non_trace_fun\")\n    y = fun()\n    print(f\"output: {y}\\nparents {[(p.name, p.data) for p in y.parents]}\")\n\n    fun = foo.getattr(\"trace_fun\")\n    y = fun(x)\n\n    y = foo.call(\"non_trace_fun\")\n    print(f\"output: {y}\\nparents {[(p.name, p.data) for p in y.parents]}\")\n\n    y = foo.call(\"trace_fun\", x)\n    print(f\"output: {y}\\nparents {[(p.name, p.data) for p in y.parents]}\")\n\n\n    class Foo:\n        def __init__(self):\n            self.x = node(1)\n\n        def add(self, y):\n            return y + 1 + self.x  # node\n\n\n    node_F = node(Foo())\n    y = node_F.getattr(\"x\")\n    assert len(y.parents) == 2\n    assert \"getattr\" in y.name\n    assert y == node_F.data.x  # value\n\n    add = node_F.getattr(\"add\")\n    z = add(node(2))\n    assert len(z.parents) == 2\n    assert contain(z.parents, add)\n    assert contain(z.parents[0].parents, node_F)\n\n    z2 = node_F.call(\"add\", 2)\n    assert z2 == z\n    assert contain(z2.parents[0].parents, node_F)\n\n    z2 = node_F.call(\"add\", node(2))\n    assert z2 == z\n    assert contain(z2.parents[0].parents, node_F)\n\n    # Test recursion\n    @bundle()\n    def recursion(n):\n        if n == 0:\n            return 0\n        return n + recursion(n - 1)\n\n    output = recursion(10)\n    assert output == 55, \"Failed to compute recursion\"\n    if not trainable:\n        assert len(output.parents) == 1\n    else:\n        assert len(output.parents) == 2\n\n    # Test nested function visibility\n\n    @bundle()\n    def func_a(a):\n        \"Returns a+1\"\n        return a + 1\n\n\n    @bundle()\n    def func_b(b):\n        \"Returns b+1\"\n        return func_a(b) + 1\n\n    y = func_b(3)\n    if not trainable:\n        assert len(y.parents) == 1\n    else:\n        assert len(y.parents) == 2\n    assert y == 5\n\n\n    def test_retriving_non_local_objects():\n\n        @bundle()\n        def non_local_func_a(a):\n            \"Returns a+1\"\n            return a + 1\n        @bundle()\n        def non_func_b(b):\n            \"Returns b+1\"\n            return non_local_func_a(b) + 1\n        y = non_func_b(3)\n        if not trainable:\n            assert len(y.parents) == 1\n        else:\n            assert len(y.parents) == 2\n        assert y == 5\n\n    test_retriving_non_local_objects()\n\n    if not trainable:\n        # test modifying nonlocal and global variables\n        # TODO this does not work with trainable=True, based on function defined by exec\n        nonlocal_x = 5\n        @bundle()\n        def modify_nonlocal():\n            nonlocal nonlocal_x\n            print('nonlocal', x)\n            nonlocal_x = nonlocal_x + 1\n        modify_nonlocal()\n        assert nonlocal_x == 6\n\n        print('before', id(global_var))\n        @bundle()\n        def modify_global():\n            global global_var\n            print('global', global_var, id(global_var))\n            global_var = node(str(trainable)+'none')\n        modify_global()\n        print(global_var, (str(trainable)+'none'))\n        assert (global_var == (str(trainable)+'none')), global_var\n\n    # Test modifying global list\n    old_len = len(global_list)\n    @bundle()\n    def modify_global_list():\n        global_list.append(1)\n    modify_global_list()\n    assert len(global_list) == old_len + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "opto\\trace\\errors.py/TraceMissingInputsError",
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/AbstractNode/parents",
        "opto\\trace\\nodes.py/AbstractNode/name",
        "opto\\trace\\nodes.py/Node",
        "opto\\trace\\nodes.py/Node/info",
        "opto\\trace\\nodes.py/Node/getattr",
        "opto\\trace\\nodes.py/Node/call",
        "opto\\trace\\nodes.py/MessageNode/inputs",
        "opto\\trace\\trace.py/stop_tracing",
        "opto\\trace\\utils.py/contain",
        "opto\\trace\\utils.py/for_all_methods"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "print_test",
      "md_content": [],
      "code_start_line": 20,
      "code_end_line": 24,
      "params": [],
      "have_return": false,
      "code_content": "    def print_test():\n        # Check accessibility\n        print('locals\\n', locals())\n        print(global_var._data)\n        print(nonlocal_var._data)#\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "auto_cond",
      "md_content": [],
      "code_start_line": 35,
      "code_end_line": 41,
      "params": [
        "condition",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "    def auto_cond(condition: Node, x: Node, y: Node):\n        \"\"\"\n        A function that selects x if condition is True, otherwise y.\n        \"\"\"\n        # You can type comments in the function body\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "cond",
      "md_content": [],
      "code_start_line": 53,
      "code_end_line": 55,
      "params": [
        "condition",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "    def cond(condition: Node, x: Node, y: Node):\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "fancy_cond",
      "md_content": [],
      "code_start_line": 66,
      "code_end_line": 68,
      "params": [
        "condition",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "    def fancy_cond(condition: Node, x: Node, y: Node):\n        x, y, condition = x, y, condition  # This makes sure all data are read\n        return x if condition else y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "foo",
      "md_content": [],
      "code_start_line": 79,
      "code_end_line": 81,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "    def foo(x, y):\n        z = x + y\n        return z\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Foo",
      "md_content": [],
      "code_start_line": 93,
      "code_end_line": 97,
      "params": [],
      "have_return": true,
      "code_content": "    class Foo:\n        @bundle(\"[Foo.add] Add input x and input y\")\n        def add(self, x, y):\n            z = x + y\n            return z\n",
      "name_column": 10,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "add",
      "md_content": [],
      "code_start_line": 95,
      "code_end_line": 97,
      "params": [
        "self",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "        def add(self, x, y):\n            z = x + y\n            return z\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Foo",
      "md_content": [],
      "code_start_line": 105,
      "code_end_line": 111,
      "params": [],
      "have_return": false,
      "code_content": "    class Foo:\n        def __init__(self):\n            self.x = 1\n\n        @bundle()\n        def modify_x(self):\n            self.x = 2\n",
      "name_column": 10,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 106,
      "code_end_line": 107,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "        def __init__(self):\n            self.x = 1\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "modify_x",
      "md_content": [],
      "code_start_line": 110,
      "code_end_line": 111,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "        def modify_x(self):\n            self.x = 2\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_cls_decorator",
      "md_content": [],
      "code_start_line": 120,
      "code_end_line": 124,
      "params": [
        "fun"
      ],
      "have_return": true,
      "code_content": "    def test_cls_decorator(fun):\n        def wrapper(*args, **kwargs):\n            return fun(*args, **kwargs)\n\n        return wrapper\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "wrapper",
      "md_content": [],
      "code_start_line": 121,
      "code_end_line": 122,
      "params": [],
      "have_return": true,
      "code_content": "        def wrapper(*args, **kwargs):\n            return fun(*args, **kwargs)\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Foo",
      "md_content": [],
      "code_start_line": 128,
      "code_end_line": 133,
      "params": [],
      "have_return": true,
      "code_content": "    class Foo:\n        # Test automatic description generation\n        @bundle()\n        def add(self, x, y):\n            z = x + y\n            return z\n",
      "name_column": 10,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "add",
      "md_content": [],
      "code_start_line": 131,
      "code_end_line": 133,
      "params": [
        "self",
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "        def add(self, x, y):\n            z = x + y\n            return z\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 142,
      "code_end_line": 146,
      "params": [
        "a",
        "args",
        "kwargs"
      ],
      "have_return": true,
      "code_content": "    def fun(a, args, kwargs, *_args, **_kwargs):\n        print(a.data)\n        print(args.data)\n        print(kwargs.data)\n        return a\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 160,
      "code_end_line": 168,
      "params": [
        "a",
        "args",
        "kwargs"
      ],
      "have_return": true,
      "code_content": "    def fun(a, args, kwargs, *_args, **_kwargs):\n        print(a)\n        print(args)\n        print(kwargs)\n        for v in _args:\n            print(v)\n        for k, v in _kwargs.items():\n            print(v)\n        return a\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 186,
      "code_end_line": 187,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def fun(a, b):  # Test bundle with inline comment\n        return a + b\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 191,
      "code_end_line": 192,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def fun(a, b):\n        return a + b\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 203,
      "code_end_line": 204,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def fun(a, b):\n        return a + b, a - b\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 211,
      "code_end_line": 212,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def fun(a, b):\n        return a + b, a - b\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 227,
      "code_end_line": 229,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 252,
      "code_end_line": 254,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 266,
      "code_end_line": 268,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 278,
      "code_end_line": 280,
      "params": [
        "a",
        "b"
      ],
      "have_return": true,
      "code_content": "    def test(a: Node, b: Node):\n        \"\"\"Complex function.\"\"\"\n        return a + b + 10 + external_var.data\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "ClassDef",
      "name": "Foo",
      "md_content": [],
      "code_start_line": 292,
      "code_end_line": 302,
      "params": [],
      "have_return": true,
      "code_content": "    class Foo:\n        def __init__(self):\n            self.node = node(1)\n            self.non_node = 2\n\n        def trace_fun(self, x: Node):\n            print(x.data)\n            return self.node * 2\n\n        def non_trace_fun(self):\n            return self.non_node * 2\n",
      "name_column": 10,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 293,
      "code_end_line": 295,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "        def __init__(self):\n            self.node = node(1)\n            self.non_node = 2\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "trace_fun",
      "md_content": [],
      "code_start_line": 297,
      "code_end_line": 299,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "        def trace_fun(self, x: Node):\n            print(x.data)\n            return self.node * 2\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/AbstractNode/data",
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        false,
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "non_trace_fun",
      "md_content": [],
      "code_start_line": 301,
      "code_end_line": 302,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "        def non_trace_fun(self):\n            return self.non_node * 2\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "Foo",
      "md_content": [],
      "code_start_line": 336,
      "code_end_line": 341,
      "params": [],
      "have_return": true,
      "code_content": "    class Foo:\n        def __init__(self):\n            self.x = node(1)\n\n        def add(self, y):\n            return y + 1 + self.x  # node\n",
      "name_column": 10,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 337,
      "code_end_line": 338,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "        def __init__(self):\n            self.x = node(1)\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "add",
      "md_content": [],
      "code_start_line": 340,
      "code_end_line": 341,
      "params": [
        "self",
        "y"
      ],
      "have_return": true,
      "code_content": "        def add(self, y):\n            return y + 1 + self.x  # node\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "recursion",
      "md_content": [],
      "code_start_line": 366,
      "code_end_line": 369,
      "params": [
        "n"
      ],
      "have_return": true,
      "code_content": "    def recursion(n):\n        if n == 0:\n            return 0\n        return n + recursion(n - 1)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "func_a",
      "md_content": [],
      "code_start_line": 381,
      "code_end_line": 383,
      "params": [
        "a"
      ],
      "have_return": true,
      "code_content": "    def func_a(a):\n        \"Returns a+1\"\n        return a + 1\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_bundle.py/run/func_b"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "func_b",
      "md_content": [],
      "code_start_line": 387,
      "code_end_line": 389,
      "params": [
        "b"
      ],
      "have_return": true,
      "code_content": "    def func_b(b):\n        \"Returns b+1\"\n        return func_a(b) + 1\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_bundle.py/run/func_a"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_retriving_non_local_objects",
      "md_content": [],
      "code_start_line": 399,
      "code_end_line": 414,
      "params": [],
      "have_return": true,
      "code_content": "    def test_retriving_non_local_objects():\n\n        @bundle()\n        def non_local_func_a(a):\n            \"Returns a+1\"\n            return a + 1\n        @bundle()\n        def non_func_b(b):\n            \"Returns b+1\"\n            return non_local_func_a(b) + 1\n        y = non_func_b(3)\n        if not trainable:\n            assert len(y.parents) == 1\n        else:\n            assert len(y.parents) == 2\n        assert y == 5\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "non_local_func_a",
      "md_content": [],
      "code_start_line": 402,
      "code_end_line": 404,
      "params": [
        "a"
      ],
      "have_return": true,
      "code_content": "        def non_local_func_a(a):\n            \"Returns a+1\"\n            return a + 1\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_bundle.py/run/test_retriving_non_local_objects/non_func_b"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "non_func_b",
      "md_content": [],
      "code_start_line": 406,
      "code_end_line": 408,
      "params": [
        "b"
      ],
      "have_return": true,
      "code_content": "        def non_func_b(b):\n            \"Returns b+1\"\n            return non_local_func_a(b) + 1\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_bundle.py/run/test_retriving_non_local_objects/non_local_func_a"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "modify_global_list",
      "md_content": [],
      "code_start_line": 443,
      "code_end_line": 444,
      "params": [],
      "have_return": false,
      "code_content": "    def modify_global_list():\n        global_list.append(1)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "modify_nonlocal",
      "md_content": [],
      "code_start_line": 423,
      "code_end_line": 426,
      "params": [],
      "have_return": false,
      "code_content": "        def modify_nonlocal():\n            nonlocal nonlocal_x\n            print('nonlocal', x)\n            nonlocal_x = nonlocal_x + 1\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "modify_global",
      "md_content": [],
      "code_start_line": 432,
      "code_end_line": 435,
      "params": [],
      "have_return": false,
      "code_content": "        def modify_global():\n            global global_var\n            print('global', global_var, id(global_var))\n            global_var = node(str(trainable)+'none')\n",
      "name_column": 12,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    }
  ],
  "tests\\unit_tests\\test_containers.py": [],
  "tests\\unit_tests\\test_error_handling.py": [
    {
      "type": "FunctionDef",
      "name": "bug_program",
      "md_content": [],
      "code_start_line": 9,
      "code_end_line": 11,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def bug_program(x: Node, y: Node):\n    z = x / y\n    return z\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "bug_progam",
      "md_content": [],
      "code_start_line": 33,
      "code_end_line": 35,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def bug_progam(x):\n    x + 10\n    return\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_modules.py": [
    {
      "type": "ClassDef",
      "name": "BaseModule",
      "md_content": [],
      "code_start_line": 10,
      "code_end_line": 23,
      "params": [],
      "have_return": true,
      "code_content": "class BaseModule(Module):\n    def __init__(self):\n        super().__init__()\n        self._param = node(1, trainable=True)\n\n    @bundle(trainable=True)\n    def method1(self, x):\n        return x\n\n    def method2(self, y):\n        return y\n\n    def forward(self, i):\n        return self.method1(i)\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/ChildModule",
        "tests\\unit_tests\\test_modules.py/ChildModule/__init__"
      ],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "opto\\trace\\modules.py/Module"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 11,
      "code_end_line": 13,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        super().__init__()\n        self._param = node(1, trainable=True)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "method1",
      "md_content": [],
      "code_start_line": 16,
      "code_end_line": 17,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def method1(self, x):\n        return x\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/BaseModule/forward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "method2",
      "md_content": [],
      "code_start_line": 19,
      "code_end_line": 20,
      "params": [
        "self",
        "y"
      ],
      "have_return": true,
      "code_content": "    def method2(self, y):\n        return y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [],
      "code_start_line": 22,
      "code_end_line": 23,
      "params": [
        "self",
        "i"
      ],
      "have_return": true,
      "code_content": "    def forward(self, i):\n        return self.method1(i)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_modules.py/BaseModule/method1"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "dummy_method",
      "md_content": [],
      "code_start_line": 31,
      "code_end_line": 32,
      "params": [],
      "have_return": true,
      "code_content": "def dummy_method():\n    return 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/ChildModule/__init__",
        "tests\\unit_tests\\test_modules.py/ChildClass/__init__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "ChildModule",
      "md_content": [],
      "code_start_line": 35,
      "code_end_line": 47,
      "params": [],
      "have_return": true,
      "code_content": "class ChildModule(BaseModule):\n    def __init__(self):\n        super().__init__()\n        self._extra_param = node(1, trainable=True)\n        self._extra_method = bundle(trainable=True)(dummy_method)\n        self._base = BaseModule()  # ParameterContainer\n\n    @bundle(trainable=True)\n    def method1(self, x):\n        return x\n\n    def method2(self, y):\n        return y\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "tests\\unit_tests\\test_modules.py/BaseModule"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 36,
      "code_end_line": 40,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        super().__init__()\n        self._extra_param = node(1, trainable=True)\n        self._extra_method = bundle(trainable=True)(dummy_method)\n        self._base = BaseModule()  # ParameterContainer\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_modules.py/BaseModule",
        "tests\\unit_tests\\test_modules.py/dummy_method",
        "tests\\unit_tests\\test_modules.py/dummy_method_0(name_duplicate_version)"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "method1",
      "md_content": [],
      "code_start_line": 43,
      "code_end_line": 44,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def method1(self, x):\n        return x\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "method2",
      "md_content": [],
      "code_start_line": 46,
      "code_end_line": 47,
      "params": [
        "self",
        "y"
      ],
      "have_return": true,
      "code_content": "    def method2(self, y):\n        return y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "BaseClass",
      "md_content": [],
      "code_start_line": 57,
      "code_end_line": 70,
      "params": [],
      "have_return": true,
      "code_content": "class BaseClass:\n    def __init__(self):\n        super().__init__()\n        self._param = node(1, trainable=True)\n\n    @bundle(trainable=True)\n    def method1(self, x):\n        return x\n\n    def method2(self, y):\n        return y\n\n    def forward(self, i):\n        return self.method1(i)\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/ChildClass",
        "tests\\unit_tests\\test_modules.py/ChildClass/__init__"
      ],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 58,
      "code_end_line": 60,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        super().__init__()\n        self._param = node(1, trainable=True)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "method1",
      "md_content": [],
      "code_start_line": 63,
      "code_end_line": 64,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def method1(self, x):\n        return x\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/BaseClass/forward"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "method2",
      "md_content": [],
      "code_start_line": 66,
      "code_end_line": 67,
      "params": [
        "self",
        "y"
      ],
      "have_return": true,
      "code_content": "    def method2(self, y):\n        return y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [],
      "code_start_line": 69,
      "code_end_line": 70,
      "params": [
        "self",
        "i"
      ],
      "have_return": true,
      "code_content": "    def forward(self, i):\n        return self.method1(i)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_modules.py/BaseClass/method1"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "dummy_method",
      "md_content": [],
      "code_start_line": 78,
      "code_end_line": 79,
      "params": [],
      "have_return": true,
      "code_content": "def dummy_method():\n    return 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_modules.py/ChildModule/__init__",
        "tests\\unit_tests\\test_modules.py/ChildClass/__init__"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "ChildClass",
      "md_content": [],
      "code_start_line": 82,
      "code_end_line": 94,
      "params": [],
      "have_return": true,
      "code_content": "class ChildClass(BaseClass):\n    def __init__(self):\n        super().__init__()\n        self._extra_param = node(1, trainable=True)\n        self._extra_method = bundle(trainable=True)(dummy_method)\n        self._base = BaseClass()  # ParameterContainer\n\n    @bundle(trainable=True)\n    def method1(self, x):\n        return x\n\n    def method2(self, y):\n        return y\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "tests\\unit_tests\\test_modules.py/BaseClass"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [],
      "code_start_line": 83,
      "code_end_line": 87,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        super().__init__()\n        self._extra_param = node(1, trainable=True)\n        self._extra_method = bundle(trainable=True)(dummy_method)\n        self._base = BaseClass()  # ParameterContainer\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/bundle",
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_modules.py/dummy_method",
        "tests\\unit_tests\\test_modules.py/BaseClass",
        "tests\\unit_tests\\test_modules.py/dummy_method_0(name_duplicate_version)"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "method1",
      "md_content": [],
      "code_start_line": 90,
      "code_end_line": 91,
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "    def method1(self, x):\n        return x\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "method2",
      "md_content": [],
      "code_start_line": 93,
      "code_end_line": 94,
      "params": [
        "self",
        "y"
      ],
      "have_return": true,
      "code_content": "    def method2(self, y):\n        return y\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_nodes.py": [
    {
      "type": "FunctionDef",
      "name": "fun",
      "md_content": [],
      "code_start_line": 119,
      "code_end_line": 120,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def fun(x):\n    return x + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_optimizer.py": [
    {
      "type": "FunctionDef",
      "name": "blackbox",
      "md_content": [],
      "code_start_line": 11,
      "code_end_line": 12,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def blackbox(x):\n    return -x * 2\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py/bar"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "bar",
      "md_content": [],
      "code_start_line": 16,
      "code_end_line": 18,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def bar(x):\n    \"This is a test function, which does negative scaling.\"\n    return blackbox(x)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py/foobar",
        "tests\\unit_tests\\test_optimizer.py/foobar_text"
      ],
      "reference_who": [
        "tests\\unit_tests\\test_optimizer.py/blackbox"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "foo",
      "md_content": [],
      "code_start_line": 21,
      "code_end_line": 23,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def foo(x):\n    y = x + 1\n    return x * y\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py/foobar",
        "tests\\unit_tests\\test_optimizer.py/foobar_text"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "foobar",
      "md_content": [],
      "code_start_line": 27,
      "code_end_line": 28,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def foobar(x):\n    return foo(bar(x))\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_optimizer.py/bar",
        "tests\\unit_tests\\test_optimizer.py/foo"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "user",
      "md_content": [],
      "code_start_line": 31,
      "code_end_line": 35,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def user(x):\n    if x < 50:\n        return \"The number needs to be larger.\"\n    else:\n        return \"Success.\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "convert_english_to_numbers",
      "md_content": [],
      "code_start_line": 53,
      "code_end_line": 104,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def convert_english_to_numbers(x):\n    \"\"\"This is a function that converts English to numbers. This function has limited ability.\"\"\"\n    # remove special characters, like, \", &, etc.\n    x = x.replace('\"', \"\")\n    try:  # Convert string to integer\n        return int(x)\n    except ValueError:\n        pass\n    # Convert integers written in Engligsh in [-10, 10] to numbers\n    if x == \"negative ten\":\n        return -10\n    if x == \"negative nine\":\n        return -9\n    if x == \"negative eight\":\n        return -8\n    if x == \"negative seven\":\n        return -7\n    if x == \"negative six\":\n        return -6\n    if x == \"negative five\":\n        return -5\n    if x == \"negative four\":\n        return -4\n    if x == \"negative three\":\n        return -3\n    if x == \"negative two\":\n        return -2\n    if x == \"negative one\":\n        return -1\n    if x == \"zero\":\n        return 0\n    if x == \"one\":\n        return 1\n    if x == \"two\":\n        return 2\n    if x == \"three\":\n        return 3\n    if x == \"four\":\n        return 4\n    if x == \"five\":\n        return 5\n    if x == \"six\":\n        return 6\n    if x == \"seven\":\n        return 7\n    if x == \"eight\":\n        return 8\n    if x == \"nine\":\n        return 9\n    if x == \"ten\":\n        return 10\n    return \"FAIL\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_optimizer.py/foobar_text"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "user",
      "md_content": [],
      "code_start_line": 107,
      "code_end_line": 113,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def user(x):\n    if x == \"FAIL\":\n        return \"The text cannot be converted to a number.\"\n    if x < 50:\n        return \"The number needs to be larger.\"\n    else:\n        return \"Success.\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "foobar_text",
      "md_content": [],
      "code_start_line": 116,
      "code_end_line": 121,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def foobar_text(x):\n    output = convert_english_to_numbers(x)\n    if output.data == \"FAIL\":  # This is not traced\n        return output\n    else:\n        return foo(bar(output))\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests\\unit_tests\\test_optimizer.py/bar",
        "tests\\unit_tests\\test_optimizer.py/foo",
        "tests\\unit_tests\\test_optimizer.py/convert_english_to_numbers"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "user",
      "md_content": [],
      "code_start_line": 138,
      "code_end_line": 142,
      "params": [
        "output"
      ],
      "have_return": true,
      "code_content": "def user(output):\n    if output < 0:\n        return \"Success.\"\n    else:\n        return \"Try again. The output should be negative\"\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "my_fun",
      "md_content": [],
      "code_start_line": 147,
      "code_end_line": 149,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def my_fun(x):\n    \"\"\"Test function\"\"\"\n    return x**2 + 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_python_funcs.py": [
    {
      "type": "FunctionDef",
      "name": "get_env",
      "md_content": [],
      "code_start_line": 15,
      "code_end_line": 19,
      "params": [
        "params",
        "args",
        "env"
      ],
      "have_return": true,
      "code_content": "def get_env(params, args, env=None):\n    new_env = {\"_outer\": env}\n    for param, arg in zip(params, args):\n        new_env[param] = arg\n    return new_env\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_get_env",
        "tests\\unit_tests\\test_python_funcs.py/test_find"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_get_env",
      "md_content": [],
      "code_start_line": 22,
      "code_end_line": 25,
      "params": [],
      "have_return": false,
      "code_content": "def test_get_env():\n    env = get_env(node([\"a\", \"b\"]), node([1, 2]))\n    assert isinstance(env, Node)\n    assert env.data == {\"_outer\": None, \"a\": 1, \"b\": 2}\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "opto\\trace\\nodes.py/Node",
        "tests\\unit_tests\\test_python_funcs.py/get_env"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_math",
      "md_content": [],
      "code_start_line": 32,
      "code_end_line": 37,
      "params": [],
      "have_return": true,
      "code_content": "def get_math():\n    d = {}\n    for name in dir(math):\n        if name[:2] != \"__\":\n            d[name] = getattr(math, name)\n    return d\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_empty_inputs",
        "tests\\unit_tests\\test_python_funcs.py/standard_env"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_empty_inputs",
      "md_content": [],
      "code_start_line": 40,
      "code_end_line": 47,
      "params": [],
      "have_return": false,
      "code_content": "def test_empty_inputs():\n    result = get_math()\n    assert isinstance(result, Node)\n    result.backward()\n\n    result = get_ops()\n    assert isinstance(result, Node)\n    result.backward()\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "tests\\unit_tests\\test_python_funcs.py/get_math",
        "tests\\unit_tests\\test_python_funcs.py/get_ops"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_ops",
      "md_content": [],
      "code_start_line": 53,
      "code_end_line": 64,
      "params": [],
      "have_return": true,
      "code_content": "def get_ops():\n    return {\n        \"+\": (lambda x, y: x + y),\n        \"-\": (lambda x, y: x - y),\n        \"*\": (lambda x, y: x * y),\n        \"/\": (lambda x, y: x / y),\n        \">\": (lambda x, y: x > y),\n        \"<\": (lambda x, y: x < y),\n        \">=\": (lambda x, y: x >= y),\n        \"<=\": (lambda x, y: x <= y),\n        \"=\": (lambda x, y: x == y),\n    }\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_empty_inputs",
        "tests\\unit_tests\\test_python_funcs.py/test_apply_fn_dict_key",
        "tests\\unit_tests\\test_python_funcs.py/standard_env"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "apply_fn_dict_key",
      "md_content": [],
      "code_start_line": 74,
      "code_end_line": 76,
      "params": [
        "fn_dict_generator",
        "key",
        "args_list"
      ],
      "have_return": true,
      "code_content": "def apply_fn_dict_key(fn_dict_generator, key, args_list):\n    fn_dict = fn_dict_generator()\n    return fn_dict[key](*args_list)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_apply_fn_dict_key"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_apply_fn_dict_key",
      "md_content": [],
      "code_start_line": 79,
      "code_end_line": 86,
      "params": [],
      "have_return": false,
      "code_content": "def test_apply_fn_dict_key():\n    fn_dict_generator = get_ops\n    key = \"+\"\n    args_list = node([1, 2])\n    result = apply_fn_dict_key(fn_dict_generator, key, args_list)\n    assert result.data == 3\n\n    result.backward(visualize=True)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_python_funcs.py/get_ops",
        "tests\\unit_tests\\test_python_funcs.py/apply_fn_dict_key"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_simple_math",
      "md_content": [],
      "code_start_line": 98,
      "code_end_line": 99,
      "params": [],
      "have_return": true,
      "code_content": "def get_simple_math():\n    return {\"abs\": abs, \"min\": min, \"max\": max, \"not\": lambda x: not x, \"round\": round}\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/standard_env"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "standard_env",
      "md_content": [],
      "code_start_line": 108,
      "code_end_line": 116,
      "params": [
        "includes"
      ],
      "have_return": true,
      "code_content": "def standard_env(includes=[\"math\", \"ops\", \"simple_math\"]):\n    env = {\"_outer\": None}\n    if \"math\" in includes:\n        env.update(get_math())\n    if \"ops\" in includes:\n        env.update(get_ops())\n    if \"simple_math\" in includes:\n        env.update(get_simple_math())\n    return env\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_standard_env"
      ],
      "reference_who": [
        "tests\\unit_tests\\test_python_funcs.py/get_math",
        "tests\\unit_tests\\test_python_funcs.py/get_ops",
        "tests\\unit_tests\\test_python_funcs.py/get_simple_math"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_standard_env",
      "md_content": [],
      "code_start_line": 119,
      "code_end_line": 121,
      "params": [],
      "have_return": false,
      "code_content": "def test_standard_env():\n    env = standard_env()\n    assert isinstance(env, Node)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/Node",
        "tests\\unit_tests\\test_python_funcs.py/standard_env"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "recurse",
      "md_content": [],
      "code_start_line": 130,
      "code_end_line": 135,
      "params": [
        "dic",
        "var"
      ],
      "have_return": true,
      "code_content": "    def recurse(dic, var):\n        \"Simple recursion\"\n        if var in dic:\n            return dic[var]\n        else:\n            return recurse(dic[\"_outer\"], var)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_recurse"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_recurse",
      "md_content": [],
      "code_start_line": 137,
      "code_end_line": 140,
      "params": [],
      "have_return": false,
      "code_content": "    def test_recurse():\n        dic = {\"_outer\": {\"_outer\": {\"_outer\": None, \"a\": 1}, \"b\": 2}, \"c\": 3}\n        result = recurse(node(dic), node(\"a\"))\n        assert result.data == 1\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_python_funcs.py/recurse"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "find",
      "md_content": [],
      "code_start_line": 150,
      "code_end_line": 154,
      "params": [
        "env",
        "var"
      ],
      "have_return": true,
      "code_content": "    def find(env, var):\n        if var in env:\n            return env[var]\n        else:\n            return find(env[\"_outer\"], var)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests\\unit_tests\\test_python_funcs.py/test_find"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_find",
      "md_content": [],
      "code_start_line": 156,
      "code_end_line": 165,
      "params": [],
      "have_return": false,
      "code_content": "    def test_find():\n        env = get_env(node([\"a\", \"b\"]), node([1, 2]))\n        result = find(env, node(\"a\"))\n        assert result.data == 1\n\n        result = find(env, node(\"b\"))\n        assert result.data == 2\n\n        result = find(env, node(\"c\"))\n        assert result.data == 2\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\nodes.py/node",
        "tests\\unit_tests\\test_python_funcs.py/get_env",
        "tests\\unit_tests\\test_python_funcs.py/find"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    }
  ],
  "tests\\unit_tests\\test_randomness.py": [
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 9,
      "code_end_line": 11,
      "params": [],
      "have_return": true,
      "code_content": "def test():\n    x = random.random()\n    return x\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test",
      "md_content": [],
      "code_start_line": 26,
      "code_end_line": 27,
      "params": [],
      "have_return": true,
      "code_content": "def test():\n    return 1\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tests\\unit_tests\\test_to_data.py": [
    {
      "type": "FunctionDef",
      "name": "simple_test_unnested",
      "md_content": [],
      "code_start_line": 4,
      "code_end_line": 12,
      "params": [],
      "have_return": false,
      "code_content": "def simple_test_unnested():\n    a = node(1)\n    to_data(a)\n\n    a = node({\"2\": 2})\n    to_data(a)\n\n    a = node([1, 2, 3])\n    to_data(a)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "simple_test_node_over_container",
      "md_content": [],
      "code_start_line": 15,
      "code_end_line": 17,
      "params": [],
      "have_return": false,
      "code_content": "def simple_test_node_over_container():\n    a = node([node(1), node(2), node(3)])\n    to_data(a)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "simple_test_container_over_node",
      "md_content": [],
      "code_start_line": 20,
      "code_end_line": 22,
      "params": [],
      "have_return": false,
      "code_content": "def simple_test_container_over_node():\n    a = [node(1), node(2), node(3)]\n    to_data(a)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_container_over_container_over_node",
      "md_content": [],
      "code_start_line": 25,
      "code_end_line": 28,
      "params": [],
      "have_return": false,
      "code_content": "def test_container_over_container_over_node():\n    # currently fails, and we don't expect this to work\n    a = ({node(1): node(\"1\")},)\n    to_data(a)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_node_over_container_over_container_over_node",
      "md_content": [],
      "code_start_line": 31,
      "code_end_line": 34,
      "params": [],
      "have_return": false,
      "code_content": "def test_node_over_container_over_container_over_node():\n    # currently fails\n    a = node(({node(1): node(\"1\")},))\n    to_data(a)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "opto\\trace\\bundle.py/to_data",
        "opto\\trace\\nodes.py/node"
      ],
      "special_reference_type": [
        false,
        false
      ]
    }
  ]
}